<!DOCTYPE html><html class="appearance-dark" lang="zh-CN"><head><meta charset="UTF-8"><title>学习记录之Servlet</title><meta name="description" content="welcome！"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.ico"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><link rel="stylesheet" href="/style/common/jquery.fancybox.min.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="1 Servlet1.2 调用流程
客户端发起请求： 客户端通过浏览器或其他客户端发送 HTTP 请求到服务器。
Web服务器接收请求： Web 服务器（如Tomcat）接收到客户端的请求。
Servlet容器处理请求： Servlet 容器（如Tomcat的Catalina）负责解析 HTTP 请求，确定请求的 Servlet，并调用相应的 Servlet。
加载和实例化 Servlet： 如果请求的 Servlet 尚未加载或实例化，Servlet 容器将加载并实例化相应的 Servlet 类。
调用Servlet的service方法： Servlet 容器调用 Servlet 的 service 方法，并将请求和响应对象传递给该方法。
Servlet处理请求： 在 service 方法中，开发人员编写.."><meta name="generator" content="Hexo 6.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">1PHAN's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">学习记录之Servlet</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">点击返回顶部</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-Servlet"><span class="toc-text">1 Servlet</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B"><span class="toc-text">1.2 调用流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-service%EF%BC%88%EF%BC%89"><span class="toc-text">1.3 service（）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%B0%9D%E8%AF%95"><span class="toc-text">2 第一个尝试</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC"><span class="toc-text">2.2 页面跳转</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E8%87%AA%E5%90%AF%E5%8A%A8%E9%85%8D%E7%BD%AE"><span class="toc-text">2.3 自启动配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-request%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">2.4 request常用方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-response%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">2.5 response常用方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#servlet%E9%85%8D%E5%90%88JDBC%E7%9A%84%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B"><span class="toc-text">servlet配合JDBC的使用案例</span></a></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/java"><i class="tag post-item-tag">java</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">学习记录之Servlet</h1><time class="has-text-grey" datetime="2023-12-20T11:36:59.000Z">2023-12-20</time><article class="mt-2 post-content"><h1 id="1-Servlet"><a href="#1-Servlet" class="headerlink" title="1 Servlet"></a>1 Servlet</h1><h2 id="1-2-调用流程"><a href="#1-2-调用流程" class="headerlink" title="1.2 调用流程"></a>1.2 调用流程</h2><ol>
<li><strong>客户端发起请求：</strong> 客户端通过浏览器或其他客户端发送 HTTP 请求到服务器。</li>
<li><strong>Web服务器接收请求：</strong> Web 服务器（如Tomcat）接收到客户端的请求。</li>
<li><strong>Servlet容器处理请求：</strong> Servlet 容器（如Tomcat的Catalina）负责解析 HTTP 请求，确定请求的 Servlet，并调用相应的 Servlet。</li>
<li><strong>加载和实例化 Servlet：</strong> 如果请求的 Servlet 尚未加载或实例化，Servlet 容器将加载并实例化相应的 Servlet 类。</li>
<li><strong>调用Servlet的service方法：</strong> Servlet 容器调用 Servlet 的 <code>service</code> 方法，并将请求和响应对象传递给该方法。</li>
<li><strong>Servlet处理请求：</strong> 在 <code>service</code> 方法中，开发人员编写的 Servlet 处理客户端的请求，生成响应内容。</li>
<li><strong>生成响应：</strong> Servlet 通过操作响应对象生成 HTML 页面或其他类型的响应内容。</li>
<li><strong>发送响应给客户端：</strong> Servlet 将生成的响应通过响应对象发送回客户端。</li>
<li><strong>Servlet容器处理响应：</strong> Servlet 容器接收到 Servlet 生成的响应后，将其发送给客户端，完成整个请求-响应周期。</li>
</ol>
<h2 id="1-3-service（）"><a href="#1-3-service（）" class="headerlink" title="1.3 service（）"></a>1.3 service（）</h2><ul>
<li><code>service</code> 方法是Servlet中处理请求的主要入口，负责分发请求到具体的处理方法。</li>
<li><code>doGet</code> 方法用于处理GET请求，适合从服务器获取数据。</li>
<li><code>doPost</code> 方法用于处理POST请求，适合向服务器提交数据。</li>
<li>一般情况下，如果你只关心一种请求类型，你可以选择只覆盖 <code>doGet</code> 或 <code>doPost</code> 中的一个。如果你需要处理两者，你可以覆盖 <code>service</code> 方法。</li>
</ul>
<pre><code class="java">import java.io.IOException;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class MyServlet extends HttpServlet {
    protected void service(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        if (request.getMethod().equals("GET")) {
            // 处理GET请求的逻辑
            doGet(request, response);
        } else if (request.getMethod().equals("POST")) {
            // 处理POST请求的逻辑
            doPost(request, response);
        }
        // 可以添加其他请求类型的处理逻辑
    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        // 处理GET请求的具体逻辑
    }

    protected void doPost(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        // 处理POST请求的具体逻辑
    }
}
</code></pre>
<h1 id="2-第一个尝试"><a href="#2-第一个尝试" class="headerlink" title="2 第一个尝试"></a>2 第一个尝试</h1><p>在webapp的包里创建一个html，设置好post请求以便于触发servlet。</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;form action="myweb" method="post"&gt;
        &lt;div&gt;
            &lt;span&gt;姓名:&lt;/span&gt;
            &lt;input name="name"&gt;

        &lt;/div&gt;
        &lt;div&gt;
            &lt;span&gt;密码:&lt;/span&gt;
            &lt;input name="password"&gt;
        &lt;/div&gt;
        &lt;button type="submit"&gt;提交&lt;/button&gt;
    &lt;/form&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>在src/main/java/com/example/demo1这个目录下创建myweb.java实现doPost请求</p>
<pre><code class="java">package com.example.demo1;

import com.sun.nio.sctp.AbstractNotificationHandler;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import java.io.IOException;

public class myweb extends HttpServlet {
    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        //super.doPost(req, resp);
        String name = req.getParameter("name");
        String password = req.getParameter("password");
        System.out.println(name);
        System.out.println(password);
    }
}
</code></pre>
<p>在webapp下的WEB-INF中的web.xml配置好关联信息</p>
<pre><code class="xml">        &lt;servlet&gt;
            &lt;servlet-name&gt;myweb&lt;/servlet-name&gt;
            &lt;servlet-class&gt;com.example.demo1.myweb&lt;/servlet-class&gt;
        &lt;/servlet&gt;

        &lt;servlet-mapping&gt;
            &lt;servlet-name&gt;myweb&lt;/servlet-name&gt;
            &lt;url-pattern&gt;/myweb&lt;/url-pattern&gt;
        &lt;/servlet-mapping&gt;

        &lt;welcome-file-list&gt;
            &lt;welcome-file&gt;myweb.html&lt;/welcome-file&gt;
        &lt;/welcome-file-list&gt;
</code></pre>
<p>==servlet-class在这里是全限定名==</p>
<p>启动tomcat之后可以观察到运行效果。</p>
<p><img src="/../images/image-20231220200342786.png" alt="image-20231220200342786"></p>
<p>证明我的post请求已经获取到了，开始进一步的学习。</p>
<h2 id="2-2-页面跳转"><a href="#2-2-页面跳转" class="headerlink" title="2.2 页面跳转"></a>2.2 页面跳转</h2><p>服务端跳转</p>
<pre><code class="java">package com.example.demo1;

import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import java.io.IOException;

public class tiaozhuan extends HttpServlet {
    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        String name = req.getParameter("name");
        String password = req.getParameter("password");
        if(name.equals("姓名") &amp;&amp; password.equals("123")){
            req.getRequestDispatcher("success.html").forward(req,resp);
        }else{
            req.getRequestDispatcher("fail.html").forward(req, resp);
        }
    }
}
</code></pre>
<p>客户端跳转</p>
<pre><code class="java">package com.example.demo1;

import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import java.io.IOException;

public class tiaozhuan extends HttpServlet {
    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        String name = req.getParameter("name");
        String password = req.getParameter("password");
        if(name.equals("姓名") &amp;&amp; password.equals("123")){
            
            resp.sendRedirect("success.html");
        }else{
            
            resp.sendRedirect("fail.html");
        }
    }
}
</code></pre>
<h2 id="2-3-自启动配置"><a href="#2-3-自启动配置" class="headerlink" title="2.3 自启动配置"></a>2.3 自启动配置</h2><p>在Servlet的<code>web.xml</code>配置文件中，<code>&lt;load-on-startup&gt;</code> 元素用于指定Servlet在应用启动时被加载的顺序。</p>
<pre><code class="xml">&lt;servlet&gt;
    &lt;servlet-name&gt;MyServlet&lt;/servlet-name&gt;
    &lt;servlet-class&gt;com.example.MyServlet&lt;/servlet-class&gt;
    &lt;load-on-startup&gt;10&lt;/load-on-startup&gt;
&lt;/servlet&gt;
</code></pre>
<p>这里的 <code>&lt;load-on-startup&gt;</code> 元素中的值是一个整数，表示Servlet的加载顺序。当应用启动时，容器会按照 <code>&lt;load-on-startup&gt;</code> 的值的升序来加载Servlet。值越小，加载的越早。如果多个Servlet有相同的 <code>&lt;load-on-startup&gt;</code> 值，容器可以自由选择加载的顺序。</p>
<p>使用 <code>&lt;load-on-startup&gt;</code> 的情况通常包括：</p>
<ol>
<li><strong>初始化操作：</strong> 如果Servlet在启动时需要执行一些初始化工作，可以通过在 <code>&lt;load-on-startup&gt;</code> 中指定一个值，确保在应用启动时就加载该Servlet。(比如要加载数据库等等操作)</li>
<li><strong>确保顺序：</strong> 在一些特定的场景，可能需要确保一些Servlet在应用启动时按照指定的顺序加载，以确保它们正确初始化。</li>
</ol>
<h2 id="2-4-request常用方法"><a href="#2-4-request常用方法" class="headerlink" title="2.4 request常用方法"></a>2.4 request常用方法</h2><p><code>HttpServletRequest</code> 接口提供了一系列用于获取客户端请求信息的方法。以下是一些 <code>HttpServletRequest</code> 中常用的方法：</p>
<ol>
<li><strong>获取请求行信息：</strong><ul>
<li><code>getMethod()</code>: 获取HTTP请求的方法，如GET、POST等。</li>
<li><code>getRequestURI()</code>: 获取请求的URI，不包含查询字符串。</li>
<li><code>getQueryString()</code>: 获取请求的查询字符串部分。</li>
</ul>
</li>
<li><strong>获取请求头信息：</strong><ul>
<li><code>getHeader(String name)</code>: 获取指定名称的请求头的值。</li>
<li><code>getHeaders(String name)</code>: 获取指定名称的请求头的所有值。</li>
<li><code>getHeaderNames()</code>: 获取所有的请求头名称。</li>
</ul>
</li>
<li><strong>获取请求参数：</strong><ul>
<li><code>getParameter(String name)</code>: 获取指定名称的请求参数的值。</li>
<li><code>getParameterValues(String name)</code>: 获取指定名称的请求参数的所有值。</li>
<li><code>getParameterMap()</code>: 获取所有请求参数的映射。</li>
<li><code>getParameterNames()</code>: 获取所有请求参数的名称。</li>
</ul>
</li>
<li><strong>获取客户端信息：</strong><ul>
<li><code>getRemoteAddr()</code>: 获取客户端的IP地址。</li>
<li><code>getRemotePort()</code>: 获取客户端的端口号。</li>
<li><code>getRemoteHost()</code>: 获取客户端的主机名。</li>
</ul>
</li>
<li><strong>获取会话信息：</strong><ul>
<li><code>getSession()</code>: 获取与请求关联的会话对象。</li>
<li><code>getSession(boolean create)</code>: 获取与请求关联的会话对象，如果不存在并且 <code>create</code> 为 <code>true</code>，则创建一个新的会话。</li>
</ul>
</li>
<li><strong>获取其他信息：</strong><ul>
<li><code>getLocale()</code>: 获取客户端请求的语言环境。</li>
<li><code>getInputStream()</code>: 获取请求的输入流，用于读取请求体的数据。</li>
<li><code>getReader()</code>: 获取请求的Reader，用于读取请求体的数据。</li>
<li><code>getServletContext()</code>: 获取Servlet上下文对象。</li>
</ul>
</li>
</ol>
<h2 id="2-5-response常用方法"><a href="#2-5-response常用方法" class="headerlink" title="2.5 response常用方法"></a>2.5 response常用方法</h2><p><code>HttpServletResponse</code> 接口提供了一系列用于设置响应的方法。以下是一些 <code>HttpServletResponse</code> 中常用的方法：</p>
<ol>
<li><strong>设置响应内容类型和字符编码：</strong><ul>
<li><code>setContentType(String type)</code>: 设置响应的内容类型（MIME类型）。</li>
<li><code>setCharacterEncoding(String charset)</code>: 设置响应的字符编码。</li>
</ul>
</li>
<li><strong>设置响应状态和头信息：</strong><ul>
<li><code>setStatus(int sc)</code>: 设置响应的状态码，例如200表示成功。</li>
<li><code>sendError(int sc, String msg)</code>: 发送一个错误响应。</li>
<li><code>sendRedirect(String location)</code>: 发送一个重定向响应。</li>
<li><code>addHeader(String name, String value)</code>: 添加一个响应头。</li>
<li><code>setHeader(String name, String value)</code>: 设置一个响应头。</li>
</ul>
</li>
<li><strong>设置响应内容：</strong><ul>
<li><code>getWriter()</code>: 获取一个 PrintWriter 对象，用于向客户端写入字符数据。</li>
<li><code>getOutputStream()</code>: 获取一个 ServletOutputStream 对象，用于向客户端写入二进制数据。</li>
<li><code>setCharacterEncoding(String charset)</code>: 设置字符编码。</li>
<li><code>setContentLength(int len)</code>: 设置响应内容长度。</li>
<li><code>setContentLengthLong(long len)</code>: 设置响应内容长度（长整型）。</li>
<li><code>setBufferSize(int size)</code>: 设置响应缓冲区的大小。</li>
</ul>
</li>
<li><strong>缓存控制：</strong><ul>
<li><code>setDateHeader(String name, long date)</code>: 设置响应头中日期字段的值。</li>
<li><code>addDateHeader(String name, long date)</code>: 添加响应头中日期字段的值。</li>
<li><code>setExpires(long expires)</code>: 设置响应过期的日期。</li>
<li><code>addHeader(String name, String value)</code>: 添加响应头。</li>
</ul>
</li>
<li><strong>Cookie：</strong><ul>
<li><code>addCookie(Cookie cookie)</code>: 添加一个Cookie到响应。</li>
</ul>
</li>
<li><strong>重定向和错误处理：</strong><ul>
<li><code>sendRedirect(String location)</code>: 发送一个重定向响应。</li>
<li><code>sendError(int sc)</code>: 发送一个错误响应。</li>
</ul>
</li>
<li><strong>其他方法：</strong><ul>
<li><code>flushBuffer()</code>: 强制将响应的缓冲区内容发送到客户端。</li>
<li><code>reset()</code>: 重置响应，清除所有设置。</li>
</ul>
</li>
</ol>
<h1 id="servlet配合JDBC的使用案例"><a href="#servlet配合JDBC的使用案例" class="headerlink" title="servlet配合JDBC的使用案例"></a>servlet配合JDBC的使用案例</h1></article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><em></em><a class="button is-default" href="/2023/12/20/git%E4%B8%AD%E5%87%BA%E7%8E%B0%E8%AE%BF%E9%97%AE403%E7%9A%84%E9%97%AE%E9%A2%98/" title="git中出现访问403的问题"><span class="has-text-weight-semibold">下一页: git中出现访问403的问题</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><a title="twitter" target="_blank" rel="noopener nofollow" href="//twitter.com//"><i class="iconfont icon-twitter"></i></a><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/https://github.com/1PHAN-7878"><i class="iconfont icon-github"></i></a><!-- Ins--><a title="instagram" target="_blank" rel="noopener nofollow" href="//www.instagram.com//"><i class="iconfont icon-ins"></i></a><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--><a title="facebook" target="_blank" rel="noopener nofollow" href="//www.facebook.com//"><i class="iconfont icon-tian7_facebook"></i></a></section><p><span>Copyright ©</span><span> 1PHAN 2023</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/jquery-3.6.1.min.js"></script><script src="/js/jquery-fancybox.min.js"></script><script src="/js/img_zoom.js"></script><script src="/js/post.js"></script></body></html>