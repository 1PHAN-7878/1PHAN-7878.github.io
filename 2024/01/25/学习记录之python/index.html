<!DOCTYPE html><html class="appearance-dark" lang="zh-CN"><head><meta charset="UTF-8"><title>学习记录之python</title><meta name="description" content="welcome！"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.ico"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><link rel="stylesheet" href="/style/common/jquery.fancybox.min.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="1 入print('Hello World!')

python可视化：pythontutor.com
1.1 注释
单行注释 #

多行注释 ‘’’ “””
# 这是单行注释
'''
多行注释
'''
&quot;&quot;&quot;
多行注释
&quot;&quot;&quot;



1.2 拷贝
浅拷贝（Shallow Copy）：浅拷贝创建一个新的对象，但是它只复制了原始对象中的引用。也就是说，新对象和原始对象共享相同的数据。浅拷贝通常适用于简单的数据结构，如列表、字典等。（一个修改了，另一个也修改了）
import copy

# 列表的浅拷贝
list1 = [1, 2, 3]
list2 = copy.copy(list1)
print(list2)  # 输出 [1, 2, 3]

# 字典的浅拷贝
dict1 = {'name': 'Alic.."><meta name="generator" content="Hexo 6.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">1PHAN's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">学习记录之python</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">点击返回顶部</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E5%85%A5"><span class="toc-text">1 入</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E6%B3%A8%E9%87%8A"><span class="toc-text">1.1 注释</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E6%8B%B7%E8%B4%9D"><span class="toc-text">1.2 拷贝</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E5%8F%98%E9%87%8F"><span class="toc-text">2 变量</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B"><span class="toc-text">2.1 变量类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E8%BE%93%E5%85%A5"><span class="toc-text">2.2 输入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96"><span class="toc-text">2.3 强制类型转化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2"><span class="toc-text">2.4 隐式转换</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E8%BF%90%E7%AE%97"><span class="toc-text">3 运算</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97"><span class="toc-text">3.1 算术运算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">3.2 关系运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E6%88%90%E5%91%98%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">3.3 成员运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">3.4 逻辑运算符</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E5%88%86%E6%94%AF%E5%BE%AA%E7%8E%AF"><span class="toc-text">4 分支循环</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84"><span class="toc-text">4.1 分支结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E5%BE%AA%E7%8E%AF"><span class="toc-text">4.2 循环</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">5 字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA"><span class="toc-text">5.1 格式化输出</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E6%93%8D%E4%BD%9C"><span class="toc-text">5.2 操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81"><span class="toc-text">5.3 编码解码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-ASCII-%E8%BD%AC%E6%8D%A2"><span class="toc-text">5.4 ASCII 转换</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E5%88%97%E8%A1%A8"><span class="toc-text">6 列表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-%E7%89%B9%E5%BE%81"><span class="toc-text">6.1 特征</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C"><span class="toc-text">6.2 常见操作</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E5%AD%97%E5%85%B8"><span class="toc-text">7 字典</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-%E9%9B%86%E5%90%88"><span class="toc-text">8 集合</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-%E5%85%83%E7%BB%84"><span class="toc-text">9 元组</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-%E5%87%BD%E6%95%B0"><span class="toc-text">10 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#10-1-%E5%9F%BA%E6%9C%AC%E8%B0%83%E7%94%A8"><span class="toc-text">10.1 基本调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-2-%E5%8F%82%E6%95%B0"><span class="toc-text">10.2 参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-3-%E4%BD%BF%E7%94%A8%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-text">10.3 使用全局变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-4-filter%E7%AD%9B%E9%80%89%E5%87%BD%E6%95%B0"><span class="toc-text">10.4 filter筛选函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-5-map-%E5%87%BD%E6%95%B0"><span class="toc-text">10.5 map()函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-6-%E8%A3%85%E9%A5%B0%E5%99%A8%E5%87%BD%E6%95%B0"><span class="toc-text">10.6 装饰器函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-%E6%A8%A1%E5%9D%97"><span class="toc-text">11 模块</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#11-1-%E6%A8%A1%E5%9D%97%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-text">11.1 模块基本操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-2-os%E6%A8%A1%E5%9D%97"><span class="toc-text">11. 2 os模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-3-random%E6%A8%A1%E5%9D%97"><span class="toc-text">11.3 random模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-4-datetime%E6%A8%A1%E5%9D%97"><span class="toc-text">11. 4 datetime模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-5-time%E6%A8%A1%E5%9D%97"><span class="toc-text">11. 5 time模块</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12-%E7%B1%BB"><span class="toc-text">12 类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#12-1-%E5%88%9D%E5%A7%8B%E5%8C%96%E7%B1%BB"><span class="toc-text">12.1 初始化类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-2-%E7%B1%BB%E5%B1%9E%E6%80%A7%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7"><span class="toc-text">12.2 类属性和对象属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-3-%E7%BB%A7%E6%89%BF"><span class="toc-text">12.3 继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-4-%E7%B1%BB%E6%96%B9%E6%B3%95%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-text">12.4 类方法和静态方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-5-%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95"><span class="toc-text">12.5 私有属性私有方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-6-%E5%A4%9A%E6%80%81"><span class="toc-text">12.6 多态</span></a></li></ol></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/python"><i class="tag post-item-tag">python</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">学习记录之python</h1><time class="has-text-grey" datetime="2024-01-25T13:56:25.000Z">2024-01-25</time><article class="mt-2 post-content"><h1 id="1-入"><a href="#1-入" class="headerlink" title="1 入"></a>1 入</h1><pre><code class="python">print('Hello World!')
</code></pre>
<p>python可视化：pythontutor.com</p>
<h2 id="1-1-注释"><a href="#1-1-注释" class="headerlink" title="1.1 注释"></a>1.1 注释</h2><ul>
<li><p>单行注释 #</p>
</li>
<li><p>多行注释 ‘’’ “””</p>
<pre><code class="python"># 这是单行注释
'''
多行注释
'''
"""
多行注释
"""
</code></pre>
</li>
</ul>
<h2 id="1-2-拷贝"><a href="#1-2-拷贝" class="headerlink" title="1.2 拷贝"></a>1.2 拷贝</h2><ul>
<li><p>浅拷贝（Shallow Copy）：浅拷贝创建一个新的对象，但是它只复制了原始对象中的引用。也就是说，新对象和原始对象<strong>共享相同的数据</strong>。浅拷贝通常适用于简单的数据结构，如列表、字典等。（一个修改了，另一个也修改了）</p>
<pre><code class="python">import copy

# 列表的浅拷贝
list1 = [1, 2, 3]
list2 = copy.copy(list1)
print(list2)  # 输出 [1, 2, 3]

# 字典的浅拷贝
dict1 = {'name': 'Alice', 'age': 20}
dict2 = copy.copy(dict1)
print(dict2)  # 输出 {'name': 'Alice', 'age': 20}
</code></pre>
</li>
<li><p>深拷贝（Deep Copy）：深拷贝创建一个完全独立的新对象，并且递归地复制原始对象及其所有嵌套的对象。深拷贝在处理复杂的数据结构时非常有用，如嵌套的列表、字典等。</p>
<pre><code class="python">import copy

# 列表的深拷贝
list1 = [1, 2, [3, 4]]
list2 = copy.deepcopy(list1)
print(list2)  # 输出 [1, 2, [3, 4]]

# 字典的深拷贝
dict1 = {'name': 'Alice', 'info': {'age': 20}}
dict2 = copy.deepcopy(dict1)
print(dict2)  # 输出 {'name': 'Alice', 'info': {'age': 20}}
</code></pre>
</li>
</ul>
<h1 id="2-变量"><a href="#2-变量" class="headerlink" title="2 变量"></a>2 变量</h1><p>无需定义变量类型</p>
<pre><code class="python">name = "chichu"
age = 18
num = 4.3
a, b = 23, 4.2
</code></pre>
<p>输出</p>
<pre><code class="python">print(name1, name2) # 默认空格分隔
print(name1, name2, sep = '$$')  # 分隔是$$
print(name1, name2, end='333') # 默认结尾'\n'
</code></pre>
<h2 id="2-1-变量类型"><a href="#2-1-变量类型" class="headerlink" title="2.1 变量类型"></a>2.1 变量类型</h2><ul>
<li><p>Number 数字</p>
<ul>
<li>int float bool</li>
</ul>
<pre><code class="python">a = 1, b = 2, bool = True
</code></pre>
</li>
<li><p>String </p>
<pre><code class="python">str1 = 'H1'
str2 = '''
duoduo
shaos
'''
</code></pre>
</li>
<li><p>List 列表</p>
</li>
<li><p>Tuple 元组</p>
</li>
<li><p>Dict 字典</p>
</li>
<li><p>Set 集合</p>
</li>
</ul>
<h2 id="2-2-输入"><a href="#2-2-输入" class="headerlink" title="2.2 输入"></a>2.2 输入</h2><p>input 函数</p>
<pre><code class="python">name = input('请输入您的姓名：')
print(f'Hello, {name}!')
</code></pre>
<h2 id="2-3-强制类型转化"><a href="#2-3-强制类型转化" class="headerlink" title="2.3 强制类型转化"></a>2.3 强制类型转化</h2><ul>
<li><p>整形转化</p>
<pre><code class="python">x = int(3.14)  # 将浮点型转换为整型，结果为 3
y = int('123')  # 将字符串转换为整型，结果为 123
</code></pre>
</li>
<li><p>浮点型转化</p>
<pre><code>x = float(3)  # 将整型转换为浮点型，结果为 3.0
y = float('3.14')  # 将字符串转换为浮点型，结果为 3.14
</code></pre>
</li>
<li><p>字符串</p>
<pre><code class="python">x = str(123)  # 将整型转换为字符串，结果为 '123'
y = str(3.14)  # 将浮点型转换为字符串，结果为 '3.14'
</code></pre>
</li>
<li><p>列表</p>
<pre><code class="python">str1 = 'hello1'
print(list(str1)) # ['h', 'e', 'l', 'l', 'o', '1']
</code></pre>
</li>
</ul>
<h2 id="2-4-隐式转换"><a href="#2-4-隐式转换" class="headerlink" title="2.4 隐式转换"></a>2.4 隐式转换</h2><ul>
<li><p>整形浮点型</p>
<pre><code class="python">a = 10
b = 3.14
c = a + b  # a 会被自动转换为 10.0，结果为 13.14
</code></pre>
</li>
<li><p>字符串与数字型</p>
<pre><code class="python">a = '10'
b = 3.14
c = a + b  # a 会被自动转换为整型，结果为 13.14
</code></pre>
</li>
<li><p>布尔型与整型</p>
<pre><code class="python">a = True
b = 3
c = a + b  # True 会被自动转换为整型 1，结果为 4
</code></pre>
</li>
</ul>
<h1 id="3-运算"><a href="#3-运算" class="headerlink" title="3 运算"></a>3 运算</h1><h2 id="3-1-算术运算"><a href="#3-1-算术运算" class="headerlink" title="3.1 算术运算"></a>3.1 算术运算</h2><table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>加法</td>
</tr>
<tr>
<td>-</td>
<td>减法</td>
</tr>
<tr>
<td>*</td>
<td>乘法</td>
</tr>
<tr>
<td>/</td>
<td>除法</td>
</tr>
<tr>
<td>%</td>
<td>取余</td>
</tr>
<tr>
<td>**</td>
<td>幂运算</td>
</tr>
<tr>
<td>//</td>
<td>整数除法（向下取整）</td>
</tr>
</tbody></table>
<p>==python中没有a++，a–==</p>
<h2 id="3-2-关系运算符"><a href="#3-2-关系运算符" class="headerlink" title="3.2 关系运算符"></a>3.2 关系运算符</h2><table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>==</td>
<td>检查两个值是否相等</td>
</tr>
<tr>
<td>!=</td>
<td>检查两个值是否不相等</td>
</tr>
<tr>
<td>&gt;</td>
<td>检查左操作数是否大于右操作数</td>
</tr>
<tr>
<td>&lt;</td>
<td>检查左操作数是否小于右操作数</td>
</tr>
<tr>
<td>&gt;=</td>
<td>检查左操作数是否大于或等于右操作数</td>
</tr>
<tr>
<td>&lt;=</td>
<td>检查左操作数是否小于或等于右操作数</td>
</tr>
</tbody></table>
<h2 id="3-3-成员运算符"><a href="#3-3-成员运算符" class="headerlink" title="3.3 成员运算符"></a>3.3 成员运算符</h2><table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>in</td>
<td>如果在序列中找到具有相应值的项，则为 True</td>
</tr>
<tr>
<td>not in</td>
<td>如果在序列中没有找到具有相应值的项，则为 True</td>
</tr>
<tr>
<td>is</td>
<td>判断两个变量是否引用了同一个对象（通常用于判断 None 变量）</td>
</tr>
<tr>
<td>is not</td>
<td>判断两个变量是否没有引用同一个对象</td>
</tr>
</tbody></table>
<pre><code class="python"># 检查元素是否在列表中
fruits = ["apple", "banana", "cherry"]
print("apple" in fruits)  # 输出 True

# 检查键是否在字典中
ages = {"Tom": 18, "Jack": 20, "Mary": 22}
print("Tom" in ages)  # 输出 True
print("John" not in ages)  # 输出 True

# 检查变量是否为 None
x = None
print(x is None)  # 输出 True
</code></pre>
<h2 id="3-4-逻辑运算符"><a href="#3-4-逻辑运算符" class="headerlink" title="3.4 逻辑运算符"></a>3.4 逻辑运算符</h2><table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>and</td>
<td>如果两个操作数都为 True，则计算结果为 True</td>
</tr>
<tr>
<td>or</td>
<td>如果两个操作数中有任意一个为 True，则计算结果为 True</td>
</tr>
<tr>
<td>not</td>
<td>取反操作，如果操作数为 True，则返回 False</td>
</tr>
</tbody></table>
<pre><code class="python"># and 运算符，例如判断数值是否在指定范围内
x = 5
print(x &gt; 0 and x &lt; 10)  # 输出 True

# or 运算符，例如判断字符串是否包含某个字符
text = "Hello, world!"
print("e" in text or "a" in text)  # 输出 True

# not 运算符，例如取反操作
is_valid = True
print(not is_valid)  # 输出 False
</code></pre>
<h1 id="4-分支循环"><a href="#4-分支循环" class="headerlink" title="4 分支循环"></a>4 分支循环</h1><h2 id="4-1-分支结构"><a href="#4-1-分支结构" class="headerlink" title="4.1 分支结构"></a>4.1 分支结构</h2><pre><code class="python">score = 75
if score &gt;= 90:
    grade = 'A'
elif score &gt;= 80:
    grade = 'B'
elif score &gt;= 70:
    grade = 'C'
elif score &gt;= 60:
    grade = 'D'
else:
    grade = 'F'
print("成绩等级是：", grade)
</code></pre>
<h2 id="4-2-循环"><a href="#4-2-循环" class="headerlink" title="4.2 循环"></a>4.2 循环</h2><pre><code class="python">count = 0

while count &lt; 5:
    print("当前计数: ", count)
    count += 1

print("循环结束")
</code></pre>
<pre><code class="python">fruits = ["apple", "banana", "cherry"]
for fruit in fruits:
    print(fruit)

fruits = ["apple", "banana", "cherry"]
for index, fruit in enumerate(fruits):
    print(index, fruit)

for i in range(5): # 0 ~ 4
    print(i)
for i in range(1, 6) # 1 ~ 5
</code></pre>
<h1 id="5-字符串"><a href="#5-字符串" class="headerlink" title="5 字符串"></a>5 字符串</h1><ul>
<li>外面使用单引号，内部屏蔽单引号，双引号同理</li>
<li>转义字符</li>
</ul>
<ul>
<li>\`：反斜杠（用于表示反斜杠字符）。</li>
<li><code>\'</code>：单引号（用于表示单引号字符）。</li>
<li><code>\"</code>：双引号（用于表示双引号字符）。</li>
<li><code>\n</code>：换行符（将光标移到下一行的开头位置）。</li>
<li><code>\r</code>：回车符（将光标移到当前行的开头位置）。</li>
<li><code>\t</code>：制表符（在输出中创建水平制表或跳到下一个制表位置）。</li>
<li><code>\b</code>：退格符（将光标向左移动一个位置）。</li>
<li><code>\f</code>：换页符（在输出中创建一个新页）。</li>
</ul>
<p>加上r开头无视制表符</p>
<h2 id="5-1-格式化输出"><a href="#5-1-格式化输出" class="headerlink" title="5.1 格式化输出"></a>5.1 格式化输出</h2><pre><code class="python">name = "cc"
print(f"my name is {name}")
</code></pre>
<pre><code class="python">name = "John"
age = 25
print("My name is %s and I am %d years old." % (name, age))
</code></pre>
<pre><code class="python">name = "John"
age = 25
print("My name is {} and I am {} years old.".format(name, age))
</code></pre>
<h2 id="5-2-操作"><a href="#5-2-操作" class="headerlink" title="5.2 操作"></a>5.2 操作</h2><ul>
<li><p>下标访问</p>
<pre><code class="python">text = "Hello, World!"
print(text[0])  # 访问第一个字符
print(text[7])  # 访问第八个字符
print(text[-1])  # 访问最后一个字符
print(text[-6])  # 访问倒数第六个字符
</code></pre>
</li>
<li><p>切片</p>
<p><code>[start:stop:step]</code> 格式，其中：</p>
<ul>
<li><code>start</code> 是起始索引（默认为 0）</li>
<li><code>stop</code> 是结束索引（不包含在切片结果中）</li>
<li><code>step</code> 是步长（默认为 1）</li>
</ul>
<pre><code class="python">text = "Hello, World!"
print(text[7:12])   # 提取索引从7到11的字符
print(text[-6:-1])    # 提取倒数第六个到倒数第二个字符

my_list = [1, 2, 3, 4, 5]
print(my_list[1:4])  # 提取索引从1到3的元素
print(my_list[::-1])  # 逆序提取所有元素

my_tuple = ('apple', 'banana', 'cherry', 'date')
print(my_tuple[::2])  # 按照步长为2提取所有元素
print(my_tuple[-2:-5:-1])  # 逆序提取倒数第二到倒数第四个元素
</code></pre>
</li>
<li><p>操作函数</p>
<ol>
<li><p><code>len(string)</code>：返回字符串的长度。</p>
</li>
<li><p><code>string.lower()</code>：将字符串中的字符转换为小写形式。</p>
</li>
<li><p><code>string.upper()</code>：将字符串中的字符转换为大写形式。</p>
</li>
<li><p><code>string.capitalize()</code>：将字符串的首字母转换为大写形式，其余字符转换为小写形式。</p>
</li>
<li><p><code>string.title()</code>：将字符串中每个单词的首字母转换为大写形式，其余字符转换为小写形式。</p>
</li>
<li><p><code>string.strip()</code>：去除字符串开头和结尾的空格或指定字符。</p>
</li>
<li><p><code>string.split(sep)</code>：根据分隔符 <code>sep</code> 将字符串拆分成子字符串，并返回一个列表。</p>
</li>
<li><p><code>string.join(iterable)</code>：将可迭代对象 <code>iterable</code> 中的字符串元素连接起来，中间使用 <code>string</code> 分隔。</p>
<pre><code class="python">string = "-"
my_list = ["apple", "banana", "cherry"]
result = string.join(my_list)
print(result)
 # apple-banana-cherry
</code></pre>
</li>
<li><p><code>string.replace(old, new)</code>：将字符串中的所有匹配 <code>old</code> 的子串替换为 <code>new</code>。</p>
</li>
<li><p><code>string.startswith(prefix)</code>：检查字符串是否以指定的前缀 <code>prefix</code> 开头，返回布尔值。</p>
</li>
<li><p><code>string.endswith(suffix)</code>：检查字符串是否以指定的后缀 <code>suffix</code> 结尾，返回布尔值。</p>
</li>
<li><p><code>string.find(substring)</code>：在字符串中查找子串 <code>substring</code> 的第一个匹配位置，并返回索引值。</p>
</li>
<li><p><code>string.count(substring)</code>：统计字符串中子串 <code>substring</code> 出现的次数。</p>
</li>
<li><p><code>string.isalpha()</code>：检查字符串是否只包含字母字符。</p>
</li>
<li><p><code>string.isdigit()</code>：检查字符串是否只包含数字字符。</p>
</li>
</ol>
</li>
</ul>
<h2 id="5-3-编码解码"><a href="#5-3-编码解码" class="headerlink" title="5.3 编码解码"></a>5.3 编码解码</h2><pre><code class="python"># 编码示例
string = "你好，世界！"  # 普通字符串
byte_string = string.encode("utf-8")  # 编码为字节字符串
print(byte_string)  # 输出：b'\xe4\xbd\xa0\xe5\xa5\xbd\xef\xbc\x8c\xe4\xb8\x96\xe7\x95\x8c\xef\xbc\x81'

# 解码示例
decoded_string = byte_string.decode("utf-8")  # 解码为普通字符串
print(decoded_string)  # 输出：你好，世界！
</code></pre>
<h2 id="5-4-ASCII-转换"><a href="#5-4-ASCII-转换" class="headerlink" title="5.4 ASCII 转换"></a>5.4 ASCII 转换</h2><pre><code class="python"># ASCII 码转字符示例
ascii_value = 65  # ASCII 码值
character = chr(ascii_value)  # 转换为字符
print(character)  # 输出：A

# 字符转 ASCII 码示例
character = 'A'  # 字符
ascii_value = ord(character)  # 转换为 ASCII 码值
print(ascii_value)  # 输出：65
</code></pre>
<h1 id="6-列表"><a href="#6-列表" class="headerlink" title="6 列表"></a>6 列表</h1><h2 id="6-1-特征"><a href="#6-1-特征" class="headerlink" title="6.1 特征"></a>6.1 特征</h2><ul>
<li>有序性：列表中的元素按照它们在列表中的位置顺序进行存储和访问，可以通过索引来访问和修改特定位置的元素。索引从 0 开始，第一个元素的索引为 0，第二个元素的索引为 1，依此类推。</li>
<li>可变性：列表中的元素可以随时被修改、替换或删除，也可以在任意位置插入新元素。这意味着列表的长度和内容都是可变的。</li>
<li>可重复性：列表中可以包含重复的元素，即同一个值可以出现多次。</li>
<li>多样性：列表可以容纳不同类型的元素，例如整数、浮点数、字符串、布尔值等。</li>
</ul>
<h2 id="6-2-常见操作"><a href="#6-2-常见操作" class="headerlink" title="6.2 常见操作"></a>6.2 常见操作</h2><p>创建列表：</p>
<pre><code class="python">empty_list = []  # 创建一个空列表
my_list = [1, 2, 3, 'a', 'b', 'c']  # 创建一个包含元素的列表
</code></pre>
<p>访问和修改元素：</p>
<pre><code class="python">my_list = ['a', 'b', 'c']
print(my_list[0])  # 输出：'a'
my_list[1] = 'd'
print(my_list)  # 输出：['a', 'd', 'c']
</code></pre>
<p>添加元素：</p>
<pre><code class="python">my_list = ['a', 'b', 'c']
my_list.append('d')
print(my_list)  # 输出：['a', 'b', 'c', 'd']

# 如果直接append列表，就变成二维列表了
list1 = my_list.copy()
list1.append([23,43]) # ['a', 'b', 'c', 'd', [23, 43]]

# 选择extend会进行一次拆分
list2 = my_list.copy()
list2.extend(["34", "34"]) # 等价于list2 += ["34", "34"], ['a', 'b', 'c', 'd', '34', '34']
list2.extend("qqqe") # ['a', 'b', 'c', 'd', '34', '34']

my_list = [1, 2, 3, 4]
my_list.insert(2, 5)
print(my_list) # [1, 2, 5, 3, 4]
</code></pre>
<p>删除元素：</p>
<pre><code class="python">my_list = ['a', 'b', 'c']
del my_list[1]  # 删除索引为1的元素
print(my_list)  # 输出：['a', 'c']

my_list.remove('a')  # 删除值为'a'的元素
print(my_list)  # 输出：['c']
my_list.pop(0)  # 删除索引0的位置的元素，无参数是删除最后一个
my_list.clear()  # 清空
</code></pre>
<p>切片操作：</p>
<pre><code class="python">my_list = [1, 2, 3, 4, 5]
sub_list = my_list[1:3]  # 获取索引为1到2的子列表
print(sub_list)  # 输出：[2, 3]
</code></pre>
<p>列表长度：</p>
<pre><code class="python">my_list = [1, 2, 3, 4, 5]
length = len(my_list)
print(length)  # 输出：5
</code></pre>
<p>其他操作：</p>
<pre><code class="python">my_list.reverse()  # 反转列表元素
print(my_list)  # 输出：[5, 4, 3, 2, 1]

another_list = [6, 7, 8]
my_list.extend(another_list)  # 将另一个列表的元素添加到当前列表
print(my_list)  # 输出：[5, 4, 3, 2, 1, 6, 7, 8]

count = my_list.count(5)  # 统计5在列表中出现的次数
print(count)  # 输出：1
</code></pre>
<p>遍历：</p>
<pre><code class="python">my_list = ['a', 'b', 'c']

for index, value in enumerate(my_list): # 获取索引和元素
    print(index, value)
</code></pre>
<p>排序：</p>
<pre><code class="python">my_list = [3, 1, 4, 2, 5]
my_list.sort()  # 对列表进行升序排序
my_list.sort(reverse=True)  # 进行降序
print(my_list)  # 输出：[1, 2, 3, 4, 5]，对本身列表进行改变

# sorted(iterable, key=None, reverse=False)
list1 = sorted(my_list)  # 生成新的列表
list1 = sorted(my_list, reverse=True)  # 降序

my_list = ['apple', 'banana', 'cherry', 'date']
sorted_list = sorted(my_list, key=len)

print(sorted_list)  # ['date', 'apple', 'cherry', 'banana']
</code></pre>
<p>列表生成：</p>
<pre><code class="python">list1 = [None] * 10

list2 = list(range(1, 11))

list3 = [i * 2 for i in range(1, 6)]
</code></pre>
<h1 id="7-字典"><a href="#7-字典" class="headerlink" title="7 字典"></a>7 字典</h1><pre><code class="python">person = {
    "name": "Alice",
    "age": 27,
    "city": "Beijing"
}
print(person["name"])  # 访问键为"name"的值："Alice"
person["age"] = 28  # 修改键为"age"的值为28
print(person)  # 打印整个字典：{'name': 'Alice', 'age': 28, 'city': 'Beijing'}

person["email"] = "alice@example.com"  # 添加新的键值对
print(person)  # 打印整个字典，包含新的键值对：{'name': 'Alice', 'age': 28, 'city': 'Beijing', 'email': 'alice@example.com'}

del person["city"]  # 删除键为"city"的键值对
print(person)  # 打印整个字典，不再包含"city"键值对：{'name': 'Alice', 'age': 28, 'email': 'alice@example.com'}

length = len(person)  # 获取字典的长度
print(length)  # 打印字典长度：3
</code></pre>
<pre><code class="python">person.key()  # 所有的键
person.value()  # 所有的键值
person.item()  # 所有的项
for i in person:  # 遍历所有的key()
    print(i)
for key, value in enumerate(person):  # 带下标的key
    print(key, value)
for key, value in person.items():  # 遍历所有
    print(key, value)
for v in person.value()  # 遍历键值
    print(v)

  # 合并
dict1 = {"name": "Alice", "age": 27}
dict2 = {"city": "Beijing", "email": "alice@example.com"}

dict1.update(dict2)  # 合并字典

print(dict1)  # 打印合并后的字典：{'name': 'Alice', 'age': 27, 'city': 'Beijing', 'email': 'alice@example.com'}
</code></pre>
<h1 id="8-集合"><a href="#8-集合" class="headerlink" title="8 集合"></a>8 集合</h1><ol>
<li>无序性：集合中的元素没有固定的顺序，每次输出的顺序可能不同。</li>
<li>唯一性：集合中的元素是唯一的，不允许有重复的元素。</li>
<li>可变性：集合是可变的，可以通过添加或删除元素来修改集合。</li>
<li>集合元素必须是可哈希的：集合中的元素必须是可哈希的，即不可变的（例如数字、字符串、元组），但不支持可变类型（例如列表、字典）。</li>
<li>数学操作：可以进行集合间的数学操作，如并集、交集和差集等。</li>
</ol>
<pre><code class="python"># 创建集合
set1 = {1, 2, 3}
set2 = set([3, 4, 5])

# 添加元素
set1.add(4)
print(set1)  # 输出 {1, 2, 3, 4}

# 删除元素
set2.remove(4)
print(set2)  # 输出 {3, 5}

# 集合运算
union_set = set1.union(set2)  # 并集
intersection_set = set1.intersection(set2)  # 交集
difference_set = set1.difference(set2)  # 差集
print(union_set)  # 输出 {1, 2, 3, 5}
print(intersection_set)  # 输出 {3}
print(difference_set)  # 输出 {1, 2, 4}
</code></pre>
<h1 id="9-元组"><a href="#9-元组" class="headerlink" title="9 元组"></a>9 元组</h1><ol>
<li>有序性：元组中的元素按照定义的顺序排列，并且保持不变。</li>
<li>不可变性：元组的元素不能被修改，添加或删除。一旦创建，元组的内容就不可更改。</li>
<li>支持多种数据类型：元组可以包含不同类型的数据，例如整数、浮点数、字符串等。</li>
<li>可用于索引和切片：可以使用索引和切片操作访问元组中的元素。</li>
</ol>
<pre><code class="python"># 创建元组
tuple1 = (1, 2, 3)
tuple2 = tuple([4, 5, 6])

# 访问元素
print(tuple1[0])  # 输出 1
print(tuple2[1:])  # 输出 (5, 6)

# 元组拼接
tuple3 = tuple1 + tuple2
print(tuple3)  # 输出 (1, 2, 3, 4, 5, 6)

# 元组解包
a, b, c = tuple1
print(a, b, c)  # 输出 1 2 3

# 遍历元组
for item in tuple2:
    print(item)  # 输出 4 5 6
</code></pre>
<ul>
<li>需要注意的是，元组是不可变的，这意味着一旦创建，就不能修改元组中的元素。如果需要修改元素，可以将元组转换为列表进行修改，然后再转换回元组。</li>
</ul>
<pre><code class="python">tuple4 = (1, 2, 3)
list4 = list(tuple4)
list4[0] = 4
tuple4 = tuple(list4)
print(tuple4)  # 输出 (4, 2, 3)
</code></pre>
<h1 id="10-函数"><a href="#10-函数" class="headerlink" title="10 函数"></a>10 函数</h1><h2 id="10-1-基本调用"><a href="#10-1-基本调用" class="headerlink" title="10.1 基本调用"></a>10.1 基本调用</h2><p>定义函数：使用 <code>def</code> 关键字来定义一个函数，并给函数取一个名称。函数名称后面跟着一对圆括号 <code>()</code>，括号中可以包含参数（可选），参数用于接收传递给函数的值。函数体以冒号 <code>:</code> 开始，并通过缩进来表示函数体内的代码块。</p>
<pre><code class="python">def greet():
    print("Hello, world!")

def add(a, b):
    return a + b
</code></pre>
<p>调用函数：当需要执行函数内的代码时，通过函数名称后跟一对圆括号 <code>()</code> 来调用函数。如果函数有参数，需要在括号中传递相应的值。</p>
<pre><code class="python">greet()  # 调用 greet 函数，输出 "Hello, world!"

result = add(3, 5)  # 调用 add 函数，并将返回值赋给 result 变量
print(result)  # 输出 8
</code></pre>
<h2 id="10-2-参数"><a href="#10-2-参数" class="headerlink" title="10.2 参数"></a>10.2 参数</h2><ul>
<li><p>默认参数</p>
<pre><code class="python">def greet(name, greeting="Hello"):
    """
    给定名称和问候语，打印出个性化的问候信息。
    
    Args:
        name (str): 要问候的人的名称。
        greeting (str, optional): 问候语，默认为"Hello"。
    """
    message = f"{greeting}, {name}!"
    print(message)

# 不指定 greeting 参数的值，默认使用 "Hello"
greet("Alice")  # 输出：Hello, Alice!

# 传递自定义的 greeting 参数值
greet("Bob", "Hi")  # 输出：Hi, Bob!
</code></pre>
</li>
<li><p>不定长参数</p>
<pre><code class="python">def my_func(*args):
    """
    接收任意数量的位置参数，并打印出来。
    
    Args:
        *args: 任意数量的位置参数。
    """
    for arg in args:
        print(arg)

# 调用函数并传递不同数量的位置参数
my_func(1, 2, 3)               # 输出：1 2 3
my_func('Hello', 'World')      # 输出：Hello World
my_func('a', 'b', 'c', 'd')    # 输出：a b c d
</code></pre>
<pre><code class="python">def my_func(**kwargs):
    """
    接收任意数量的关键字参数，并打印出来。
    
    Args:
        **kwargs: 任意数量的关键字参数。
    """
    for key, value in kwargs.items():
        print(f"{key}: {value}")

# 调用函数并传递不同的关键字参数
my_func(name='Alice', age=25)          # 输出：name: Alice, age: 25
my_func(city='New York', country='USA')# 输出：city: New York, country: USA
</code></pre>
</li>
<li><p>匿名函数</p>
<pre><code class="python">square = lambda x: x**2

print(square(4))  # 输出：16
print(square(7))  # 输出：49
</code></pre>
</li>
<li><p>回调函数</p>
<p>回调函数（Callback Function）是一种将函数作为参数传递给另一个函数，并在特定事件发生时被调用的函数。在 Python 中，可以使用回调函数来实现异步操作、事件处理、回调机制等。</p>
<pre><code class="python">def process_data(data, callback):
    # 在处理数据之后，调用回调函数
    result = data * 2
    callback(result)

def handle_result(result):
    # 处理回调函数的结果
    print("处理结果:", result)

data = 5
process_data(data, handle_result)
</code></pre>
</li>
<li><p>闭包函数</p>
<p>闭包函数（Closure Function）是指在一个函数内部定义并使用了另一个函数，并且这个内部函数可以访问外部函数中的变量。换句话说，闭包函数可以捕获并存储其所在作用域的状态。</p>
<p>Python 中的闭包函数是一种非常有用的功能，它可以帮助我们实现某些高级的编程技巧和模式，例如装饰器、工厂函数等。闭包函数的特点是：</p>
<ol>
<li>内部函数可以访问外部函数定义的变量：闭包函数中的内部函数可以引用并访问外部函数中的变量，即使外部函数已经执行完毕，内部函数仍然可以访问到那些变量。</li>
<li>外部函数可以返回内部函数作为结果：外部函数可以返回其内部函数作为结果，使得内部函数在外部函数执行完毕后仍然可以被调用。</li>
</ol>
<pre><code class="python">def outer_function(x):
    def inner_function(y):
        return x + y
    return inner_function

closure = outer_function(5)  # 感觉这里返回的是这个函数的内函数
result = closure(3)
print(result)  # 输出 8
</code></pre>
</li>
</ul>
<h2 id="10-3-使用全局变量"><a href="#10-3-使用全局变量" class="headerlink" title="10.3 使用全局变量"></a>10.3 使用全局变量</h2><ul>
<li><p>直接使用即可，但是局部变量不会改变全局变量的值</p>
</li>
<li><p><strong>global</strong></p>
</li>
</ul>
<pre><code>x = 10  # 全局变量

def func():
    global x  # 声明 x 是全局变量
    x = 20   # 修改全局变量 x 的值

print("Before calling func:", x)  # 输出：Before calling func: 10
func()
print("After calling func:", x)   # 输出：After calling func: 20
</code></pre>
<h2 id="10-4-filter筛选函数"><a href="#10-4-filter筛选函数" class="headerlink" title="10.4 filter筛选函数"></a>10.4 filter筛选函数</h2><p><code>filter(function, iterable)</code></p>
<p>其中，<code>function</code> 是一个判断函数，用于指定筛选的条件；<code>iterable</code> 是一个可迭代对象，包含需要筛选的元素。</p>
<p><code>filter()</code> 函数将会返回一个 <code>filter</code> 对象，它是一个迭代器，可以通过遍历或转换为其他序列（如列表）来获取结果。在筛选过程中，只有满足 <code>function</code> 函数返回值为 <code>True</code> 的元素会被保留。</p>
<pre><code class="python">numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

def is_even(x):
    return x % 2 == 0

result = filter(is_even, numbers)

print(list(result))  # 输出：[2, 4, 6, 8, 10]
</code></pre>
<h2 id="10-5-map-函数"><a href="#10-5-map-函数" class="headerlink" title="10.5 map()函数"></a>10.5 map()函数</h2><p><code>map(function, iterable)</code></p>
<p>其中，<code>function</code> 是一个函数，用于对每个元素进行处理；<code>iterable</code> 是一个可迭代对象，包含需要处理的元素。</p>
<p><code>map()</code> 函数将会返回一个 <code>map</code> 对象，它是一个迭代器，可以通过遍历或转换为其他序列（如列表）来获取结果。在处理过程中，会将 <code>iterable</code> 中的每个元素依次传递给 <code>function</code> 函数进行处理，并将处理后的结果保存在 <code>map</code> 对象中。</p>
<pre><code class="python">numbers = [1, 2, 3, 4, 5]

result = map(lambda x: x ** 2, numbers)

print(list(result))  # 输出：[1, 4, 9, 16, 25]
</code></pre>
<h2 id="10-6-装饰器函数"><a href="#10-6-装饰器函数" class="headerlink" title="10.6 装饰器函数"></a>10.6 装饰器函数</h2><p>装饰器函数通常采用一个函数作为输入参数，并返回一个新的函数作为输出结果。这样，我们可以使用装饰器函数来包装（decorate）其他函数，以添加一些额外的功能、修改其行为或执行其他操作。（相当于优雅地修改其他函数）</p>
<pre><code class="python">def decorator_function(original_function):
    def wrapper_function():
        # 在调用原始函数之前执行一些操作
        print("执行装饰器添加的功能")
        
        # 调用原始函数
        original_function()
        
        # 在调用原始函数之后执行一些操作
        print("装饰器功能执行完毕")
    
    # 返回包装后的函数对象
    return wrapper_function

def greet():
    print("Hello, world!")

# 使用装饰器函数来装饰 greet() 函数
greet = decorator_function(greet)

# 执行装饰后的函数
greet()
</code></pre>
<pre><code class="python">def decorator_function(original_function):
    def wrapper_function():
        print("执行装饰器添加的功能")
        original_function()
        print("装饰器功能执行完毕")
    return wrapper_function

@decorator_function
def greet():
    print("Hello, world!")

greet()
</code></pre>
<h1 id="11-模块"><a href="#11-模块" class="headerlink" title="11 模块"></a>11 模块</h1><h2 id="11-1-模块基本操作"><a href="#11-1-模块基本操作" class="headerlink" title="11.1 模块基本操作"></a>11.1 模块基本操作</h2><pre><code class="python"># 导入整个模块
import math

# 使用模块中的函数
print(math.sqrt(16))  # 输出：4.0

# 导入模块并指定别名
import datetime as dt

# 使用别名调用模块中的类
today = dt.date.today()
print(today)  # 输出当前日期

# 导入模块中的特定成员（函数、类、变量等）
from random import randint

# 直接使用成员，无需再加模块前缀
print(randint(1, 10))  # 输出一个随机整数

# 导入模块中的所有成员（函数、类、变量等）
from statistics import *

# 直接使用所有成员，无需再加模块前缀
data = [1, 2, 3, 4, 5]
print(mean(data))  # 输出平均值
</code></pre>
<h2 id="11-2-os模块"><a href="#11-2-os模块" class="headerlink" title="11. 2 os模块"></a>11. 2 os模块</h2><ol>
<li>文件和目录操作：<ul>
<li>创建目录：<code>os.mkdir(path)</code></li>
<li>删除目录：<code>os.rmdir(path)</code></li>
<li>列出目录下的文件和子目录：<code>os.listdir(path)</code></li>
<li>获取当前工作目录：<code>os.getcwd()</code></li>
<li>改变当前工作目录：<code>os.chdir(path)</code></li>
</ul>
</li>
</ol>
<ul>
<li><p>重命名文件或目录：<code>os.rename(src, dst)</code></p>
</li>
<li><p>删除文件：<code>os.remove(path)</code></p>
</li>
<li><p>检查文件是否存在：<code>os.path.exists(path)</code></p>
</li>
<li><p>检查是否为目录：<code>os.path.isdir(path)</code></p>
</li>
<li><p>检查是否为文件：<code>os.path.isfile(path)</code></p>
</li>
<li><p>获取文件大小：<code>os.path.getsize(path)</code></p>
</li>
<li><p>复制文件：可以使用<code>shutil</code>模块中的<code>shutil.copy(src, dst)</code>进行文件复制操作。</p>
</li>
<li><p>使用<code>os.system(command)</code>执行系统命令。例如：<code>os.system("ls")</code>会在终端运行<code>ls</code>命令。</p>
</li>
</ul>
<h2 id="11-3-random模块"><a href="#11-3-random模块" class="headerlink" title="11.3 random模块"></a>11.3 random模块</h2><p><code>random.random()</code>： 返回一个0到1之间（包括0但不包括1）的随机浮点数。</p>
<pre><code class="python">import random

num = random.random()
print(num)
# 输出：0.123456789 （随机的0到1之间的浮点数）
</code></pre>
<p><code>random.randint(a, b)</code>： 返回一个指定范围内的随机整数，包括边界值<code>a</code>和<code>b</code>。 </p>
<pre><code class="python">import random

num = random.randint(1, 10)
print(num)
# 输出：4 （随机的1到10之间的整数）
</code></pre>
<p><code>random.choice(seq)</code>： 从一个非空序列中随机选择一个元素，并返回。</p>
<pre><code class="python">import random

fruits = ['apple', 'banana', 'orange']
choice = random.choice(fruits)
print(choice)
# 输出：'banana' （随机选择一个水果）
</code></pre>
<p><code>random.shuffle(seq)</code>： 将一个序列中的元素随机打乱顺序，改变原序列，没有返回值。</p>
<pre><code class="python">import random

numbers = [1, 2, 3, 4, 5]
random.shuffle(numbers)
print(numbers)
# 输出类似于：[4, 2, 5, 1, 3] （随机打乱元素顺序）
</code></pre>
<p><code>random.sample(population, k)</code>： 从给定的序列中随机选择<code>k</code>个元素并返回，不改变原序列。</p>
<pre><code class="python">import random

numbers = [1, 2, 3, 4, 5]
sample = random.sample(numbers, 3)
print(sample)
# 输出类似于：[4, 2, 5] （随机选择3个元素）
</code></pre>
<h2 id="11-4-datetime模块"><a href="#11-4-datetime模块" class="headerlink" title="11. 4 datetime模块"></a>11. 4 datetime模块</h2><p><code>datetime.datetime.now()</code>： 返回当前的日期和时间。</p>
<pre><code class="python">import datetime

now = datetime.datetime.now()
print(now)
# 输出类似于：2023-07-13 11:46:28.123456 （当前的日期和时间）
</code></pre>
<p><code>datetime.datetime(year, month, day[, hour[, minute[, second[, microsecond[, tzinfo]]]]])</code>： 创建一个表示指定日期和时间的<code>datetime</code>对象。</p>
<pre><code class="python">import datetime

dt = datetime.datetime(2023, 7, 13, 12, 30)
print(dt)
# 输出：2023-07-13 12:30:00 （表示指定日期和时间的datetime对象）
</code></pre>
<p><code>datetime.timedelta(days[, seconds[, microseconds[, milliseconds[, minutes[, hours[, weeks]]]]]])</code>： 表示时间间隔的类，可以用于进行日期和时间的计算。</p>
<pre><code class="python">import datetime

delta = datetime.timedelta(days=7)
one_week_later = datetime.datetime.now() + delta
print(one_week_later)
# 输出：2023-07-20 11:46:28.123456 （当前时间的一周后）
</code></pre>
<p><code>datetime.strftime(format)</code>与<code>datetime.strptime(date_string, format)</code>： <code>strftime</code>方法将<code>datetime</code>对象格式化为字符串，而<code>strptime</code>方法将字符串解析为<code>datetime</code>对象。</p>
<pre><code class="python">import datetime

dt = datetime.datetime.now()
dt_str = dt.strftime('%Y-%m-%d %H:%M:%S')
print(dt_str)
# 输出类似于：2023-07-13 11:46:28 （将datetime对象格式化为字符串）

dt_parsed = datetime.datetime.strptime('2023-07-13 12:30:00', '%Y-%m-%d %H:%M:%S')
print(dt_parsed)
# 输出：2023-07-13 12:30:00 （将字符串解析为datetime对象）
</code></pre>
<h2 id="11-5-time模块"><a href="#11-5-time模块" class="headerlink" title="11. 5 time模块"></a>11. 5 time模块</h2><p><code>time.time()</code>： 返回当前时间的时间戳（自新纪元以来的秒数）。</p>
<pre><code class="python">import time

timestamp = time.time()
print(timestamp)
# 输出类似于：1626162382.123456 （当前时间的时间戳）
</code></pre>
<p><code>time.sleep(secs)</code>： 让程序暂停执行指定的秒数。</p>
<pre><code class="python">import time

print('开始')
time.sleep(3)
print('结束')
# 输出：
# 开始
# （3秒后）
# 结束
</code></pre>
<p><code>time.strftime(format[, t])</code>与<code>time.strptime(string[, format])</code>： <code>strftime</code>方法将时间元组或struct_time对象格式化为字符串，<code>strptime</code>方法将字符串解析为时间元组对象。</p>
<pre><code class="python">import time

timestamp = time.time()
time_str = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(timestamp))
print(time_str)
# 输出类似于：2023-07-13 11:46:28 （将时间戳格式化为字符串）

time_parsed = time.strptime('2023-07-13 12:30:00', '%Y-%m-%d %H:%M:%S')
print(time_parsed)
# 输出类似于：time.struct_time(tm_year=2023, tm_mon=7, tm_mday=13, tm_hour=12, tm_min=30, tm_sec=0, tm_wday=3, tm_yday=194, tm_isdst=-1) （将字符串解析为时间元组对象）
</code></pre>
<h1 id="12-类"><a href="#12-类" class="headerlink" title="12 类"></a>12 类</h1><h2 id="12-1-初始化类"><a href="#12-1-初始化类" class="headerlink" title="12.1 初始化类"></a>12.1 初始化类</h2><p>定义类（Class）：类是面向对象编程的基础，通过定义类来创建新的对象。类定义了对象的属性和方法。可以使用 <code>class</code> 关键字来定义一个类。</p>
<p>构造函数 <code>__init__()</code> 在创建对象时被调用，用于初始化对象的属性。它是一个特殊的方法，以双下划线开头和结尾。可以在构造函数中定义对象的初始状态。</p>
<p>析构函数 <code>__del__()</code> 在对象被销毁时自动调用。它也是一个特殊的方法，以双下划线开头和结尾。析构函数可以用于释放资源或执行清理操作。</p>
<p><code>Person</code> 类的析构函数 <code>__del__()</code> 会在对象被销毁时自动调用。使用 <code>del</code> 关键字可以手动销毁对象。</p>
<pre><code class="python">class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age
        print("Person object created.")

    def __del__(self):
        print("Person object destroyed.")

person = Person("Alice", 25)

del person
</code></pre>
<h2 id="12-2-类属性和对象属性"><a href="#12-2-类属性和对象属性" class="headerlink" title="12.2 类属性和对象属性"></a>12.2 类属性和对象属性</h2><p>类属性是定义在类中的变量，被所有该类的实例共享。它们属于类本身，而不属于类的任何特定实例。可以通过类名或实例访问类属性。</p>
<p>对象属性是定义在类实例中的变量，每个实例都拥有自己的一组对象属性。它们可以在类的构造函数中初始化，并使用 <code>self</code> 关键字绑定到对象。</p>
<p>需要注意的是，对象属性和类属性可以具有相同的名称，但它们是不同的。<strong>当通过实例访问属性时，如果实例没有该属性，则会查找类属性。</strong></p>
<pre><code class="python">class Person:
    species = "Human"

    def __init__(self, name):
        self.name = name

# 创建实例并访问属性
person = Person("Alice")
print(person.species)  # 输出: Human
print(person.name)  # 输出: Alice

# 修改类属性不影响已创建的实例
Person.species = "Homo sapiens"
print(person.species)  # 输出: Homo sapiens
</code></pre>
<h2 id="12-3-继承"><a href="#12-3-继承" class="headerlink" title="12.3 继承"></a>12.3 继承</h2><p>要创建一个继承关系，需要在定义子类时将父类作为参数传递给子类。子类会继承父类的所有属性和方法，并且可以添加自己特有的属性和方法。</p>
<pre><code class="python">class ParentClass:
    def __init__(self, x):
        self.x = x

    def parent_method(self):
        print("This is a parent method.")

class ChildClass(ParentClass):
    def __init__(self, x, y):
        super().__init__(x)  # 调用父类的构造方法
        self.y = y

    def child_method(self):
        print("This is a child method.")

# 创建子类实例
child = ChildClass(1, 2)

# 调用继承的父类方法
child.parent_method()  # 输出: This is a parent method.

# 调用子类自己的方法
child.child_method()  # 输出: This is a child method.

# 访问继承的父类属性和子类自己的属性
print(child.x)  # 输出: 1
print(child.y)  # 输出: 2
</code></pre>
<h2 id="12-4-类方法和静态方法"><a href="#12-4-类方法和静态方法" class="headerlink" title="12.4 类方法和静态方法"></a>12.4 类方法和静态方法</h2><ol>
<li><p>类方法（class method）：</p>
<ul>
<li>类方法使用 <code>@classmethod</code> 装饰器进行标记，通常以 <code>cls</code> 作为第一个参数，表示类本身。</li>
<li>可以通过类名或实例来调用类方法。</li>
<li>类方法可以访问和修改类属性，并且可以在没有实例的情况下被调用。</li>
<li>类方法常用于创建替代构造函数、操作共享数据等场景。</li>
</ul>
</li>
<li><p>静态方法（static method）：</p>
<ul>
<li>静态方法使用 <code>@staticmethod</code> 装饰器进行标记，不需要额外的参数来表示类或实例。</li>
<li>可以通过类名或实例来调用静态方法。</li>
<li>静态方法与类和实例无关，不能访问类属性或实例属性。</li>
<li>静态方法通常用于封装逻辑上与类相关，但在执行过程中不需要类或实例的功能。</li>
</ul>
</li>
</ol>
<pre><code class="python">class Car:
    total_cars = 0

    def __init__(self, brand, model):
        self.brand = brand
        self.model = model
        Car.total_cars += 1

    @classmethod
    def from_string(cls, car_string):
        brand, model = car_string.split(',')
        return cls(brand, model)

    @staticmethod
    def is_brand_supported(brand):
        supported_brands = ['Toyota', 'Honda', 'Ford']
        return brand in supported_brands


# 使用类方法创建 Car 实例
car1 = Car.from_string('Toyota, Camry')  # 通过字符串创建实例
print(car1.brand)  # 输出：Toyota
print(car1.model)  # 输出：Camry
print(Car.total_cars)  # 输出：1

# 使用静态方法检查品牌是否受支持
print(Car.is_brand_supported('Toyota'))  # 输出：True
print(Car.is_brand_supported('BMW'))  # 输出：False
</code></pre>
<h2 id="12-5-私有属性私有方法"><a href="#12-5-私有属性私有方法" class="headerlink" title="12.5 私有属性私有方法"></a>12.5 私有属性私有方法</h2><ol>
<li>私有属性：</li>
</ol>
<ul>
<li><p>使用两个下划线 <code>_</code> 开头的属性名来表示私有属性。</p>
</li>
<li><p>私有属性只能在类的内部和类的方法中访问，无法在类的外部直接访问。</p>
</li>
<li><p>可以通过公有方法来间接访问私有属性。</p>
</li>
</ul>
<pre><code class="python">class MyClass:
    def __init__(self):
        self._private_attr = 0  # 私有属性

    def public_method(self):
        self._private_attr += 1

# 在类的外部无法直接访问私有属性
obj = MyClass()
# print(obj._private_attr)  # 报错：AttributeError

# 通过公有方法间接访问私有属性
obj.public_method()
</code></pre>
<p>2.私有方法：</p>
<ul>
<li>使用两个下划线 <code>_</code> 开头的方法名来表示私有方法。</li>
<li>私有方法只能在类的内部调用，无法在类的外部直接调用。</li>
<li>公有方法可以内部调用私有方法。</li>
</ul>
<pre><code class="python">class MyClass:
    def __private_method(self):
        print("This is a private method.")

    def public_method(self):
        # 在公有方法内部调用私有方法
        self.__private_method()

# 在类的外部无法直接调用私有方法
obj = MyClass()
# obj.__private_method()  # 报错：AttributeError

# 通过公有方法调用私有方法
obj.public_method()  # 输出："This is a private method."
</code></pre>
<h2 id="12-6-多态"><a href="#12-6-多态" class="headerlink" title="12.6 多态"></a>12.6 多态</h2><p>方法重写（Override）：</p>
<ul>
<li>当子类继承父类时，可以重写父类的方法，以便在子类中提供对该方法的自定义实现。</li>
<li>在运行时，当调用该方法时，会根据对象的实际类型来确定使用哪个版本的方法。</li>
<li>子类可以完全覆盖父类的方法或在父类的基础上进行扩展。</li>
</ul>
<pre><code class="python">class Animal:
    def __init__(self, name):
        self.name = name

    def make_sound(self):
        print("The animal makes a sound.")


class Dog(Animal):
    def __init(self,name):
        Animal.__init__(self, name)
        
    def make_sound(self):
        print("The dog barks.")


class Cat(Animal):
    def __init(self,name):
        Animal.__init__(self, name)
        
    def make_sound(self):
        print("The cat meows.")


# 多态使用
animals = [Dog("Buddy"), Cat("Whiskers")]
for animal in animals:
    animal.make_sound()
</code></pre>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><em></em><a class="button is-default" href="/2024/01/25/pr%E6%89%AD%E6%9B%B2%E8%BD%AC%E5%9C%BA/" title="pr扭曲转场"><span class="has-text-weight-semibold">下一页: pr扭曲转场</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><a title="twitter" target="_blank" rel="noopener nofollow" href="//twitter.com//"><i class="iconfont icon-twitter"></i></a><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/https://github.com/1PHAN-7878"><i class="iconfont icon-github"></i></a><!-- Ins--><a title="instagram" target="_blank" rel="noopener nofollow" href="//www.instagram.com//"><i class="iconfont icon-ins"></i></a><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--><a title="facebook" target="_blank" rel="noopener nofollow" href="//www.facebook.com//"><i class="iconfont icon-tian7_facebook"></i></a></section><p><span>Copyright ©</span><span> 1PHAN 2024</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/jquery-3.6.1.min.js"></script><script src="/js/jquery-fancybox.min.js"></script><script src="/js/img_zoom.js"></script><script src="/js/post.js"></script></body></html>