<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>P1004 [NOIP2000 提高组] 方格取数解析</title>
      <link href="/2023/11/06/P1004-NOIP2000-%E6%8F%90%E9%AB%98%E7%BB%84-%E6%96%B9%E6%A0%BC%E5%8F%96%E6%95%B0%E8%A7%A3%E6%9E%90/"/>
      <url>/2023/11/06/P1004-NOIP2000-%E6%8F%90%E9%AB%98%E7%BB%84-%E6%96%B9%E6%A0%BC%E5%8F%96%E6%95%B0%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="NOIP2000-提高组-方格取数"><a href="#NOIP2000-提高组-方格取数" class="headerlink" title="[NOIP2000 提高组] 方格取数"></a>[NOIP2000 提高组] 方格取数</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>设有 $N \times N$ 的方格图 $(N \le 9)$，我们将其中的某些方格中填入正整数，而其他的方格中则放入数字 $0$。如下图所示（见样例）:</p><p><img src="/../images/zj4bo91w.png"></p><p>某人从图的左上角的 $A$ 点出发，可以向下行走，也可以向右走，直到到达右下角的 $B$ 点。在走过的路上，他可以取走方格中的数（取走后的方格中将变为数字 $0$）。<br>此人从 $A$ 点到 $B$ 点共走两次，试找出 $2$ 条这样的路径，使得取得的数之和为最大。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入的第一行为一个整数 $N$（表示 $N \times N$ 的方格图），接下来的每行有三个整数，前两个表示位置，第三个数为该位置上所放的数。一行单独的 $0$ 表示输入结束。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>只需输出一个整数，表示 $2$ 条路径上取得的最大的和。</p><h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><pre><code>82 3 132 6  63 5  74 4 145 2 215 6  46 3 157 2 140 0  0</code></pre><h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><pre><code>67</code></pre><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>NOIP 2000 提高组第四题</p><p>使用四维的dp，因为这里来说，可以ij当做第一次走过到了的点，kl当做第二次走过到了的点，所以就是</p><pre><code class="c++">dp[i][j][k][l] = //最大值dp[i-1][j][k-1][l]dp[i][j-1][k-1][l]dp[i-1][j][k][l-1]dp[i][j-1][k][l-1]加上本身所到了的a[i][j],a[k][l]如果两个是一样的位置，那么只要加一次</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P1002 [NOIP2002 普及组] 过河卒解析</title>
      <link href="/2023/11/06/P1002-NOIP2002-%E6%99%AE%E5%8F%8A%E7%BB%84-%E8%BF%87%E6%B2%B3%E5%8D%92%E8%A7%A3%E6%9E%90/"/>
      <url>/2023/11/06/P1002-NOIP2002-%E6%99%AE%E5%8F%8A%E7%BB%84-%E8%BF%87%E6%B2%B3%E5%8D%92%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="NOIP2002-普及组-过河卒"><a href="#NOIP2002-普及组-过河卒" class="headerlink" title="[NOIP2002 普及组] 过河卒"></a>[NOIP2002 普及组] 过河卒</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>棋盘上 $A$ 点有一个过河卒，需要走到目标 $B$ 点。卒行走的规则：可以向下、或者向右。同时在棋盘上 $C$ 点有一个对方的马，该马所在的点和所有跳跃一步可达的点称为对方马的控制点。因此称之为“马拦过河卒”。</p><p>棋盘用坐标表示，$A$ 点 $(0, 0)$、$B$ 点 $(n, m)$，同样马的位置坐标是需要给出的。</p><p><img src="/../images/f3wwgqj6.png"></p><p>现在要求你计算出卒从 $A$ 点能够到达 $B$ 点的路径的条数，假设马的位置是固定不动的，并不是卒走一步马走一步。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>一行四个正整数，分别表示 $B$ 点坐标和马的坐标。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个整数，表示所有的路径条数。</p><h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><pre><code>6 6 3 3</code></pre><h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><pre><code>6</code></pre><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>对于 $100 %$ 的数据，$1 \le n, m \le 20$，$0 \le$ 马的坐标 $\le 20$。</p><p><strong>【题目来源】</strong></p><p>NOIP 2002 普及组第四题</p><p>分析得知可以按照递推的方式向后做，因为没有向前的可以影响的。</p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include &lt;queue&gt;#define LL long long#define endl "\n"#define int long long#define rg register#define pli pair&lt;LL,int&gt;#define pil pair&lt;int,LL&gt;#define debug(x) std:: cout &lt;&lt; "---DEBUG--- " &lt;&lt; x &lt;&lt; " -----DEBUG----\n"#define rep(a,b,c) for(int i = a; i &lt; b; i += c)#define repr(a,b,c) for(int i = a; i &gt; b; i -= c)using namespace std;int dp[50][59];signed main() {    int n, m;    int a, b;    cin &gt;&gt; n &gt;&gt; m;    cin &gt;&gt; a &gt;&gt; b;    n++,m++,a++,b++;    int x[10], y[10];    x[1]=a-1;    y[1]=b-2;    x[2]=a-2;    y[2]=b-1;    x[3]=a+1;    y[3]=b-2;    x[4]=a+2;    y[4]=b-1;    x[5]=a-1;    y[5]=b+2;    x[6]=a-2;    y[6]=b+1;    x[7]=a+1;    y[7]=b+2;    x[8]=a+2;    y[8]=b+1;    x[9]=a;    y[9]=b;    dp[1][1]=1;    for(int i = 1; i &lt;= n; i++){        for(int j = 1; j &lt;= m; j++){            int flag = 1;            for(int k = 1; k &lt;= 9; k++){                if(x[k] == i &amp;&amp; y[k] == j) flag = 0;            }            if(flag == 0) continue;            dp[i][j] += dp[i][j-1] + dp[i-1][j];        }    }    cout &lt;&lt; dp[n][m];    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis使用</title>
      <link href="/2023/11/04/MyBatis%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/11/04/MyBatis%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="官方网站"><a href="#官方网站" class="headerlink" title="官方网站"></a>官方网站</h1><p><a href="https://mybatis.org/mybatis-3/zh/index.html">https://mybatis.org/mybatis-3/zh/index.html</a></p><h1 id="什么是Mybatis"><a href="#什么是Mybatis" class="headerlink" title="什么是Mybatis"></a>什么是Mybatis</h1><p>一种用于 Java 编程语言的开源持久性框架。它提供了一种将对象与数据库表进行映射的方法，允许开发人员使用面向对象的编程方式来访问和操作数据库。</p><p>MyBatis 的主要功能和特点包括：</p><ol><li><strong>对象-关系映射（ORM）</strong>：MyBatis 允许开发人员将 Java 对象和数据库表进行映射，从而避免了手动编写大量的 SQL 查询语句。这使得开发人员可以更专注于业务逻辑，而不是 SQL 语句的编写。</li><li><strong>XML 或注解配置</strong>：MyBatis 支持通过 XML 文件或注解来配置数据映射和 SQL 查询。这种配置的方式使得开发人员可以更容易地维护和修改 SQL 查询。</li><li><strong>动态 SQL</strong>：MyBatis 支持动态 SQL 查询，这意味着你可以根据不同的条件生成不同的 SQL 查询语句，而不必编写大量重复的 SQL 语句。</li><li><strong>缓存支持</strong>：MyBatis 具有内置的缓存支持，可以提高应用程序的性能，减少数据库查询的次数。</li><li><strong>自动映射</strong>：MyBatis 可以自动将查询结果映射到 Java 对象，无需手动编写映射代码。</li><li><strong>批处理</strong>：MyBatis 支持批处理操作，可以有效地处理多个数据库操作。</li><li><strong>插件支持</strong>：MyBatis 允许开发人员编写自定义插件来扩展框架的功能。</li></ol><p>MyBatis 在 Java 开发中广泛使用，特别是在与关系型数据库的交互方面。它为开发人员提供了一种直观且灵活的方法，以简化数据库访问和操作。</p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>在maven中配置,修改版本号</p><pre><code class="xml">&lt;dependency&gt;  &lt;groupId&gt;org.mybatis&lt;/groupId&gt;  &lt;artifactId&gt;mybatis&lt;/artifactId&gt;  &lt;version&gt;x.x.x&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>sources中的配置，修改驱动等信息，同时修改所使用的mapper对象</p><pre><code class="xml">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration  PUBLIC "-//mybatis.org//DTD Config 3.0//EN"  "https://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt;  &lt;environments default="development"&gt;    &lt;environment id="development"&gt;      &lt;transactionManager type="JDBC"/&gt;      &lt;dataSource type="POOLED"&gt;        &lt;property name="driver" value="${driver}"/&gt;        &lt;property name="url" value="${url}"/&gt;        &lt;property name="username" value="${username}"/&gt;        &lt;property name="password" value="${password}"/&gt;      &lt;/dataSource&gt;    &lt;/environment&gt;  &lt;/environments&gt;  &lt;mappers&gt;    &lt;mapper resource="org/mybatis/example/BlogMapper.xml"/&gt;  &lt;/mappers&gt;&lt;/configuration&gt;</code></pre><p>配置用户的mappers，包含sql语句等</p><pre><code class="xml">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"  "https://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="org.mybatis.example.BlogMapper"&gt;  &lt;select id="selectBlog" resultType="Blog"&gt;    select * from Blog where id = #{id}  &lt;/select&gt;&lt;/mapper&gt;</code></pre><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>MyBatis 包含一个名叫 Resources 的工具类，它包含一些实用方法，使得从类路径或其它位置加载资源文件更加容易。</p><pre><code class="java">String resource = "org/mybatis/example/mybatis-config.xml";InputStream inputStream = Resources.getResourceAsStream(resource);SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);</code></pre><p>既然有了 SqlSessionFactory，顾名思义，我们可以从中获得 SqlSession 的实例。SqlSession 提供了在数据库执行 SQL 命令所需的所有方法。你可以通过 SqlSession 实例来直接执行已映射的 SQL 语句。例如：</p><pre><code class="java">try (SqlSession session = sqlSessionFactory.openSession()) {  Blog blog = (Blog) session.selectOne("org.mybatis.example.BlogMapper.selectBlog", 101);}</code></pre><p>目录结构为resources和java同级，在main下一级</p><p><img src="/../images/image-20231104211112060.png" alt="image-20231104211112060"></p><p>使用修改后的代码如下</p><pre><code class="java">package com.example.batis;import java.io.IOException;import java.io.InputStream;import java.util.List;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;public class Test {         private int book_id;    private String book_name;    private String book_author;    private double book_price;    private int book_stock;    private String book_desc;            public Test(int book_id, String book_name, String book_author, double book_price, int book_stock,            String book_desc) {        super();        this.book_id = book_id;        this.book_name = book_name;        this.book_author = book_author;        this.book_price = book_price;        this.book_stock = book_stock;        this.book_desc = book_desc;    }        @Override    public String toString() {        return "Test [book_id=" + book_id + ", book_name=" + book_name + ", book_author=" + book_author                + ", book_price=" + book_price + ", book_stock=" + book_stock + ", book_desc=" + book_desc + "]";    }    public static void main(String[] args) throws IOException {        // TODO 自动生成的方法存根        String resource = "mybatis-config.xml";        InputStream inputStream = Resources.getResourceAsStream(resource);        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);        SqlSession sqlSession = sqlSessionFactory.openSession();        List&lt;Test&gt; list =  sqlSession.selectList("test.All");                System.out.println(list);    }}</code></pre><h1 id="配置mapper代理"><a href="#配置mapper代理" class="headerlink" title="配置mapper代理"></a>配置mapper代理</h1><p>在 MyBatis 中，你可以使用 Mapper 代理开发方式来访问数据库而不需要编写实现类，代理会根据你的映射文件执行相应的 SQL。以下是设置 Mapper 代理开发的步骤：</p><ol><li><p><strong>创建映射文件</strong>：首先，你需要创建一个 XML 映射文件，它描述了 SQL 查询、插入、更新或删除操作。这个映射文件通常包含在 MyBatis 配置文件中。</p><p>例如，这是一个简单的映射文件示例：==名称空间是包的名称中接口==</p><pre><code class="xml">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"  "https://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.example.mapper.MyMapper"&gt;  &lt;select id="selectUser" resultType="com.example.User"&gt;    SELECT * FROM users WHERE id = #{id}  &lt;/select&gt;&lt;/mapper&gt;</code></pre></li><li><p><strong>创建 Java 接口</strong>：接下来，你需要创建一个 Java 接口，该接口定义了与映射文件相对应的方法。这些方法的名称和参数应该与映射文件中的 SQL 查询操作相匹配。==方法对应的是xml中的id==</p><pre><code class="java">package com.example.mapper;import com.example.User;public interface MyMapper {    User selectUser(int id);}</code></pre></li><li><p><strong>配置 MyBatis</strong>：在 MyBatis 配置文件（通常是 <code>mybatis-config.xml</code>）中，确保已包含了映射文件的引用，如下所示：==通常使用包名==</p><pre><code class="xml">&lt;mappers&gt;  &lt;mapper resource="com/example/mapper/MyMapper.xml" /&gt;&lt;/mappers&gt;</code></pre></li><li><p><strong>使用 Mapper 代理</strong>：在你的应用程序中，你可以通过创建 <code>SqlSession</code> 并获取 Mapper 接口的代理对象来使用 Mapper 代理。然后，你可以使用该代理对象来执行映射文件中定义的方法。</p><pre><code class="java">SqlSession sqlSession = sessionFactory.openSession();MyMapper myMapper = sqlSession.getMapper(MyMapper.class);User user = myMapper.selectUser(123);</code></pre></li><li><p><strong>关闭 SqlSession</strong>：在完成操作后，不要忘记关闭 <code>SqlSession</code> 以释放资源。</p><pre><code class="java">sqlSession.close();</code></pre></li></ol><p>这样，你就可以使用 Mapper 代理开发方式与数据库交互，而无需显式实现每个 SQL 操作。Mapper 代理会根据你的接口定义和映射文件执行相应的 SQL 操作。</p><p>目录结构如下</p><p><img src="/../images/image-20231106093649924.png" alt="image-20231106093649924"></p><h1 id="结果映射"><a href="#结果映射" class="headerlink" title="结果映射"></a>结果映射</h1><p>在 XML 中使用 <code>&lt;resultMap&gt;</code> 元素是为了定制查询结果映射到对象的方式。 <code>&lt;resultMap&gt;</code> 元素通常用于 MyBatis（一个流行的 Java 持久层框架）的配置文件中，用于定义如何将查询结果映射到 Java 对象。以下是如何使用 <code>&lt;resultMap&gt;</code> 元素的示例：</p><pre><code class="xml">&lt;resultMap id="userResultMap" type="com.example.User"&gt;  &lt;!-- 指定结果集中的列到 Java 对象的属性的映射 --&gt;  &lt;result property="id" column="user_id"/&gt;  &lt;result property="username" column="username"/&gt;  &lt;result property="email" column="user_email"/&gt;&lt;/resultMap&gt;</code></pre><p>上面的示例中，<code>&lt;resultMap&gt;</code> 元素定义了一个名为 <code>userResultMap</code> 的映射，将查询结果映射到 <code>com.example.User</code> 类型的对象。它使用 <code>&lt;result&gt;</code> 元素指定了查询结果中的列与 Java 对象的属性之间的映射关系。</p><p>接下来，你可以在 SQL 查询语句中引用这个 <code>&lt;resultMap&gt;</code>，如下所示：</p><pre><code class="xml">&lt;select id="getUserById" resultMap="userResultMap"&gt;  SELECT user_id, username, user_email  FROM users  WHERE user_id = #{id}&lt;/select&gt;</code></pre><p>在上面的 <code>&lt;select&gt;</code> 元素中，通过 <code>resultMap</code> 属性指定了要使用的 <code>&lt;resultMap&gt;</code>，这将告诉 MyBatis 如何将查询结果映射到 <code>com.example.User</code> 对象。</p><p>使用 <code>&lt;resultMap&gt;</code> 元素的主要目的是为了灵活地映射查询结果，允许你将查询结果中的列映射到不同的 Java 对象属性，以及支持高级的映射配置，如复杂的嵌套对象映射等。这对于定制数据映射非常有用。</p><h1 id="引用参数"><a href="#引用参数" class="headerlink" title="引用参数"></a>引用参数</h1><p>在 MyBatis 的 XML 配置文件中，你可以定义带有参数的 SQL 语句，并在需要时引用这些参数。以下是一个示例，演示了如何在 MyBatis XML 中使用带有参数的 SQL 语句：</p><p>首先，在 MyBatis XML 配置文件中定义带有参数的 SQL 语句，你可以使用 <code>${paramName}</code> 来引用参数：</p><pre><code class="xml">&lt;mapper namespace="com.example.MyMapper"&gt;  &lt;!-- 定义带有参数的 SQL 语句 --&gt;  &lt;select id="getUserById" resultType="com.example.User"&gt;    SELECT * FROM users WHERE id = ${id}  &lt;/select&gt;&lt;/mapper&gt;</code></pre><p>在上面的示例中，<code>getUserById</code> 查询使用 <code>${id}</code> 来引用一个参数，它会匹配方法参数的名称。</p><p>接下来，你可以在 Java 代码中调用这个 SQL 语句，将参数传递给它：</p><pre><code class="java">import com.example.User;import org.apache.ibatis.annotations.Param;public interface MyMapper {    User getUserById(@Param("id") int id);}</code></pre><p>在上面的 Java 代码中，<code>@Param("id")</code> 注解指定了参数的名称，这个名称应该与 SQL 语句中的 <code>${id}</code> 匹配。</p><p>然后，你可以在应用中调用这个方法，并传递参数：</p><pre><code class="java">public class MyApp {    public static void main(String[] args) {        SqlSessionFactory sqlSessionFactory = MyBatisUtil.getSqlSessionFactory();        SqlSession session = sqlSessionFactory.openSession();        MyMapper myMapper = session.getMapper(MyMapper.class);        User user = myMapper.getUserById(1);        System.out.println(user);                session.close();    }}</code></pre><p>在上面的示例中，<code>getUserById</code> 方法接收一个参数，该参数与 SQL 语句中的 <code>${id}</code> 匹配，MyBatis 将执行 SQL 查询并将结果映射到 <code>User</code> 对象中。</p><p>这是一个简单的示例，演示了如何在 MyBatis XML 配置文件中定义带有参数的 SQL 语句，并在 Java 代码中使用它。你可以根据你的需要定义更复杂的 SQL 语句，引用多个参数，并执行各种查询和操作。</p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>maven</title>
      <link href="/2023/11/04/maven/"/>
      <url>/2023/11/04/maven/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Apache Maven（通常简称为 Maven）是一个开源的项目管理和构建工具，用于构建、管理和部署Java应用程序。它提供了一种结构化的方式来管理项目的构建过程、依赖管理、文档生成和发布过程。Maven 的主要目标是提供一种一致的构建方法，减少开发人员的配置工作，以及提供自动化构建的能力。</p><p>Maven 提供了以下主要功能和特点：</p><ol><li><strong>项目结构和约定</strong>：Maven 鼓励开发者遵循一组约定，以简化项目的组织和结构。这些约定包括源代码目录、资源目录、测试目录等。</li><li><strong>依赖管理</strong>：Maven 支持管理项目的依赖关系。你可以定义项目依赖，Maven 会自动下载和管理这些依赖的库文件。这减轻了手动管理JAR文件的负担。</li><li><strong>生命周期和构建阶段</strong>：Maven 定义了一组生命周期和构建阶段，包括编译、测试、打包、部署等。开发者可以配置和执行这些构建阶段，以满足项目的需求。</li><li><strong>插件体系</strong>：Maven 使用插件来扩展其功能。它有丰富的插件生态系统，允许开发者使用现有的插件或编写自定义插件以满足特定需求。</li><li><strong>POM 文件</strong>：Maven 使用项目对象模型（Project Object Model，POM）文件来描述项目的配置信息、依赖关系和构建过程。POM 文件以 XML 格式编写。</li><li><strong>自动化构建</strong>：Maven 提供了一种自动化构建过程，可以生成项目的可执行文件、文档、测试报告等。</li><li><strong>集成测试和部署</strong>：Maven 支持集成测试和部署到不同环境的过程，有助于构建和交付可靠的应用程序。</li></ol><p>Maven 的强大功能和生态系统使其成为 Java 开发社区中最受欢迎的项目管理和构建工具之一。它有助于简化项目的构建和管理，并提高开发效率。</p><h1 id="eclipse中使用maven"><a href="#eclipse中使用maven" class="headerlink" title="eclipse中使用maven"></a>eclipse中使用maven</h1><p>新建maven项目</p><p><img src="/../images/image-20231104135249214.png" alt="image-20231104135249214"></p><ol><li><strong>maven-archetype-quickstart</strong>：<ul><li>这是一个基本的 Maven 项目模板，用于创建简单的 Java 项目。</li><li>包括了一个示例的 Java 类和一个简单的 <code>pom.xml</code> 配置文件。</li><li>适用于快速创建基本的 Java 项目。</li></ul></li><li><strong>maven-archetype-webapp</strong>：<ul><li>用于创建基本的 Web 应用程序项目，包括了一个简单的 Java Servlet 和 Web 目录结构。</li><li>适用于开发简单的 Web 应用程序。</li></ul></li><li><strong>maven-archetype-j2ee-simple</strong>：<ul><li>创建了一个简单的 Java EE 项目，包括了一个 EJB 模块和一个 WAR 模块。</li><li>适用于创建较复杂的 Java EE 项目。</li></ul></li><li><strong>maven-archetype-quickstart-jdk8</strong>：<ul><li>类似于 “maven-archetype-quickstart”，但是使用 Java 8 作为目标 JDK 版本。</li><li>适用于在 Java 8 环境下开发的项目。</li></ul></li><li><strong>maven-archetype-archetype</strong>：<ul><li>用于创建自定义 Maven “archetype” 的模板。</li><li>适用于开发自定义项目模板的高级用户。</li></ul></li></ol><p><img src="/../images/image-20231104135514615.png" alt="image-20231104135514615"></p><ol><li>**Group ID (groupId)**：Group ID 是你的项目的组织或包的唯一标识符。通常，它使用逆域名（reverse domain name）的方式来定义，例如 <code>com.example</code>。这个标识符用于区分不同的项目和组织。你可以根据你的组织或项目的实际情况来定义 Group ID。</li><li>**Artifact ID (artifactId)**：Artifact ID 是你的项目的名称标识符。它代表项目本身的名称。例如，如果你的项目是一个名为 “myapp” 的应用程序，那么 Artifact ID 可以设置为 <code>myapp</code>。</li><li>**Package (package)**：Package 是你的 Java 类的默认包名。通常，它是根据 Group ID 和 Artifact ID 自动生成的，形式为 <code>groupId.artifactId</code>。例如，如果 Group ID 是 <code>com.example</code>，Artifact ID 是 <code>myapp</code>，那么默认的包名将是 <code>com.example.myapp</code>。</li></ol><p>下面是一个示例：</p><ul><li>Group ID: <code>com.example</code></li><li>Artifact ID: <code>myapp</code></li><li>Package: <code>com.example.myapp</code></li></ul><h1 id="添加后产生错误"><a href="#添加后产生错误" class="headerlink" title="添加后产生错误"></a>添加后产生错误</h1><p><img src="/../images/image-20231104140409713.png" alt="image-20231104140409713"></p><p>这个错误是由于 Maven 无法从默认的中央仓库（<a href="https://repo.maven.apache.org/maven2%EF%BC%89%E4%B8%8B%E8%BD%BD%E6%89%80%E9%9C%80%E7%9A%84%E4%BE%9D%E8%B5%96%E9%A1%B9%EF%BC%8C%E7%89%B9%E5%88%AB%E6%98%AF%E4%B8%8E">https://repo.maven.apache.org/maven2）下载所需的依赖项，特别是与</a> Maven 插件和工具有关的依赖项。通常，这种问题可能是网络连接问题或中央仓库服务器问题导致的。</p><p>解决方法：</p><ol><li><p>打开 Eclipse。</p></li><li><p>转到 “Window” 菜单，选择 “Preferences”。</p></li><li><p>在 Preferences 窗口中，展开 “Maven” 部分，然后选择 “User Settings”。</p></li><li><p>在 “User Settings” 下，你会看到 “User Settings” 文件的路径。通常情况下，这是 <code>$USER_HOME/.m2/settings.xml</code>，其中 <code>$USER_HOME</code> 表示你的用户主目录。</p></li><li><p>打开这个文件以编辑 Maven 的设置。</p></li><li><p>在 <code>settings.xml</code> 文件中，你可以添加镜像源配置，如以下示例所示：</p><pre><code class="xml">&lt;mirrors&gt;  &lt;mirror&gt;    &lt;id&gt;aliyun-maven&lt;/id&gt;    &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;    &lt;url&gt;https://maven.aliyun.com/repository/central&lt;/url&gt;  &lt;/mirror&gt;&lt;/mirrors&gt;</code></pre><p>你可以根据你的需求添加镜像源，确保镜像源的 URL 和 <code>&lt;mirrorOf&gt;</code> 标签中的值正确。</p></li><li><p>保存 <code>settings.xml</code> 文件。</p></li></ol><p>然后，尝试重新构建你的项目，Maven 应该会使用你配置的镜像源来下载依赖项。如果 <code>settings.xml</code> 文件不存在，你可以创建一个并添加所需的配置。确保 Eclipse 中的 Maven 插件能够正确找到这个文件。</p><pre><code class="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;metadata&gt;  &lt;groupId&gt;org.jetbrains.externalAnnotations.junit&lt;/groupId&gt;  &lt;artifactId&gt;junit&lt;/artifactId&gt;  &lt;versioning&gt;    &lt;latest&gt;4.12-an1&lt;/latest&gt;    &lt;release&gt;4.12-an1&lt;/release&gt;    &lt;versions&gt;      &lt;version&gt;4.12-an1&lt;/version&gt;    &lt;/versions&gt;    &lt;lastUpdated&gt;20210416102806&lt;/lastUpdated&gt;  &lt;/versioning&gt;    &lt;mirrors&gt;  &lt;mirror&gt;    &lt;id&gt;aliyun-maven&lt;/id&gt;    &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;    &lt;url&gt;https://maven.aliyun.com/repository/central&lt;/url&gt;  &lt;/mirror&gt;  &lt;/mirrors&gt;&lt;/metadata&gt;</code></pre><p><img src="/../images/image-20231104141116493.png" alt="image-20231104141116493"></p><p>最后update本地文件</p><p><img src="/../images/image-20231104141357297.png" alt="image-20231104141357297"></p><p>测试输出helloworld</p><p><img src="/../images/image-20231104141823736.png" alt="image-20231104141823736"></p><h1 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h1><pre><code class="xml">&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;  &lt;groupId&gt;com.example&lt;/groupId&gt;  &lt;artifactId&gt;myapp&lt;/artifactId&gt;  &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;  &lt;packaging&gt;jar&lt;/packaging&gt;      &lt;name&gt;myapp&lt;/name&gt;  &lt;url&gt;http://maven.apache.org&lt;/url&gt;  &lt;properties&gt;    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;  &lt;/properties&gt;  &lt;dependencies&gt;    &lt;dependency&gt;      &lt;groupId&gt;junit&lt;/groupId&gt;      &lt;artifactId&gt;junit&lt;/artifactId&gt;      &lt;version&gt;3.8.1&lt;/version&gt;      &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt;        &lt;!-- MySQL Connector/J 8.0.27 的依赖 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;version&gt;8.0.27&lt;/version&gt;        &lt;/dependency&gt;  &lt;/dependencies&gt;&lt;/project&gt;</code></pre><p><img src="/../images/image-20231104142540115.png" alt="image-20231104142540115"></p><p>update可以看到增加了jar包</p><p>进行测试成功</p><p><img src="/../images/image-20231104144200991.png" alt="image-20231104144200991"></p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo无法显示图片的问题解决</title>
      <link href="/2023/11/04/hexo%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87%E7%9A%84%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
      <url>/2023/11/04/hexo%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87%E7%9A%84%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<p>最近发现在上传一些包含图片的md文件时不能正常的显示，于是去寻找解决办法。</p><p>md文件中插入图片的语法为<code>![]()</code></p><p>总体来说就是路径不对，无法找到正确的路径，于是更改默认的路径例如</p><p><img src="/../images/image-20231104133817100.png" alt="image-20231104133817100"></p><p>我在source文件夹下建立了images的文件夹来存储图片，但是每次都要这样写一下路径不，不是嘞。</p><p>按照typora的偏好设置，可以让他为我们自己配置这样的路径。</p><p><img src="/../images/image-20231104133941585.png" alt="image-20231104133941585"></p><p>如此一来在执行</p><pre><code>hexo generatehexo deploy</code></pre><p>即可发现成功显示图片</p><p><img src="/../images/image-20231104134052640.png" alt="image-20231104134052640"></p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MATLABQ关于灰度直方图以及一些线性非线性变换？</title>
      <link href="/2023/11/01/MATLABQ%E5%85%B3%E4%BA%8E%E7%81%B0%E5%BA%A6%E7%9B%B4%E6%96%B9%E5%9B%BE%E4%BB%A5%E5%8F%8A%E4%B8%80%E4%BA%9B%E7%BA%BF%E6%80%A7%E9%9D%9E%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2%EF%BC%9F/"/>
      <url>/2023/11/01/MATLABQ%E5%85%B3%E4%BA%8E%E7%81%B0%E5%BA%A6%E7%9B%B4%E6%96%B9%E5%9B%BE%E4%BB%A5%E5%8F%8A%E4%B8%80%E4%BA%9B%E7%BA%BF%E6%80%A7%E9%9D%9E%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>风和日丽，Q艮又来点任务，这次是让看一看图片（灰度图）的直方分布，加上来然后让这个灰度图像进行一些变换，反正今天讲的叫什么前映射后映射变换是迷迷糊糊的。</p><p>这个是编写的康可：</p><pre><code class="matlab">img = imread('C:\Users\7878\Desktop\my_image.png');img1 = imresize(img, 0.3);img1 = rgb2gray(img1);subplot(2, 2, 1);imshow(img1);subplot(2, 2, 2);imhist(img1);img2 = imadjust(img1,[0.5, 0.6], [0, 1]);subplot(2, 2, 3);imshow(img2);subplot(2, 2, 4);imhist(img2);</code></pre><p>当使用 <code>imadjust</code> 函数时，你可以指定输入图像中要拉伸到特定亮度范围的百分比，并且你可以指定输出图像中的目标亮度范围。这允许你控制亮度值的映射方式，以改变图像的对比度和亮度。</p><p>具体来说，这些参数的含义如下：</p><ol><li><code>low_in</code>：这是输入图像中要拉伸到的亮度范围的下限。它表示输入图像中亮度较低的像素值的百分比。例如，如果 <code>low_in</code> 设置为 0.2，表示将输入图像中最暗的 20% 像素值拉伸到目标范围。</li><li><code>high_in</code>：这是输入图像中要拉伸到的亮度范围的上限。它表示输入图像中亮度较高的像素值的百分比。例如，如果 <code>high_in</code> 设置为 0.8，表示将输入图像中最亮的 80% 像素值拉伸到目标范围。</li><li><code>low_out</code>：这是输出图像中的目标亮度范围的下限。它表示输出图像中最暗的像素值应该对应的亮度值。通常，它是 0，表示黑色。</li><li><code>high_out</code>：这是输出图像中的目标亮度范围的上限。它表示输出图像中最亮的像素值应该对应的亮度值。通常，它是 1，表示白色。</li></ol><p>通过调整这些参数，你可以控制输入图像中不同亮度级别的像素如何映射到输出图像中的亮度范围，从而增强或调整图像的对比度和亮度。这些参数的选择取决于你希望达到的图像效果。</p><p><img src="/../images/qg-1699076069906-1.jpg"></p>]]></content>
      
      
      
        <tags>
            
            <tag> MATLAB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于git上传文件的.gitignore</title>
      <link href="/2023/10/27/%E5%85%B3%E4%BA%8Egit%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E7%9A%84-gitignore/"/>
      <url>/2023/10/27/%E5%85%B3%E4%BA%8Egit%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E7%9A%84-gitignore/</url>
      
        <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>产生问题：由于我想上传一个Unity的项目到github，但是里面包含有大于50MB的文件，github规定了上传的文件大小，因此是不可以传上去的。</p><h1 id="方案1"><a href="#方案1" class="headerlink" title="方案1"></a>方案1</h1><p>需要git-lfs工具支持</p><h1 id="方案2"><a href="#方案2" class="headerlink" title="方案2"></a>方案2</h1><p>将大文件加入.gitignore名单</p><p>由于我在操作时已经push出现了问题，所以需要先进行</p><pre><code class="shell">git reset</code></pre><p>我在创建了该文件之后，并没有删除之前的暂存区的内容，所以每一次commit和push都有之前的大文件，最终是折腾好。</p><p>==步骤如下==</p><p>创建 <code>.gitignore</code> 文件：在你的 Git 仓库根目录下，创建一个名为 <code>.gitignore</code> 的文件。可以使用文本编辑器来创建它。</p><p>编辑 <code>.gitignore</code> 文件：在 <code>.gitignore</code> 文件中，你可以列出你希望忽略的文件、目录或模式。每一行代表一个要忽略的项。可以使用通配符来匹配多个文件或目录，如 <code>*</code> 表示任意字符，<code>/</code> 表示目录分隔符，<code>#</code> 表示注释等。</p><p>   例如，以下是一个简单的 <code>.gitignore</code> 文件的示例：</p><pre><code>gitignoreCopy code# 忽略所有 .log 文件*.log# 忽略 temp 目录/temp/# 忽略 .DS_Store 文件（通常在 macOS 系统中生成）.DS_Store</code></pre><p>保存并提交 <code>.gitignore</code> 文件：保存 <code>.gitignore</code> 文件后，将其提交到 Git 仓库中。你可以使用以下命令：</p><pre><code class="shell">git add .gitignoregit commit -m "Add .gitignore file"</code></pre><p>一旦设置了 <code>.gitignore</code> 文件，Git 将会忽略在文件中列出的文件和目录，不会将它们包括在版本历史中。</p>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MATLABQ入门关于图像的平移旋转镜像与分析</title>
      <link href="/2023/10/25/MATLABQ%E5%85%A5%E9%97%A8%E5%85%B3%E4%BA%8E%E5%9B%BE%E5%83%8F%E7%9A%84%E5%B9%B3%E7%A7%BB%E6%97%8B%E8%BD%AC%E9%95%9C%E5%83%8F%E4%B8%8E%E5%88%86%E6%9E%90/"/>
      <url>/2023/10/25/MATLABQ%E5%85%A5%E9%97%A8%E5%85%B3%E4%BA%8E%E5%9B%BE%E5%83%8F%E7%9A%84%E5%B9%B3%E7%A7%BB%E6%97%8B%E8%BD%AC%E9%95%9C%E5%83%8F%E4%B8%8E%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="MATLAB-Q根作业"><a href="#MATLAB-Q根作业" class="headerlink" title="MATLAB Q根作业"></a>MATLAB Q根作业</h1><p>今天Q根说要我完成一些作业，他还会检查其中一部分。这让我感到非常紧张和着急，我开始焦虑地写作业。</p><p>在心慌意乱的状态下，我努力扩写了每个问题，并尽量给出详细的答案。我不断提醒自己要保持专注和冷静，尽力完成作业。</p><p>时间一分一秒地过去，我试图将注意力集中在任务上，忽略掉内心的不安和压力。我意识到，即使紧张也无法改变现实，唯一的解决办法就是面对并尽力去完成作业。</p><p>逐渐地，我发现自己进入了一种工作的节奏。通过不断努力，我开始逐渐克服恐惧和焦虑，专注于解决问题和完成任务。</p><p>最终，我完成了作业，并在一半检查时交给了Q根。我深呼吸一口气，希望我的努力能够得到认可。无论结果如何，我知道我已经尽力了，并从中学到了如何应对压力和困难。</p><p>这次经历让我明白，当面临紧张和压力时，保持冷静和专注非常重要。虽然一开始感到慌乱，但通过努力和积极思考，我能够克服困难，完成任务并成长。</p><h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><p>编程：图像的平移，水平，垂直，镜像（对比你自己的和自带的），验证：旋转（调用），imageresize实现图像缩放（很多算法不同），对比两幅图像是否相同的标准psnr</p><h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><pre><code class="matlab">img = imread('C:\Users\7878\Desktop\my_image.png');img1 = imresize(img, 0.2);% 旋转angle = 45;img_rotate = imrotate(img1, angle);subplot(2,3,1);imshow(img1);% title('before rotate');subplot(2,3,2);imshow(img_rotate);% title('旋转后');img_gray = rgb2gray(img1);subplot(2,3,3);imshow(img_gray);% title('灰色');[r,c] = size(img_gray);img_dst = zeros(r,c);dx = 50;dy = 50;tras=[1 0 dx;0 1 dy;0 0 1];for i=1:r    for j=1:c        %         temp = [i;j;1];        %         temp = tras*temp;        %         x=temp(1,1);        %         y=temp(2,1);        x = i + dx;        y = j + dy;        if(x&gt;=1 &amp;&amp; x&lt;=r) &amp;&amp; (y&gt;=1 &amp;&amp; y&lt;=c)            img_dst(x,y) = img_gray(i,j);        end    endendimg_mirror = zeros(r,c);for i=1:r    for j=1:c        x = abs(r - i);        y = j;        if(x&gt;=1 &amp;&amp; x&lt;=r) &amp;&amp; (y&gt;=1 &amp;&amp; y&lt;=c)            img_mirror(x,y) = img_gray(i,j);        end    endendsubplot(2,3,4);imshow(uint8(img_mirror));% title('镜像的');subplot(2,3,5);imshow(uint8(img_dst));% title('平移后');% 水平镜像horizontal_flip = flip(img_gray, 2);% 垂直镜像vertical_flip = flip(img_gray, 1);subplot(2,3,6);imshow(vertical_flip);% 峰值信噪比% mse = sum((double(img_mirror) - double(vertical_flip)).^2, [], 'all') / numel(img_mirror);% psnr = 10 * log10((255^2) / mse);% disp(psnr);% result = psnr(img_mirror, vertical_flip);[peaksnr, snr] = psnr(uint8(img_mirror), uint8(vertical_flip));  fprintf('\n The Peak-SNR value is %0.4f', peaksnr);</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> MATLAB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git学习下的一些基本操作</title>
      <link href="/2023/10/18/git/"/>
      <url>/2023/10/18/git/</url>
      
        <content type="html"><![CDATA[<h1 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h1><pre><code class="shell">git clone [ssh]</code></pre><blockquote><p><img src="C:\Users\7878\AppData\Roaming\Typora\typora-user-images\image-20231017162915772.png" alt="image-20231017162915772"></p></blockquote><pre><code class="shell"># 执行 git status 查看整个仓库的状态git status# 使用 git add [文件名] 命令跟踪此新建文件，即把新增文件添加到暂存区，以备提交git add one.txt# 如果要撤销暂存区的修改怎么办？# 根据上图的提示，执行 git reset -- [文件名] 或者 git rm --cached [文件名] 命令即可git reset -- one.txt# 用于查看 Git 仓库中所有分支（包括本地和远程分支）详细信息的命令。git branch -avv# 执行 git commit 命令生成一个新的提交，一个必须的选项 -m 用来提供该提交的备注git commit -m 'commit one'# 执行 git log 查看提交记录，紫色框中的十六进制序列号就是提交版本号git log#  git reset --soft HEAD^ 撤销最近的一次提交，将修改还原到暂存区git reset --soft HEAD^# 因为刚才的提交操作不是基于远程仓库 origin/master 分支的最新提交版本，而是撤回了一个版本。这种情况下也是可以将本地 master 分支推送到远程仓库的，需要加一个选项 -f ，它是 --force 的简写，这就是强制推送# push 是需要联网执行的，它对远程仓库进行了修改git push -f# git reflog 命令，它会记录本地仓库所有分支的每一次版本变化git reflog# 怎么回退到 5c04 那个版本呢？可以直接执行命令 git reset --hard [版本号]# 如果记不清版本号，也可以根据上图第 3 行的信息，执行 git reset --hard HEAD@{2} 命令git reset --hard HEAD@{2}# 还想反悔，刚才还是改对了，怎么办？再执行一次即可，这次大括号里就是 1 了git reset --hard HEAD@{1}</code></pre><h1 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h1><p>有些命令的重复度极高，比如 <code>git status</code> 和 <code>git branch -avv</code> 等，Git 可以对这些命令设置别名，以便简化对它们的使用，设置别名的命令是 <code>git config --global alias.[别名] [原命令]</code>，如果原命令中有选项，需要加引号。别名是自定义的，可以随意命名，设置后，原命令和别名具有同等作用。</p><blockquote><p><img src="https://doc.shiyanlou.com/courses/uid310176-20190514-1557819719173" alt="图片描述"></p></blockquote><p>自己设置的别名要记住，也可以使用 <code>git config -l</code> 命令查看配置文件。</p><ol><li><p><strong>git fetch</strong>：</p><ul><li><code>git fetch</code> 仅仅是将远程仓库的更新下载到本地，但它不会自动合并或更新你的当前工作分支。</li><li>它会下载远程分支的最新状态，但不会影响你的本地分支，你需要手动将这些更新合并到你的分支中。</li></ul><p>使用示例：</p><pre><code class="shell">git fetch origin</code></pre></li><li><p><strong>git pull</strong>：</p><ul><li><code>git pull</code> 也从远程仓库获取更新，但它会自动将远程分支的更新合并到你的当前分支。</li><li>通常，<code>git pull</code> 相当于运行 <code>git fetch</code> 后再运行 <code>git merge</code> 来合并远程分支的更新。</li></ul><p>使用示例：</p><pre><code class="shell">git pull origin master</code></pre></li></ol><p>总之，主要区别在于自动合并。<code>git fetch</code> 用于获取远程更新，但不自动合并，而 <code>git pull</code> 用于获取远程更新并自动合并到当前分支。选择使用哪一个取决于你的工作流程和需求。如果你想手动审查和控制合并过程，可以首先运行 <code>git fetch</code>，然后手动合并。如果你想快速将远程更新合并到当前分支，可以使用 <code>git pull</code>。</p><h2 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h2><p>要查看分支信息，只需在终端中输入以下命令：</p><pre><code class="shell">git branch</code></pre><p>这将列出本地分支，当前分支将以星号标记。如果要查看远程分支，可以使用以下命令：</p><pre><code class="shell">git branch -r</code></pre><pre><code class="shell"># 执行 git branch [分支名] 可以创建新的分支git branch dev# 执行 git checkout [分支名] 切换分支git checkout dev</code></pre><p>在新的分支中创建文件然后进行提交到暂存区和版本库</p><img src="C:\Users\7878\AppData\Roaming\Typora\typora-user-images\image-20231018144722734.png" alt="image-20231018144722734" style="zoom:50%;"><p>好，新功能已经写好并提交到了版本区，现在要推送了，推送到哪里呢？正常逻辑当然要推送到远程仓库的同名分支，不过现在远程仓库里只有一个分支：</p><pre><code class="shell"># 执行 git push [主机名] [本地分支名]:[远程分支名] 即可将本地分支推送到远程仓库的分支中，通常冒号前后的分支名是相同的，如果是相同的，可以省略 :[远程分支名]，如果远程分支不存在，会自动创建git push origin dev:dev</code></pre><img src="C:\Users\7878\AppData\Roaming\Typora\typora-user-images\image-20231018145103413.png" alt="image-20231018145103413" style="zoom:50%;"><img src="C:\Users\7878\AppData\Roaming\Typora\typora-user-images\image-20231018145147990.png" alt="image-20231018145147990" style="zoom: 50%;"><p>如果再次在dev上修改并提交每次仍要输入<code>git push origin dev:dev</code>,可以像main一样将本地branch与远程branch关联</p><pre><code class="shell"># 执行这个命令 git branch -u [主机名/远程分支名] [本地分支名] 将本地分支与远程分支关联git branch -u origin/dev</code></pre><h2 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h2><pre><code class="shell"># 删除远程分支的命令：git push [主机名] --delete [远程分支名]git push origin --delete dev# 使用 git branch -D [分支名] 删除本地分支git branch -D dev</code></pre><h1 id="多人操作"><a href="#多人操作" class="headerlink" title="多人操作"></a>多人操作</h1><p>建立新的仓库，邀请参与人员</p><p>组长可以发布issue</p><p>组员克隆仓库到本地 <code>git clone </code></p><p>解决issue 在提交时 <code>git commit - m 'fix #1 this is fix one'</code></p><p><code>pull requests</code></p><p><img src="https://doc.shiyanlou.com/document-uid310176labid9824timestamp1548757171365.png" alt="此处输入图片的描述"></p><p><img src="https://doc.shiyanlou.com/document-uid310176labid9824timestamp1548757180192.png" alt="此处输入图片的描述"></p><p><img src="https://doc.shiyanlou.com/document-uid310176labid9824timestamp1548757180192.png" alt="此处输入图片的描述"></p><p><img src="https://doc.shiyanlou.com/document-uid310176labid9824timestamp1548757219135.png" alt="此处输入图片的描述"></p><p>以上就是一次完整的修改、提交、推送、提 PR、合并 PR 的过程。</p><p><strong>需要注意的一点：从 A 向 B 提 PR 后，在 PR 合并或关闭前，A 上所有新增的提交都会出现在 PR 里。</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/10/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C/"/>
      <url>/2023/10/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="实验四"><a href="#实验四" class="headerlink" title="实验四"></a>实验四</h1><p><strong>(1) 创建一个目录，目录名用学号命名：</strong></p><pre><code class="bash">hdfs dfs -mkdir /201612345</code></pre><p><strong>(2) 查看该目录是否成功创建：</strong></p><pre><code class="bash">hdfs dfs -ls /</code></pre><p><strong>(3) 创建一个文本文件并上传到HDFS：</strong></p><pre><code class="bash">echo "hello hdfs" &gt; /usr/local/hadoop/zhangsan.txthdfs dfs -put /usr/local/hadoop/zhangsan.txt /201612345/</code></pre><p><strong>(4) 将该文件上传到HDFS的学号目录中：</strong></p><p>这已经在第三步中完成。</p><p><strong>(5) 查看该文件是否成功上传到HDFS中：</strong></p><pre><code class="bash">hdfs dfs -ls /201612345</code></pre><p><strong>(6) 将该文件从HDFS下载到本地目录：</strong></p><pre><code class="bash">hdfs dfs -get /201612345/zhangsan.txt /home/hadoop/downloads/</code></pre><p><strong>(7) 将该文件从学号目录中拷贝到input目录中，并查看是否拷贝成功：</strong></p><pre><code class="bash">hdfs dfs -cp /201612345/zhangsan.txt /input/</code></pre><p><strong>(8) 在HDFS中将该文件从学号目录中删除：</strong></p><pre><code class="bash">hdfs dfs -rm /201612345/zhangsan.txt</code></pre><p><strong>(9) 在HDFS中将学号目录删除：</strong></p><pre><code class="bash">hdfs dfs -rmdir /201612345</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>yhcsb</title>
      <link href="/2023/10/10/yhcsb/"/>
      <url>/2023/10/10/yhcsb/</url>
      
        <content type="html"><![CDATA[<p><img src="E:\hexo\1PHAN-7878.github.io\source\images\fengjing.jpg" alt="fengjing"></p>]]></content>
      
      
      
        <tags>
            
            <tag> yu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/09/22/java/"/>
      <url>/2023/09/22/java/</url>
      
        <content type="html"><![CDATA[<h1 id="1-基本语法"><a href="#1-基本语法" class="headerlink" title="1 基本语法"></a>1 基本语法</h1><h2 id="1-1-String"><a href="#1-1-String" class="headerlink" title="1.1 String"></a>1.1 String</h2><p>在Java中，<code>String</code> 类是用于表示字符串的类，它提供了丰富的方法和功能来操作字符串。字符串是一组字符的序列，而在Java中，字符串是不可变的，这意味着一旦创建了字符串，就不能更改其内容。</p><p>以下是一些常用的 <code>String</code> 类的用法和示例：</p><h3 id="1-创建字符串"><a href="#1-创建字符串" class="headerlink" title="1. 创建字符串"></a>1. 创建字符串</h3><p>可以通过直接赋值或使用构造函数创建字符串对象：</p><pre><code class="java">String str1 = "Hello, World!";  // 使用直接赋值创建字符串String str2 = new String("Hello, World!");  // 使用构造函数创建字符串</code></pre><h3 id="2-获取字符串长度"><a href="#2-获取字符串长度" class="headerlink" title="2. 获取字符串长度"></a>2. 获取字符串长度</h3><p>可以使用 <code>length()</code> 方法获取字符串的长度：</p><pre><code class="java">String str = "Hello, World!";int length = str.length();  // 获取字符串长度System.out.println("Length of the string: " + length);</code></pre><h3 id="3-拼接字符串"><a href="#3-拼接字符串" class="headerlink" title="3. 拼接字符串"></a>3. 拼接字符串</h3><p>可以使用 <code>+</code> 运算符或 <code>concat()</code> 方法将多个字符串拼接在一起：</p><pre><code class="java">String str1 = "Hello, ";String str2 = "World!";String result = str1 + str2;  // 使用 + 运算符拼接字符串// 或者使用 concat() 方法String result = str1.concat(str2);System.out.println("Concatenated string: " + result);</code></pre><h3 id="4-字符串比较"><a href="#4-字符串比较" class="headerlink" title="4. 字符串比较"></a>4. 字符串比较</h3><p>可以使用 <code>equals()</code> 方法或 <code>compareTo()</code> 方法比较字符串：</p><pre><code class="java">String str1 = "hello";String str2 = "Hello";boolean isEqual = str1.equals(str2);  // 使用 equals() 比较字符串int comparison = str1.compareTo(str2);  // 使用 compareTo() 比较字符串</code></pre><h3 id="5-提取子字符串"><a href="#5-提取子字符串" class="headerlink" title="5. 提取子字符串"></a>5. 提取子字符串</h3><p>可以使用 <code>substring()</code> 方法从字符串中提取子串：</p><pre><code class="java">String str = "Hello, World!";String subStr = str.substring(7);  // 提取从位置7开始的子串System.out.println("Substring: " + subStr);</code></pre><h3 id="6-查找子字符串"><a href="#6-查找子字符串" class="headerlink" title="6. 查找子字符串"></a>6. 查找子字符串</h3><p>可以使用 <code>indexOf()</code> 方法或 <code>contains()</code> 方法查找子字符串是否存在：</p><pre><code class="java">String str = "Hello, World!";int index = str.indexOf("World");  // 查找子串的位置boolean contains = str.contains("Hello");  // 检查是否包含子串</code></pre><h2 id="1-2-StringBuilder"><a href="#1-2-StringBuilder" class="headerlink" title="1.2 StringBuilder"></a>1.2 StringBuilder</h2><p>在Java中，<code>StringBuilder</code> 是一个用于处理可变字符串的类。与 <code>String</code> 不同，<code>StringBuilder</code> 允许你在不创建新对象的情况下修改字符串的内容，这对于频繁的字符串拼接操作非常高效。以下是一些使用 <code>StringBuilder</code> 的常见方法和示例：</p><h3 id="1-创建-StringBuilder-对象"><a href="#1-创建-StringBuilder-对象" class="headerlink" title="1. 创建 StringBuilder 对象"></a>1. 创建 <code>StringBuilder</code> 对象</h3><p>可以使用构造函数创建一个 <code>StringBuilder</code> 对象：</p><pre><code class="java">StringBuilder sb = new StringBuilder(); // 创建一个空的 StringBuilder 对象</code></pre><p>你也可以在构造函数中传入一个初始字符串：</p><pre><code class="java">StringBuilder sb = new StringBuilder("Hello"); // 创建包含初始字符串 "Hello" 的 StringBuilder 对象</code></pre><h3 id="2-追加字符串"><a href="#2-追加字符串" class="headerlink" title="2. 追加字符串"></a>2. 追加字符串</h3><p>可以使用 <code>append()</code> 方法来追加字符串到 <code>StringBuilder</code> 对象：</p><pre><code class="java">StringBuilder sb = new StringBuilder("Hello");sb.append(", World!"); // 追加字符串</code></pre><h3 id="3-插入字符串"><a href="#3-插入字符串" class="headerlink" title="3. 插入字符串"></a>3. 插入字符串</h3><p>使用 <code>insert()</code> 方法可以在指定位置插入字符串：</p><pre><code class="java">StringBuilder sb = new StringBuilder("Hello");sb.insert(5, " Java"); // 在位置5插入字符串</code></pre><h3 id="4-删除字符"><a href="#4-删除字符" class="headerlink" title="4. 删除字符"></a>4. 删除字符</h3><p>使用 <code>delete()</code> 方法可以删除指定范围内的字符：</p><pre><code class="java">StringBuilder sb = new StringBuilder("Hello, World!");sb.delete(7, 13); // 删除位置7到13之间的字符</code></pre><h3 id="5-替换字符"><a href="#5-替换字符" class="headerlink" title="5. 替换字符"></a>5. 替换字符</h3><p>使用 <code>replace()</code> 方法可以替换指定范围内的字符：</p><pre><code class="java">StringBuilder sb = new StringBuilder("Hello, World!");sb.replace(7, 13, "Java"); // 将位置7到13之间的字符替换为 "Java"</code></pre><h3 id="6-获取字符串"><a href="#6-获取字符串" class="headerlink" title="6. 获取字符串"></a>6. 获取字符串</h3><p>使用 <code>toString()</code> 方法可以将 <code>StringBuilder</code> 对象转换为 <code>String</code>：</p><pre><code class="java">StringBuilder sb = new StringBuilder("Hello, World!");String result = sb.toString(); // 转换为 String</code></pre><h3 id="7-获取长度"><a href="#7-获取长度" class="headerlink" title="7. 获取长度"></a>7. 获取长度</h3><p>可以使用 <code>length()</code> 方法获取 <code>StringBuilder</code> 中字符的数量：</p><pre><code class="java">StringBuilder sb = new StringBuilder("Hello, World!");int length = sb.length(); // 获取长度</code></pre><p><code>StringBuilder</code> 的方法允许你执行许多字符串操作，而不需要创建多个不必要的字符串对象，这在性能上通常更高效。因此，当需要频繁修改字符串时，建议使用 <code>StringBuilder</code>。</p><h2 id="1-3-final关键字"><a href="#1-3-final关键字" class="headerlink" title="1.3 final关键字"></a>1.3 final关键字</h2><p><code>final</code> 是 Java 编程语言中的一个关键字，用于表示不可变性和不可继承性，它可以用于不同的上下文中，具体作用如下：</p><ol><li><p><strong>不可变变量</strong>：当你将 <code>final</code> 关键字应用于一个变量时，它表示该变量的值不能被修改，即它是一个不可变变量（immutable）。通常用于声明常量，这意味着一旦分配了值，就不能再更改。例如：</p><pre><code class="java">final int x = 10;// x = 20;  // 这将导致编译错误，因为 x 是不可变的</code></pre></li><li><p><strong>不可变类</strong>：当你将 <code>final</code> 关键字应用于一个类时，它表示该类不能被继承，即它是一个不可继承的类。这通常用于防止其他类继承或修改基类的行为，以确保类的稳定性和安全性。</p><pre><code class="java">final class MyFinalClass {    // 类的成员和方法}// 下面的代码将导致编译错误，因为无法继承 MyFinalClass// class AnotherClass extends MyFinalClass { ... }</code></pre></li><li><p><strong>不可变方法</strong>：当你将 <code>final</code> 关键字应用于一个方法时，它表示该方法不能被子类重写或覆盖。这通常用于确保某个方法的行为不会被修改。</p><pre><code class="java">class MyBaseClass {    final void myFinalMethod() {        // 这个方法不能被子类重写    }}</code></pre></li><li><p><strong>不可变参数</strong>：当你将 <code>final</code> 关键字应用于方法的参数时，它表示该参数的值在方法内部不能被修改。</p><pre><code class="java">void myMethod(final int param) {    // param 的值不能在方法内部被修改}</code></pre></li></ol><h2 id="1-4-super关键字"><a href="#1-4-super关键字" class="headerlink" title="1.4 super关键字"></a>1.4 super关键字</h2><p><code>super</code> 是 Java 中的一个关键字，用于引用父类（或超类）的成员变量、方法和构造函数。它可以在子类中使用，用于访问或调用父类的成员或构造函数。以下是关于 <code>super</code> 关键字的使用方法：</p><ol><li><p><strong>访问父类的成员变量</strong>：你可以使用 <code>super</code> 关键字来访问父类中的成员变量，特别是在子类中存在与父类同名的成员变量时。这样可以避免混淆。</p><pre><code class="java">class Parent {    int x = 10;}class Child extends Parent {    int x = 20;    void display() {        System.out.println("子类 x：" + x); // 访问子类的 x        System.out.println("父类 x：" + super.x); // 访问父类的 x    }}</code></pre></li><li><p><strong>调用父类的方法</strong>：你可以使用 <code>super</code> 关键字来调用父类中的方法，特别是在子类中存在与父类同名的方法时。</p><pre><code class="java">class Parent {    void showMessage() {        System.out.println("这是父类的消息");    }}class Child extends Parent {    void showMessage() {        System.out.println("这是子类的消息");        super.showMessage(); // 调用父类的 showMessage() 方法    }}</code></pre></li><li><p><strong>调用父类的构造函数</strong>：你可以使用 <code>super</code> 关键字来调用父类的构造函数。这通常用于子类的构造函数中，以确保父类的初始化工作得以执行。</p><pre><code class="java">class Parent {    Parent() {        System.out.println("父类的构造函数");    }}class Child extends Parent {    Child() {        super(); // 调用父类的构造函数        System.out.println("子类的构造函数");    }}</code></pre></li></ol><p>注意事项：</p><ul><li>在子类构造函数中，如果没有显式调用 <code>super()</code> 来调用父类的构造函数，Java 将自动调用父类的默认构造函数。</li><li><code>super()</code> 必须作为子类构造函数的第一行语句出现，因此它通常是构造函数的第一句。</li></ul><h2 id="1-5-abstract-关键字"><a href="#1-5-abstract-关键字" class="headerlink" title="1.5 abstract 关键字"></a>1.5 abstract 关键字</h2><p><code>abstract</code> 是 Java 中的一个关键字，用于声明抽象类和抽象方法。抽象类和抽象方法的目的是为了提供一种结构，以便其他类可以继承或实现它们，并根据需要进行定制化实现。以下是 <code>abstract</code> 关键字的主要作用：</p><ol><li><p><strong>抽象类</strong>：</p><ul><li>抽象类用 <code>abstract</code> 关键字声明，它不能被实例化（不能创建对象）。</li><li>抽象类可以包含抽象方法和非抽象方法。</li><li>抽象类的存在是为了被继承和拓展，提供通用的结构和行为。</li></ul><pre><code class="java">abstract class AbstractClass {    // 抽象方法    abstract void abstractMethod();    // 普通方法    void nonAbstractMethod() {        System.out.println("非抽象方法的实现");    }}</code></pre></li><li><p><strong>抽象方法</strong>：</p><ul><li>抽象方法用 <code>abstract</code> 关键字声明，但没有方法体。</li><li>抽象方法必须在抽象类中声明，不允许在普通类中声明。</li><li>抽象方法的具体实现由继承抽象类的子类完成。</li></ul><pre><code class="java">abstract class AbstractClass {    // 抽象方法    abstract void abstractMethod();}class ConcreteClass extends AbstractClass {    // 必须实现抽象方法    @Override    void abstractMethod() {        System.out.println("抽象方法的实现");    }}</code></pre></li></ol><p>抽象类和抽象方法的作用是为了促使子类实现特定的行为，同时确保了基类中的通用结构。这有助于提高代码的可维护性和扩展性，同时强调了面向对象设计的抽象思想。</p><h1 id="2-类"><a href="#2-类" class="headerlink" title="2 类"></a>2 类</h1><h2 id="2-1-接口"><a href="#2-1-接口" class="headerlink" title="2.1 接口"></a>2.1 接口</h2><p>在 Java 中，接口（Interface）是一种抽象类型，它定义了一组抽象方法，但没有具体的实现。接口通常用于描述对象应该具有的行为。以下是关于 Java 接口的主要特点：</p><ol><li><p><strong>接口定义</strong>：接口使用 <code>interface</code> 关键字定义。</p><pre><code class="java">interface MyInterface {    // 抽象方法的声明    void abstractMethod();}</code></pre></li><li><p><strong>抽象方法</strong>：接口中的方法都是抽象的，它们只有方法签名，没有方法体。</p></li><li><p><strong>接口实现</strong>：一个类可以实现一个或多个接口。使用关键字 <code>implements</code> 来表示类实现了一个接口。</p><pre><code class="java">class MyClass implements MyInterface {    // 必须实现接口中的抽象方法    @Override    public void abstractMethod() {        // 实现具体逻辑    }}</code></pre></li><li><p><strong>多继承</strong>：Java 中不支持多继承，但一个类可以实现多个接口，这使得 Java 中的多继承概念得以体现。</p><pre><code class="java">interface Interface1 {    void method1();}interface Interface2 {    void method2();}class MyClass implements Interface1, Interface2 {    @Override    public void method1() {        // 实现 method1    }    @Override    public void method2() {        // 实现 method2    }}</code></pre></li><li><p><strong>接口默认方法</strong>：从 Java 8 开始，接口可以包含具有默认实现的方法。</p><pre><code class="java">interface MyInterface {    void abstractMethod();    default void defaultMethod() {        System.out.println("默认方法的实现");    }}</code></pre></li><li><p><strong>接口静态方法</strong>：从 Java 8 开始，接口可以包含静态方法。</p><pre><code class="java">interface MyInterface {    void abstractMethod();    static void staticMethod() {        System.out.println("静态方法的实现");    }}</code></pre></li></ol><p>接口在 Java 中扮演着重要的角色，它提供了一种将抽象概念定义为一组行为的方式，从而实现了多态性和代码复用。接口也是 Java 中实现多继承的一种方式，使得类可以实现多个行为规范。</p><h2 id="2-2-Override"><a href="#2-2-Override" class="headerlink" title="2.2 @Override"></a>2.2 @Override</h2><p><code>@Override</code> 注解用于告诉编译器，被标注的方法是要重写（覆盖）父类或接口中的方法。通常情况下，你应该在以下情况下使用 <code>@Override</code> 注解：</p><ol><li><p><strong>重写父类方法</strong>：当你在子类中编写一个方法，其名称、参数列表和返回类型与父类中的方法完全一致时，应该使用 <code>@Override</code> 注解来明确指示你意图重写父类方法。</p><pre><code class="java">class Parent {    void myMethod() {        // 父类方法    }}class Child extends Parent {    @Override    void myMethod() {        // 子类重写的方法    }}</code></pre></li><li><p><strong>实现接口方法</strong>：当你在一个类中实现了一个接口中的方法时，也应该使用 <code>@Override</code> 注解。这有助于提醒你，你是在实现一个接口方法，而不是创建一个新的方法。</p><pre><code class="java">interface MyInterface {    void myMethod();}class MyClass implements MyInterface {    @Override    public void myMethod() {        // 实现接口方法    }}</code></pre></li><li><p><strong>编码规范</strong>：在许多编码规范中，推荐使用 <code>@Override</code> 注解，以提高代码的可读性和可维护性。这有助于其他开发人员理解你的代码意图，并防止意外的方法签名变更。</p></li></ol><p>虽然在上述情况下使用 <code>@Override</code> 注解是很好的实践，但并非所有情况下都需要使用它。在以下情况下，你通常不需要使用 <code>@Override</code> 注解：</p><ul><li>当你编写的方法不是为了重写父类或实现接口中的方法时。</li><li>当你在 Java 版本低于 5 的环境中编写代码，因为 <code>@Override</code> 注解是在 Java 5 中引入的。</li></ul><h1 id="3-常用类"><a href="#3-常用类" class="headerlink" title="3 常用类"></a>3 常用类</h1><h2 id="3-1-Arrays"><a href="#3-1-Arrays" class="headerlink" title="3.1 Arrays"></a>3.1 Arrays</h2><p>当使用 <code>Arrays</code> 类的方法时，通常需要导入 <code>java.util.Arrays</code> 包。以下是一些使用 <code>Arrays</code> 类方法的示例：</p><p><strong>1. 使用 <code>sort</code> 方法对数组进行排序：</strong></p><pre><code class="java">import java.util.Arrays;public class ArraySortingExample {    public static void main(String[] args) {        int[] numbers = {5, 2, 9, 1, 5, 6};                Arrays.sort(numbers);                System.out.println("Sorted Array: " + Arrays.toString(numbers));    }}</code></pre><p><strong>2. 使用 <code>binarySearch</code> 方法查找元素：</strong></p><pre><code class="java">import java.util.Arrays;public class BinarySearchExample {    public static void main(String[] args) {        int[] numbers = {1, 2, 3, 4, 5, 6};                int key = 3;        int index = Arrays.binarySearch(numbers, key);                if (index &gt;= 0) {            System.out.println("Element " + key + " found at index " + index);        } else {            System.out.println("Element " + key + " not found in the array");        }    }}</code></pre><p><strong>3. 使用 <code>equals</code> 方法比较数组：</strong></p><pre><code class="java">import java.util.Arrays;public class ArrayComparisonExample {    public static void main(String[] args) {        int[] array1 = {1, 2, 3};        int[] array2 = {1, 2, 3};                boolean isEqual = Arrays.equals(array1, array2);                if (isEqual) {            System.out.println("Arrays are equal.");        } else {            System.out.println("Arrays are not equal.");        }    }}</code></pre><p><strong>4. 使用 <code>fill</code> 方法填充数组：</strong></p><pre><code class="java">import java.util.Arrays;public class ArrayFillExample {    public static void main(String[] args) {        int[] numbers = new int[5];                Arrays.fill(numbers, 42);                System.out.println("Filled Array: " + Arrays.toString(numbers));    }}</code></pre><h2 id="3-2-time"><a href="#3-2-time" class="headerlink" title="3.2 time"></a>3.2 time</h2><p><code>java.time</code> 包是Java 8引入的现代日期和时间处理API，提供了一系列类来处理日期、时间和时区。以下是一些<code>java.time</code>包的主要类和用法示例：</p><ol><li><p><strong>LocalDate</strong>：用于表示日期，不包含时间和时区信息。</p><pre><code class="java">LocalDate today = LocalDate.now();LocalDate customDate = LocalDate.of(2023, 9, 25);int year = today.getYear();int month = today.getMonthValue();int day = today.getDayOfMonth();</code></pre></li><li><p><strong>LocalTime</strong>：用于表示时间，不包含日期和时区信息。</p><pre><code class="java">LocalTime currentTime = LocalTime.now();LocalTime customTime = LocalTime.of(14, 30, 0);int hour = currentTime.getHour();int minute = currentTime.getMinute();int second = currentTime.getSecond();</code></pre></li><li><p><strong>LocalDateTime</strong>：用于表示日期和时间的组合，不包含时区信息。</p><pre><code class="java">LocalDateTime currentDateTime = LocalDateTime.now();LocalDateTime customDateTime = LocalDateTime.of(2023, 9, 25, 14, 30, 0);int year = currentDateTime.getYear();int month = currentDateTime.getMonthValue();int hour = currentDateTime.getHour();</code></pre></li><li><p><strong>ZonedDateTime</strong>：用于表示带时区的日期和时间。</p><pre><code class="java">ZoneId newYorkZone = ZoneId.of("America/New_York");ZonedDateTime newYorkTime = ZonedDateTime.now(newYorkZone);ZoneId londonZone = ZoneId.of("Europe/London");ZonedDateTime londonTime = newYorkTime.withZoneSameInstant(londonZone);</code></pre></li><li><p><strong>Duration</strong>：用于表示时间段，可以用于计算时间间隔。</p><pre><code class="java">LocalDateTime start = LocalDateTime.of(2023, 9, 1, 8, 0);LocalDateTime end = LocalDateTime.of(2023, 9, 5, 17, 0);Duration duration = Duration.between(start, end);long hours = duration.toHours();long minutes = duration.toMinutes();</code></pre></li><li><p><strong>Period</strong>：用于表示日期段，可以用于计算日期间隔。</p><pre><code class="java">LocalDate startDate = LocalDate.of(2023, 9, 1);LocalDate endDate = LocalDate.of(2023, 9, 5);Period period = Period.between(startDate, endDate);int days = period.getDays();int months = period.getMonths();</code></pre></li><li><p><strong>DateTimeFormatter</strong>：用于日期和时间的格式化和解析。</p><pre><code class="java">DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");String formattedDateTime = LocalDateTime.now().format(formatter);LocalDateTime parsedDateTime = LocalDateTime.parse("2023-09-25 14:30:00", formatter);</code></pre></li><li><p><strong>TemporalAdjusters</strong>：提供了一些有用的日期调整器，例如获取某月的第一个周一。</p><pre><code class="java">LocalDate firstMondayOfSeptember = LocalDate.of(2023, 9, 1).with(TemporalAdjusters.firstInMonth(DayOfWeek.MONDAY));</code></pre></li></ol><h2 id="3-3-Math"><a href="#3-3-Math" class="headerlink" title="3.3 Math"></a>3.3 Math</h2><p><code>java.lang.Math</code> 类包含了一些常用的数学方法，用于执行各种数学运算。以下是一些常用的 <code>Math</code> 类方法：</p><ol><li><strong>绝对值相关方法：</strong><ul><li><code>abs(x)</code>：返回给定数的绝对值。</li><li><code>max(x, y)</code>：返回两个数中较大的那个。</li><li><code>min(x, y)</code>：返回两个数中较小的那个。</li></ul></li><li><strong>舍入相关方法：</strong><ul><li><code>ceil(x)</code>：将参数向正无穷方向舍入为最接近的整数。</li><li><code>floor(x)</code>：将参数向负无穷方向舍入为最接近的整数。</li><li><code>round(x)</code>：将参数四舍五入为最接近的整数。</li><li><code>rint(x)</code>：将参数四舍五入为最接近的整数，如果两个整数同样接近，则选择偶数。</li></ul></li><li><strong>指数和对数相关方法：</strong><ul><li><code>exp(x)</code>：返回指数函数 e^x 的值。</li><li><code>log(x)</code>：返回自然对数（以 e 为底）的值。</li><li><code>pow(x, y)</code>：返回 x 的 y 次方。</li><li><code>sqrt(x)</code>：返回给定数的平方根。</li></ul></li><li><strong>三角函数相关方法：</strong><ul><li><code>sin(x)</code>：返回给定角度的正弦值。</li><li><code>cos(x)</code>：返回给定角度的余弦值。</li><li><code>tan(x)</code>：返回给定角度的正切值。</li><li><code>asin(x)</code>：返回给定值的反正弦值。</li><li><code>acos(x)</code>：返回给定值的反余弦值。</li><li><code>atan(x)</code>：返回给定值的反正切值。</li><li><code>toRadians(x)</code>：将角度从度数转换为弧度。</li><li><code>toDegrees(x)</code>：将角度从弧度转换为度数。</li></ul></li><li><strong>随机数生成方法：</strong><ul><li><code>random()</code>：返回一个伪随机 double 值，范围在 [0.0, 1.0) 之间。</li></ul></li></ol><h2 id="3-4-System"><a href="#3-4-System" class="headerlink" title="3.4 System"></a>3.4 System</h2><p><code>java.lang.System</code> 类是Java标准库中的一个类，它提供了一系列用于与系统交互的方法，包括访问系统属性、标准输入输出、以及进行垃圾回收等。以下是一些常见的 <code>System</code> 类方法和用法：</p><ol><li><p><strong>标准输入输出（I/O）：</strong></p><p>-<br>  System.out</p><p>  标准输出流，通常用于向控制台打印信息。</p><pre><code class="java">System.out.println("Hello, world!"); // 打印文本到控制台</code></pre><p>-<br>  System.err</p><p>  标准错误流，用于输出错误信息。</p><pre><code class="java">System.err.println("An error occurred!"); // 打印错误信息到控制台</code></pre><p>-<br>  System.in</p><p>  标准输入流，通常用于从控制台读取用户输入。</p><pre><code class="java">Scanner scanner = new Scanner(System.in);System.out.print("Enter your name: ");String name = scanner.nextLine();</code></pre></li><li><p><strong>系统属性：</strong></p><p>-<br>  System.getProperty(String key)</p><p>  ：获取系统属性的值，可以用于获取系统信息，如操作系统类型、Java版本等。</p><pre><code class="java">String osName = System.getProperty("os.name");String javaVersion = System.getProperty("java.version");</code></pre></li><li><p><strong>垃圾回收：</strong></p><p>-<br>  System.gc()</p><p>  ：请求系统进行垃圾回收操作。注意，具体的垃圾回收时机和行为是由JVM决定的，所以不一定会立即执行垃圾回收。</p><pre><code class="java">System.gc(); // 请求进行垃圾回收</code></pre></li><li><p><strong>程序终止：</strong></p><ul><li><pre><code class="java">System.exit(int status)</code></pre><p>终止当前Java虚拟机的运行，参数通常用于指示程序的退出状态。0 表示正常退出，非零值通常用于表示异常退出。</p><pre><code class="java">System.exit(0); // 正常退出</code></pre></li></ul></li><li><p><strong>时间获取：</strong></p><ul><li><pre><code>System.currentTimeMillis()</code></pre><p>：返回当前时间的毫秒数，通常用于性能分析和计时。</p><pre><code class="java">long startTime = System.currentTimeMillis();// 执行一些代码long endTime = System.currentTimeMillis();long elapsedTime = endTime - startTime;</code></pre></li></ul></li><li><p><strong>数组拷贝：</strong></p><ul><li><pre><code class="java">System.arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</code></pre><p>：用于将源数组的一部分复制到目标数组的指定位置。</p><pre><code class="java">int[] sourceArray = {1, 2, 3, 4, 5};int[] destArray = new int[5];System.arraycopy(sourceArray, 0, destArray, 0, 5);</code></pre></li></ul></li></ol><p><code>System</code> 类提供了许多有用的方法，可以用于访问系统资源、执行一些底层操作，以及进行基本的输入输出。在实际编程中，它通常用于调试、性能分析、系统属性获取等操作。但要注意，在大多数情况下，直接与系统资源交互的需求不多，因为Java提供了更高级的库和API来完成常见的任务。</p><h2 id="3-5-Random"><a href="#3-5-Random" class="headerlink" title="3.5 Random"></a>3.5 Random</h2><p>在Java中，你可以使用 <code>java.util.Random</code> 类来生成随机数。以下是使用 <code>Random</code> 类的基本方法：</p><ol><li><p><strong>创建 Random 对象：</strong></p><p>首先，你需要创建一个 <code>Random</code> 对象，可以通过以下方式之一来实现：</p><pre><code class="java">// 使用默认种子创建 Random 对象Random random = new Random();// 使用指定种子创建 Random 对象long seed = 123456789L; // 可以是任何长整数Random seededRandom = new Random(seed);</code></pre><p>通常情况下，如果你不需要指定特定的种子，可以使用无参数的构造函数创建 <code>Random</code> 对象，它会使用系统时间作为默认种子。</p></li><li><p><strong>生成随机整数：</strong></p><p>使用 <code>nextInt()</code> 方法可以生成一个随机整数：</p><pre><code class="java">int randomNumber = random.nextInt(); // 生成任意范围的随机整数</code></pre><p>如果你希望生成在指定范围内的随机整数，可以使用 <code>nextInt(int bound)</code> 方法：</p><pre><code class="java">int min = 1;int max = 100;int randomInRange = random.nextInt(max - min + 1) + min; // 生成1到100之间的随机整数</code></pre></li><li><p><strong>生成随机浮点数：</strong></p><p>使用 <code>nextDouble()</code> 方法可以生成一个随机的 double 值，范围在 [0.0, 1.0) 之间：</p><pre><code class="java">double randomDouble = random.nextDouble(); // 生成0.0到1.0之间的随机浮点数</code></pre></li><li><p><strong>生成随机布尔值：</strong></p><p>使用 <code>nextBoolean()</code> 方法可以生成一个随机的布尔值（<code>true</code> 或 <code>false</code>）：</p><pre><code class="java">boolean randomBoolean = random.nextBoolean(); // 随机生成true或false</code></pre></li></ol><h1 id="4-泛型"><a href="#4-泛型" class="headerlink" title="4 泛型"></a>4 泛型</h1><h2 id="4-1-介绍"><a href="#4-1-介绍" class="headerlink" title="4.1 介绍"></a>4.1 介绍</h2><p>Java中的泛型是一种编程机制，它允许你在类、接口和方法中使用类型参数，以在不同情况下使用相同的代码来处理不同的数据类型。泛型的主要目的是提高代码的重用性、类型安全性和可读性。</p><p>使用泛型，你可以定义类、接口或方法，使其能够处理多种数据类型而不必在每次使用时进行强制类型转换。泛型类、泛型接口和泛型方法的定义都可以包含类型参数。类型参数可以在定义时指定，然后在实际使用时传入具体的类型。</p><p>以下是一个简单的泛型类的示例：</p><pre><code class="java">public class GenericBox&lt;T&gt; {    private T value;    public GenericBox(T value) {        this.value = value;    }    public T getValue() {        return value;    }}</code></pre><p>在这个示例中，<code>GenericBox</code> 是一个泛型类，它有一个类型参数 <code>T</code>。你可以创建 <code>GenericBox</code> 的实例，将不同类型的数据存储在其中，而无需进行显式的类型转换。</p><p>例如：</p><pre><code class="java">GenericBox&lt;Integer&gt; intBox = new GenericBox&lt;&gt;(42);Integer intValue = intBox.getValue(); // 不需要强制类型转换GenericBox&lt;String&gt; strBox = new GenericBox&lt;&gt;("Hello, Generics!");String strValue = strBox.getValue(); // 不需要强制类型转换</code></pre><p>这使得代码更灵活，可以在不同的情况下使用相同的泛型类，而不必为每种数据类型创建不同的类或方法。泛型还有助于在编译时检测类型错误，提高了代码的安全性。</p><p>在Java中，尖括号 <code>&lt;&gt;</code> 主要用于泛型（Generics）的定义和使用。泛型是Java中的一项重要特性，允许你编写通用的、类型安全的代码，以便在运行时处理不同类型的数据。</p><p>以下是 <code>&lt;&gt;</code> 的用法和相关概念：</p><ol><li><p><strong>泛型类 (Generic Class):</strong> 你可以创建一个类，其中包含一个或多个类型参数，用 <code>&lt;&gt;</code> 括起来，然后在类的定义中使用这些类型参数。这样的类被称为泛型类。</p><pre><code class="java">public class MyGenericClass&lt;T&gt; {    private T value;    public MyGenericClass(T value) {        this.value = value;    }    public T getValue() {        return value;    }}</code></pre></li><li><p><strong>泛型接口 (Generic Interface):</strong> 类似于泛型类，你可以创建泛型接口，使接口中的方法具有类型参数。</p><pre><code class="java">public interface MyGenericInterface&lt;T&gt; {    T getDefaultValue();}</code></pre></li><li><p><strong>泛型方法 (Generic Method):</strong> 你可以在普通类或非泛型类中定义泛型方法，使用 <code>&lt;&gt;</code> 括起来的类型参数，以便在方法级别处理不同类型的数据。</p><pre><code class="java">public &lt;T&gt; T getFirstElement(List&lt;T&gt; list) {    if (list.isEmpty()) {        return null;    }    return list.get(0);}</code></pre></li><li><p><strong>通配符 (Wildcard):</strong> <code>&lt;&gt;</code> 也用于通配符的定义，通常与泛型方法和泛型类一起使用，以表示某些不确定的类型。</p><ul><li><code>&lt;?&gt;</code> 表示无界通配符，用于表示可以接受任何类型的数据。</li><li><code>&lt;? extends T&gt;</code> 表示上界通配符，用于表示只能接受类型 <code>T</code> 或其子类型的数据。</li><li><code>&lt;? super T&gt;</code> 表示下界通配符，用于表示只能接受类型 <code>T</code> 或其父类型的数据。</li></ul><p>例如，<code>List&lt;?&gt;</code> 表示一个可以包含任何类型的元素的列表。</p></li><li><p><strong>类型参数的使用:</strong> 在使用泛型时，你可以将具体的类型传递给泛型类、泛型接口或泛型方法，以实例化它们。</p><pre><code class="java">MyGenericClass&lt;Integer&gt; intObject = new MyGenericClass&lt;&gt;(42);MyGenericInterface&lt;String&gt; stringObject = new MyGenericInterface&lt;String&gt;() {    @Override    public String getDefaultValue() {        return "Default";    }};</code></pre></li></ol><p>总之，尖括号 <code>&lt;&gt;</code> 在Java中用于定义和使用泛型，允许你编写更通用和类型安全的代码，以在不同类型的数据上执行操作。泛型提高了代码的重用性和可读性，同时提供了更强的类型检查。</p><h2 id="4-2-collection"><a href="#4-2-collection" class="headerlink" title="4.2 collection"></a>4.2 collection</h2><p><img src="C:\Users\7878\AppData\Roaming\Typora\typora-user-images\image-20230926142725652.png" alt="image-20230926142725652"></p><p>在Java中，<code>Collection</code> 是一个接口，它表示一组对象，通常用于存储和操作多个元素。<code>Collection</code> 接口是Java集合框架的一部分，它定义了一系列用于管理和操作元素集合的通用方法。</p><p><code>Collection</code> 接口是Java集合框架的根接口，它有许多子接口和实现类，包括<code>List</code>、<code>Set</code>、<code>Queue</code>等，每个子接口和实现类都提供了不同的数据结构和行为，以满足不同的需求。</p><p>下面是一些常用的<code>Collection</code>接口的子类：</p><ol><li><strong>List:</strong> <code>List</code> 接口表示有序的元素集合，允许重复元素。常见的实现类包括 <code>ArrayList</code>、<code>LinkedList</code> 和 <code>Vector</code>。你可以按索引访问元素，允许插入、删除和替换元素。</li><li><strong>Set:</strong> <code>Set</code> 接口表示无序的元素集合，不允许重复元素。常见的实现类包括 <code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code>。集合中的元素不按顺序存储，而且不允许重复。</li><li><strong>Queue:</strong> <code>Queue</code> 接口表示一个队列，通常按照先进先出（FIFO）的顺序处理元素。常见的实现类包括 <code>LinkedList</code> 和 <code>PriorityQueue</code>。它通常用于任务调度和处理等场景。</li></ol><p>使用<code>Collection</code>接口和其子接口的步骤如下：</p><ol><li><p><strong>导入必要的包：</strong> 你需要导入<code>java.util</code>包，因为集合框架的类和接口都在这个包中。</p></li><li><p><strong>创建集合对象：</strong> 选择适当的集合实现类，创建一个集合对象。</p><pre><code class="java">List&lt;String&gt; myList = new ArrayList&lt;&gt;(); // 创建一个ArrayList集合Set&lt;Integer&gt; mySet = new HashSet&lt;&gt;();   // 创建一个HashSet集合</code></pre></li><li><p><strong>操作集合：</strong> 使用集合对象的方法来添加、删除、查询和遍历元素。</p><pre><code class="java">// 向List中添加元素myList.add("Apple");myList.add("Banana");// 从Set中删除元素mySet.add(1);mySet.add(2);mySet.remove(1);// 遍历List中的元素for (String fruit : myList) {    System.out.println(fruit);}</code></pre></li><li><p><strong>其他操作：</strong> 根据需要，可以使用集合的其他方法来执行搜索、排序、过滤等操作。</p></li></ol><p><code>Collection</code> 接口和其子类提供了丰富的方法来处理不同类型的集合，根据具体需求选择合适的集合类型和方法来操作数据。它们是Java中常用的数据结构，用于处理和管理多个元素的集合。</p><h2 id="4-3-List"><a href="#4-3-List" class="headerlink" title="4.3 List"></a>4.3 List</h2><p>在Java中，<code>List</code> 是一个接口，表示有序的元素集合，允许重复元素。<code>List</code> 接口继承自 <code>Collection</code> 接口，并定义了一系列方法，用于操作和管理元素列表。你可以使用<code>List</code>来存储一组元素，并按照它们的插入顺序来访问、添加、删除和修改元素。</p><p>以下是使用 <code>List</code> 的基本步骤：</p><ol><li><p><strong>导入必要的包：</strong> 在使用 <code>List</code> 之前，首先需要导入 <code>java.util</code> 包，因为 <code>List</code> 接口和相关的类都在这个包中。</p><pre><code class="java">import java.util.List;import java.util.ArrayList; // 或其他List的实现类</code></pre></li><li><p><strong>创建 <code>List</code> 对象：</strong> 选择一个 <code>List</code> 接口的实现类（例如 <code>ArrayList</code>、<code>LinkedList</code> 等），创建一个 <code>List</code> 对象。</p><pre><code class="java">List&lt;String&gt; myList = new ArrayList&lt;&gt;(); // 创建一个ArrayList集合</code></pre></li><li><p><strong>操作 <code>List</code>：</strong> 使用 <code>List</code> 对象的方法来添加、删除、查询和遍历元素。</p><pre><code class="java">// 向List中添加元素myList.add("Apple");myList.add("Banana");myList.add("Cherry");// 获取List的大小int size = myList.size(); // 返回3，因为有3个元素// 获取指定位置的元素String fruit = myList.get(1); // 返回"Banana"// 修改元素myList.set(0, "Orange"); // 将第一个元素从"Apple"修改为"Orange"// 删除元素myList.remove(2); // 删除第三个元素"Cherry"// 遍历List中的元素for (String item : myList) {    System.out.println(item);}</code></pre></li><li><p><strong>其他操作：</strong> 根据需要，可以使用 <code>List</code> 的其他方法来执行搜索、排序、过滤等操作。例如，你可以使用 <code>contains</code> 方法检查元素是否存在于列表中，使用 <code>sort</code> 方法对列表进行排序等。</p><pre><code class="java">// 检查元素是否存在于List中boolean containsBanana = myList.contains("Banana"); // 返回true// 对List进行排序Collections.sort(myList); // 对列表元素按照自然顺序排序</code></pre></li><li><p><strong>注意事项：</strong></p><ul><li><code>List</code> 是有序的，允许元素重复。元素的顺序由插入顺序决定。</li><li><code>List</code> 的索引从0开始，你可以使用索引来访问元素。</li><li><code>List</code> 接口提供了丰富的方法来处理列表，包括添加、删除、修改、遍历等操作。</li></ul></li></ol><p>根据你的具体需求，选择适当的 <code>List</code> 实现类以及方法来操作元素列表。<code>ArrayList</code> 是一个常用的 <code>List</code> 实现类，通常在不需要频繁插入和删除元素的情况下使用，而 <code>LinkedList</code> 在需要频繁插入和删除元素的情况下可能更加高效。</p><p>对于一个使用迭代器（Iterator）来遍历集合的过程，初始时迭代器并不包含任何元素信息，而是通过 <code>.next()</code> 方法来获取元素的信息。这是因为迭代器是一种用于顺序访问集合中元素的对象，它的初始位置位于第一个元素之前（或集合的开头），只有调用 <code>.next()</code> 方法才会移动迭代器到下一个元素，同时返回当前元素的值。</p><p>以下是解释为什么需要使用 <code>.next()</code> 方法来获取元素信息的原因：</p><ol><li><strong>初始位置在第一个元素之前：</strong> 迭代器的初始位置通常是在集合的第一个元素之前（或集合的开头），这意味着在迭代器创建后，它并不指向任何元素。如果你直接尝试访问迭代器的当前元素，它将返回一个空值或抛出异常。</li><li><strong>控制迭代过程：</strong> 使用 <code>.next()</code> 方法可以精确控制迭代过程，让你决定何时移动到下一个元素。这允许你在处理完当前元素后决定是否继续迭代或停止迭代，从而更加灵活地操作集合中的元素。</li><li><strong>提供当前元素的值：</strong> <code>.next()</code> 方法返回迭代器当前位置的元素，并将迭代器移动到下一个位置。这样，你可以在每次调用 <code>.next()</code> 方法后获得当前元素的值，从而进行进一步的处理，比如打印、修改或使用这个元素。</li></ol><pre><code class="java">/** * 学生类 */public class Student {    public String id;    public String name;    public Student(String id, String name){        this.id = id;        this.name = name;    }    @Override    public String toString() {        return "Student{" +                "id='" + id + '\'' +                ", name='" + name + '\'' +                '}';    }}import java.util.*;public class ListTest {    //集合后面的&lt;&gt;代表泛型的意思    //泛型是规定了集合元素的类型    /**     * 用于存放学生的List     */    public List&lt;Student&gt; students;    public ListTest() {        this.students = new ArrayList&lt;Student&gt;();    }    /**     * 用于往students中添加学生     */    public void testAdd() {        // 创建一个学生对象，并通过调用add方法，添加到学生管理List中        Student st1 = new Student("1", "张三");        students.add(st1);        // 取出 List中的Student对象 索引为0 也就是第一个        Student temp = students.get(0);        System.out.println("添加了学生：" + temp.id + ":" + temp.name);        Student st2 = new Student("2", "李四");        //添加到list中，插入到索引为0的位置，也就是第一个        students.add(0, st2);        Student temp2 = students.get(0);        System.out.println("添加了学生：" + temp2.id + ":" + temp2.name);        // 对象数组的形式添加        Student[] student = {new Student("3", "王五"), new Student("4", "马六")};        // Arrays类包含用来操作数组（比如排序和搜索）的各种方法，asList() 方法用来返回一个受指定数组支持的固定大小的列表        students.addAll(Arrays.asList(student));        Student temp3 = students.get(2);        Student temp4 = students.get(3);        System.out.println("添加了学生：" + temp3.id + ":" + temp3.name);        System.out.println("添加了学生：" + temp4.id + ":" + temp4.name);        Student[] student2 = {new Student("5", "周七"), new Student("6", "赵八")};        students.addAll(2, Arrays.asList(student2));        Student temp5 = students.get(2);        Student temp6 = students.get(3);        System.out.println("添加了学生：" + temp5.id + ":" + temp5.name);        System.out.println("添加了学生：" + temp6.id + ":" + temp6.name);    }    /**     * 取得List中的元素的方法     */    public void testGet() {        int size = students.size();        for (int i = 0; i &lt; size; i++) {            Student st = students.get(i);            System.out.println("学生：" + st.id + ":" + st.name);        }    }    /**     * 通过迭代器来遍历     * 迭代器的工作是遍历并选择序列中的对象，Java 中 Iterator 只能单向移动     */    public void testIterator() {        // 通过集合的iterator方法，取得迭代器实例        Iterator&lt;Student&gt; it = students.iterator();        System.out.println("有如下学生（通过迭代器访问）：");        while (it.hasNext()) {            Student st = it.next();            System.out.println("学生" + st.id + ":" + st.name);        }    }    /**     * 通过for each 方法访问集合元素     *     */    public void testForEach() {        System.out.println("有如下学生（通过for each）：");        for (Student obj : students) {            Student st = obj;            System.out.println("学生：" + st.id + ":" + st.name);        }        //使用java8 Steam将学生排序后输出        students.stream()//创建Stream                //通过学生id排序                .sorted(Comparator.comparing(x -&gt; x.id))                //输出                .forEach(System.out::println);    }    /**     * 修改List中的元素     *     */    public void testModify() {        students.set(4, new Student("3", "吴酒"));    }    /**     * 删除List中的元素     *     */    public void testRemove() {        Student st = students.get(4);        System.out.println("我是学生：" + st.id + ":" + st.name + "，我即将被删除");        students.remove(st);        System.out.println("成功删除学生！");        testForEach();    }    public static void main(String[] args) {        ListTest lt = new ListTest();        lt.testAdd();        lt.testGet();        lt.testIterator();        lt.testModify();        lt.testForEach();        lt.testRemove();    }}</code></pre><blockquote><p><code>ArrayList</code> 和 <code>Vector</code> 都是 Java 集合框架中的实现了 <code>List</code> 接口的类，它们都用于存储有序的元素集合，允许元素重复，且按照插入顺序进行存储。然而，它们之间存在一些关键区别：</p><ol><li><strong>线程安全性：</strong><ul><li><code>ArrayList</code> 是非线程安全的：<code>ArrayList</code> 不是线程安全的，这意味着在多线程环境中使用 <code>ArrayList</code> 时，需要额外的同步措施，否则可能会导致不确定的行为或数据损坏。</li><li><code>Vector</code> 是线程安全的：<code>Vector</code> 在每个方法上都添加了同步关键字，因此可以在多线程环境中安全使用。然而，这也可能导致在高度并发的情况下性能略有下降。</li></ul></li><li><strong>性能：</strong><ul><li><code>ArrayList</code> 通常比 <code>Vector</code> 更快：由于 <code>Vector</code> 实现了线程同步，因此在单线程环境下，<code>ArrayList</code> 通常比 <code>Vector</code> 更快，因为它不需要额外的同步开销。</li><li><code>Vector</code> 在多线程环境中可能更适用：如果你需要在多线程环境中使用一个线程安全的动态数组，<code>Vector</code> 可能更适合，尽管性能方面可能会略有牺牲。</li></ul></li><li><strong>增长策略：</strong><ul><li><code>ArrayList</code> 的增长策略是增加一半的容量：当 <code>ArrayList</code> 的容量不足以容纳新元素时，它会自动增加其容量，通常是当前容量的一半。这可以减少内存浪费。</li><li><code>Vector</code> 的增长策略是增加一倍的容量：当 <code>Vector</code> 的容量不足时，它会将容量翻倍。这可能导致更多的内存浪费，尤其在容量较大时。</li></ul></li><li><strong>遗留特性：</strong><ul><li><code>Vector</code> 是一个古老的类：<code>Vector</code> 是在Java早期引入的，因此它具有一些遗留的特性，如不支持泛型。相比之下，<code>ArrayList</code> 是在Java 1.2引入的，并支持泛型。</li></ul></li></ol><p>总结：一般情况下，如果你在单线程环境中使用动态数组，<code>ArrayList</code> 是一个更好的选择，因为它具有较好的性能。如果你需要在线程安全的多线程环境中使用动态数组，可以考虑使用 <code>Vector</code>。然而，现代 Java 更倾向于使用 <code>ArrayList</code>，并使用 <code>Collections.synchronizedList</code> 方法来将其转换为线程安全的形式，以获得更好的性能。</p></blockquote><h2 id="4-4-Map"><a href="#4-4-Map" class="headerlink" title="4.4 Map"></a>4.4 Map</h2><p>在 Java 中，<code>Map</code> 是一种非常有用的数据结构，用于存储键值对（key-value pairs）。每个键都唯一，而与每个键关联的值可以重复。<code>Map</code> 提供了一种快速查找和检索值的方式，通常用于表示和管理数据的关联关系。</p><p>以下是 Java 中使用 <code>Map</code> 的基本操作和示例：</p><ol><li>创建一个 Map 对象：</li></ol><p>你可以使用 <code>HashMap</code>、<code>TreeMap</code>、<code>LinkedHashMap</code> 等 <code>Map</code> 的实现类来创建一个 <code>Map</code> 对象。例如：</p><pre><code class="java">import java.util.*;Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); // 创建一个 HashMap，键的类型是 String，值的类型是 Integer</code></pre><ol start="2"><li>添加键值对：</li></ol><p>使用 <code>put</code> 方法将键值对添加到 <code>Map</code> 中：</p><pre><code class="java">map.put("Alice", 25);map.put("Bob", 30);map.put("Charlie", 28);</code></pre><ol start="3"><li>获取值：</li></ol><p>使用 <code>get</code> 方法根据键获取对应的值：</p><pre><code class="java">int age = map.get("Alice"); // 获取键为 "Alice" 的值，age 等于 25</code></pre><ol start="4"><li>检查键是否存在：</li></ol><p>使用 <code>containsKey</code> 方法来检查某个键是否存在于 <code>Map</code> 中：</p><pre><code class="java">boolean containsAlice = map.containsKey("Alice"); // containsAlice 等于 trueboolean containsDavid = map.containsKey("David"); // containsDavid 等于 false</code></pre><ol start="5"><li>遍历 Map：</li></ol><p>你可以使用不同的方式来遍历 <code>Map</code>，例如使用 <code>keySet()</code>、<code>values()</code> 或 <code>entrySet()</code> 方法。以下是使用 <code>entrySet()</code> 的示例：</p><pre><code class="java">for (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) {    String key = entry.getKey();    int value = entry.getValue();    System.out.println(key + " -&gt; " + value);}</code></pre><ol start="6"><li>删除键值对：</li></ol><p>使用 <code>remove</code> 方法来删除指定键的键值对：</p><pre><code class="java">map.remove("Bob"); // 删除键为 "Bob" 的键值对</code></pre><ol start="7"><li>获取 Map 的大小：</li></ol><p>使用 <code>size</code> 方法获取 <code>Map</code> 中键值对的数量：</p><pre><code class="java">int size = map.size(); // 获取 Map 中键值对的数量</code></pre><p>这些是 <code>Map</code> 基本操作的示例。<code>Map</code> 提供了强大的功能，可以用于解决各种数据关联问题，如字典、缓存、计数器等。你可以根据具体的需求选择合适的 <code>Map</code> 实现类以及操作方法。</p><pre><code class="java">public class Course {    public String id;    public String name;    public Course(String id, String name){        this.id = id;        this.name = name;    }}</code></pre><pre><code class="java">// MapTest.javaimport java.util.HashMap;import java.util.Map;import java.util.Map.Entry;import java.util.Scanner;import java.util.Set;public class MapTest {    /**     * 用来承装课程类型对象     */    public Map&lt;String, Course&gt; courses;    /**     * 在构造器中初始化 courses 属性     * @param args     */    public MapTest() {        this.courses = new HashMap&lt;String, Course&gt;();    }    /**     * 测试添加：输入课程 ID，判断是否被占用     * 若未被占用，输入课程名称，创建新课程对象     * 并且添加到 courses 中     * @param args     */    public void testPut() {        //创建一个 Scanner 对象，用来获取输入的课程 ID 和名称        Scanner console = new Scanner(System.in);        for(int i = 0; i &lt; 3; i++) {            System.out.println("请输入课程 ID：");            String ID = console.next();            //判断该 ID 是否被占用            Course cr = courses.get(ID);            if(cr == null){                //提示输入课程名称                System.out.println("请输入课程名称：");                String name = console.next();                //创建新的课程对象                Course newCourse = new Course(ID,name);                //通过调用 courses 的 put 方法，添加 ID-课程映射                courses.put(ID, newCourse);                System.out.println("成功添加课程：" + courses.get(ID).name);            }            else {                System.out.println("该课程 ID 已被占用");                continue;            }        }    }    /**     * 测试 Map 的 keySet 方法     * @param args     */    public void testKeySet() {        //通过 keySet 方法，返回 Map 中的所有键的 Set 集合        Set&lt;String&gt; keySet = courses.keySet();        //遍历 keySet，取得每一个键，在调用 get 方法取得每个键对应的 value        for(String crID: keySet) {            Course cr = courses.get(crID);            if(cr != null){                System.out.println("课程：" + cr.name);            }        }    }    /**     * 测试删除 Map 中的映射     * @param args     */    public void testRemove() {        //获取从键盘输入的待删除课程 ID 字符串        Scanner console = new Scanner(System.in);        while(true){            //提示输出待删除的课程 ID            System.out.println("请输入要删除的课程 ID！");            String ID = console.next();            //判断该 ID 是否对应的课程对象            Course cr = courses.get(ID);            if(cr == null) {                //提示输入的 ID 并不存在                System.out.println("该 ID 不存在！");                continue;            }            courses.remove(ID);            System.out.println("成功删除课程" + cr.name);            break;        }    }    /**     * 通过 entrySet 方法来遍历 Map     * @param args     */    public void testEntrySet() {        //通过 entrySet 方法，返回 Map 中的所有键值对        Set&lt;Entry&lt;String,Course&gt;&gt; entrySet = courses.entrySet();        for(Entry&lt;String,Course&gt; entry: entrySet) {            System.out.println("取得键：" + entry.getKey());            System.out.println("对应的值为：" + entry.getValue().name);        }    }    /**     * 利用 put 方法修改Map 中的已有映射     * @param args     */    public void testModify(){        //提示输入要修改的课程 ID        System.out.println("请输入要修改的课程 ID：");        //创建一个 Scanner 对象，去获取从键盘上输入的课程 ID 字符串        Scanner console = new Scanner(System.in);        while(true) {            //取得从键盘输入的课程 ID            String crID = console.next();            //从 courses 中查找该课程 ID 对应的对象            Course course = courses.get(crID);            if(course == null) {                System.out.println("该 ID 不存在！请重新输入！");                continue;            }            //提示当前对应的课程对象的名称            System.out.println("当前该课程 ID，所对应的课程为：" + course.name);            //提示输入新的课程名称，来修改已有的映射            System.out.println("请输入新的课程名称：");            String name = console.next();            Course newCourse = new Course(crID,name);            courses.put(crID, newCourse);            System.out.println("修改成功！");            break;        }    }    public static void main(String[] args) {        MapTest mt = new MapTest();        mt.testPut();        mt.testKeySet();        mt.testRemove();        mt.testModify();        mt.testEntrySet();    }}</code></pre><h2 id="4-5-Collection"><a href="#4-5-Collection" class="headerlink" title="4.5 Collection"></a>4.5 Collection</h2><p><code>java.util.Collections</code> 类提供了许多实用的静态方法，用于对集合进行操作。以下是一些常见的用法示例：</p><ol><li><p><strong>排序列表</strong>：</p><pre><code class="java">List&lt;Integer&gt; numbers = new ArrayList&lt;&gt;();numbers.add(3);numbers.add(1);numbers.add(2);Collections.sort(numbers); // 对列表进行排序</code></pre></li><li><p><strong>反转列表</strong>：</p><pre><code class="java">List&lt;String&gt; names = new ArrayList&lt;&gt;();names.add("Alice");names.add("Bob");names.add("Charlie");Collections.reverse(names); // 反转列表中的元素顺序</code></pre></li><li><p><strong>查找元素</strong>：</p><pre><code class="java">List&lt;Integer&gt; numbers = new ArrayList&lt;&gt;();numbers.add(1);numbers.add(2);numbers.add(3);int index = Collections.binarySearch(numbers, 2); // 在有序列表中执行二分查找</code></pre></li><li><p><strong>随机打乱列表</strong>：</p><pre><code class="java">List&lt;String&gt; cards = new ArrayList&lt;&gt;();cards.add("Ace");cards.add("King");cards.add("Queen");Collections.shuffle(cards); // 随机打乱列表中的元素顺序</code></pre></li><li><p><strong>复制列表</strong>：</p><pre><code class="java">List&lt;String&gt; source = new ArrayList&lt;&gt;();source.add("A");source.add("B");List&lt;String&gt; destination = new ArrayList&lt;&gt;();Collections.copy(destination, source); // 将一个列表的元素复制到另一个列表中</code></pre></li><li><p><strong>填充列表</strong>：</p><pre><code class="java">List&lt;Integer&gt; numbers = new ArrayList&lt;&gt;(Collections.nCopies(5, 0)); // 使用指定元素填充列表</code></pre></li><li><p><strong>创建不可修改的集合</strong>：</p><pre><code class="java">List&lt;String&gt; immutableList = Collections.unmodifiableList(originalList); // 创建不可修改的列表</code></pre></li></ol><h1 id="5-异常"><a href="#5-异常" class="headerlink" title="5 异常"></a>5 异常</h1><h2 id="5-1-分类"><a href="#5-1-分类" class="headerlink" title="5.1 分类"></a>5.1 分类</h2><p>在Java中，异常分为三大类：</p><ol><li><p><strong>受检异常（Checked Exceptions）</strong>：</p><ul><li>受检异常是指在编译时必须处理的异常。这些异常通常是由外部因素引起的，比如文件不存在、网络连接问题等。如果一个方法可能会抛出受检异常，要么在方法内部使用<code>try-catch</code>块捕获异常，要么在方法签名中使用<code>throws</code>关键字声明该异常，通知调用者处理异常。</li></ul><pre><code class="java">try {    // 可能抛出受检异常的代码} catch (IOException e) {    // 处理受检异常}</code></pre></li><li><p><strong>未受检异常（Unchecked Exceptions，也称为运行时异常）</strong>：<code>RuntimeException</code></p><ul><li>未受检异常是指在运行时可能会发生的异常，通常由程序错误引起，比如空指针异常（<code>NullPointerException</code>）、数组越界异常（<code>ArrayIndexOutOfBoundsException</code>）等。这些异常是<code>RuntimeException</code>类及其子类的实例。在编程中，通常不需要显式地捕获这些异常，但最好是在代码中预防它们的发生。</li></ul><pre><code class="java">// 未受检异常的示例：空指针异常String str = null;int length = str.length(); // 这里会抛出空指针异常</code></pre></li><li><p><strong>错误（Errors）</strong>：</p><ul><li>错误是指虚拟机无法处理的严重问题，通常由系统故障引起，比如内存溢出错误（<code>OutOfMemoryError</code>）或虚拟机崩溃。与异常不同，错误通常是不可恢复的。在编写应用程序时，我们不需要关心错误，因为它们通常是由虚拟机或底层系统引起的问题。</li></ul><pre><code class="java">// 错误的示例：内存溢出错误public void recursiveMethod() {    recursiveMethod();}</code></pre></li></ol><h2 id="5-2-处理"><a href="#5-2-处理" class="headerlink" title="5.2 处理"></a>5.2 处理</h2><p>在Java中，你可以使用<code>throws</code>关键字来声明和抛出异常。异常的声明和抛出通常在方法的签名部分进行。以下是如何声明和抛出异常的一般步骤：</p><ol><li><p><strong>在方法签名中声明异常</strong>：</p><ul><li>在方法的参数列表之后，使用 <code>throws</code> 关键字声明可能会被抛出的异常。可以声明多个异常，用逗号分隔。</li></ul><pre><code class="java">public void someMethod() throws SomeException, AnotherException {    // 方法实现}</code></pre></li><li><p><strong>抛出异常</strong>：</p><ul><li>在方法内部，如果满足某个条件导致异常情况，可以使用 <code>throw</code> 关键字抛出异常对象。</li></ul><pre><code class="java">public void someMethod() throws SomeException {    if (/* 满足某个条件 */) {        throw new SomeException("发生了某种异常");    }    // 方法继续执行}</code></pre></li><li><p><strong>捕获异常</strong>：</p><ul><li>当调用抛出异常的方法时，你必须使用 <code>try-catch</code> 块捕获异常，或者将异常继续向上抛出（再次声明）。</li></ul><pre><code class="java">try {    someMethod();} catch (SomeException e) {    // 处理 SomeException 异常} catch (AnotherException e) {    // 处理 AnotherException 异常}</code></pre></li><li><p><strong>继续抛出异常</strong>：</p><ul><li>如果你不打算在当前方法中处理异常，而是希望将异常传递给调用者，可以在方法中继续使用 <code>throws</code> 关键字声明异常。</li></ul><pre><code class="java">public void someMethod() throws SomeException {    if (/* 满足某个条件 */) {        throw new SomeException("发生了某种异常");    }    // 方法继续执行}</code></pre></li></ol><p>通过这种方式，你可以在程序中声明和抛出异常，并根据需要进行适当的异常处理或传递。</p><h2 id="5-3-多异常处理"><a href="#5-3-多异常处理" class="headerlink" title="5.3 多异常处理"></a>5.3 多异常处理</h2><p>在Java中，你可以使用多个 <code>catch</code> 块来捕获多种异常。每个 <code>catch</code> 块用于捕获特定类型的异常，并提供相应的处理逻辑。下面是捕获多个异常的基本语法：</p><pre><code class="java">try {    // 一些可能抛出异常的代码} catch (ExceptionType1 e1) {    // 处理 ExceptionType1 类型的异常} catch (ExceptionType2 e2) {    // 处理 ExceptionType2 类型的异常} catch (ExceptionType3 e3) {    // 处理 ExceptionType3 类型的异常} // and so on for more catch blocks</code></pre><ul><li>在 <code>try</code> 块中，你编写可能抛出异常的代码。</li><li>对于每种可能抛出的异常类型，你可以使用一个 <code>catch</code> 块来捕获和处理该类型的异常。</li><li>按照需要，你可以定义多个 <code>catch</code> 块，每个 <code>catch</code> 块捕获不同类型的异常，并提供相应的处理逻辑。</li></ul><p>如果某个异常类型是另一个异常类型的子类，它应该在其父类之后捕获，因为Java编译器会按照从子类到父类的顺序进行匹配。</p><h2 id="5-4-自定义异常"><a href="#5-4-自定义异常" class="headerlink" title="5.4 自定义异常"></a>5.4 自定义异常</h2><p>在Java中，你可以通过创建一个继承自<code>Exception</code>或<code>RuntimeException</code>的类来自定义异常。这个自定义异常类应该提供自定义异常的特定行为和信息。</p><p>以下是创建自定义异常的基本步骤：</p><p>创建自定义异常类</p><ul><li>创建一个继承自 <code>Exception</code>（受检异常）或 <code>RuntimeException</code>（未受检异常）的类。</li></ul><pre><code class="java">// 自定义受检异常类public class CustomCheckedException extends Exception {    public CustomCheckedException(String message) {        super(message);    }}// 自定义未受检异常类public class CustomUncheckedException extends RuntimeException {    public CustomUncheckedException(String message) {        super(message);    }}</code></pre><p><strong>添加构造函数</strong>：</p><ul><li>在自定义异常类中，添加构造函数以接受异常消息并调用父类的构造函数。</li></ul><p><strong>使用自定义异常</strong>：</p><ul><li>在需要抛出自定义异常的代码中，创建自定义异常的对象并抛出。</li></ul><pre><code class="java">public class Example {    public void someMethod() throws CustomCheckedException {        // 某些情况下抛出自定义受检异常        throw new CustomCheckedException("这是自定义受检异常");    }    public void anotherMethod() {        // 某些情况下抛出自定义未受检异常        throw new CustomUncheckedException("这是自定义未受检异常");    }}</code></pre><p>捕获自定义异常</p><ul><li>在调用抛出自定义异常的方法时，你可以使用 <code>try-catch</code> 块捕获自定义异常并处理它。</li></ul><pre><code class="java">try {    Example example = new Example();    example.someMethod();} catch (CustomCheckedException e) {    // 处理自定义受检异常    e.printStackTrace();}</code></pre><h2 id="5-5-异常堆栈"><a href="#5-5-异常堆栈" class="headerlink" title="5.5 异常堆栈"></a>5.5 异常堆栈</h2><p>异常堆栈（也称为堆栈跟踪或调用堆栈）是在程序执行过程中发生异常时记录的一组调用方法的信息。它提供了一个关于异常发生位置和异常传播路径的详细视图。异常堆栈通常包括以下信息：</p><ol><li>方法调用顺序：异常堆栈列出了程序中从发生异常的地方开始到异常被捕获或程序终止的方法调用序列。这些方法调用以栈的形式排列，最上面的是最近调用的方法，最下面的是最初的调用。</li><li>类名和方法名：堆栈中的每个元素都包括了引发异常的方法的类名和方法名。这有助于确定异常发生的确切位置。</li><li>行号信息：通常，异常堆栈还包括了引发异常的方法中出现异常的代码行号。这使得程序员能够准确定位问题代码的位置。</li></ol><p>异常堆栈对于调试和诊断问题非常有用。当程序抛出异常时，异常堆栈可以帮助开发人员追踪异常的来源，找出问题的根本原因，并更轻松地修复代码中的错误。堆栈跟踪也可以用于记录异常，以便后续的故障排除或错误报告。</p><pre><code class="java">public class ExceptionStackTrace {    private static void method1() {        method2();    }    private static void method2() {        throw new NullPointerException();    }    public static void main(String[] args) {        try {            method1();        } catch (Exception e) {            //打印堆栈轨迹            e.printStackTrace();        }    }}</code></pre><pre><code class="java">java.lang.NullPointerException    at ExceptionStackTrace.method2(ExceptionStackTrace.java:7)    at ExceptionStackTrace.method1(ExceptionStackTrace.java:3)    at ExceptionStackTrace.main(ExceptionStackTrace.java:11)</code></pre><h1 id="6-Lambda"><a href="#6-Lambda" class="headerlink" title="6 Lambda"></a>6 Lambda</h1><h2 id="6-1-使用"><a href="#6-1-使用" class="headerlink" title="6.1 使用"></a>6.1 使用</h2><p>Lambda表达式是Java 8引入的一种函数式编程特性，用于简化匿名内部类的编写以及在函数式接口中定义行为。要实现Lambda表达式，你需要按照以下基本语法规则进行操作：</p><ol><li><strong>确定函数式接口</strong>：首先，你需要有一个函数式接口，它只包含一个抽象方法。函数式接口是一个具有单个抽象方法的接口。</li><li><strong>定义Lambda表达式</strong>：Lambda表达式的一般形式是 <code>(参数) -&gt; 表达式</code>。参数是方法的参数，表达式是方法的实现。可以使用箭头符号 <code>-&gt;</code> 分隔参数和表达式。</li><li><strong>调用Lambda表达式</strong>：将Lambda表达式分配给一个接口类型的变量，然后可以使用该变量来调用Lambda表达式。</li></ol><p>下面是一个简单示例，展示如何创建和使用Lambda表达式：</p><pre><code class="java">// 步骤 1：确定函数式接口@FunctionalInterfaceinterface MyFunction {    int apply(int a, int b);}public class LambdaExample {    public static void main(String[] args) {        // 步骤 2：定义Lambda表达式        MyFunction addition = (a, b) -&gt; a + b;        MyFunction subtraction = (a, b) -&gt; a - b;        // 步骤 3：调用Lambda表达式        int result1 = addition.apply(5, 3); // 调用Lambda表达式执行加法        int result2 = subtraction.apply(5, 3); // 调用Lambda表达式执行减法        System.out.println("Addition result: " + result1);        System.out.println("Subtraction result: " + result2);    }}</code></pre><p>在这个示例中，我们首先定义了一个函数式接口 <code>MyFunction</code>，它具有一个抽象方法 <code>apply</code>。然后，我们创建了两个Lambda表达式 <code>addition</code> 和 <code>subtraction</code>，并使用它们执行加法和减法操作。</p><p>Lambda表达式的强大之处在于可以将它们传递给方法、将它们作为参数传递给其他方法，并以一种简洁的方式表达行为。这在处理集合、多线程等场景中非常有用。</p><h2 id="6-2-作用域"><a href="#6-2-作用域" class="headerlink" title="6.2 作用域"></a>6.2 作用域</h2><p>Lambda表达式的作用域是指Lambda表达式可以访问哪些变量以及它们的生命周期。Lambda表达式的作用域是根据以下规则确定的：</p><ol><li><strong>局部变量</strong>：Lambda表达式可以访问外部方法中的局部变量，但这些局部变量必须满足以下条件：<ul><li>局部变量必须是隐式或显式地声明为 <code>final</code> 或 <code>effectively final</code>。这意味着一旦赋值后，不能再修改这些变量的值。从Java 8开始，如果变量在赋值后没有被再次赋值，它被认为是”effectively final”。</li><li>如果Lambda表达式在一个线程中使用了某个局部变量，那么这个变量必须是线程安全的。</li></ul></li><li><strong>成员变量和静态变量</strong>：Lambda表达式可以自由访问包含它的类的成员变量和静态变量，就像普通的类方法一样。</li><li><strong>方法参数</strong>：Lambda表达式可以访问外部方法的参数，但参数也必须是 <code>final</code> 或 <code>effectively final</code>。</li></ol><p>下面是一个示例，演示了Lambda表达式的作用域：</p><pre><code class="java">public class LambdaScopeExample {    private int instanceVar = 10;    private static int staticVar = 20;    public void lambdaInMethod() {        int localVar = 30; // 局部变量        // Lambda 表达式可以访问局部变量 localVar 和 instanceVar，以及静态变量 staticVar        MyFunctionalInterface myLambda = () -&gt; {            System.out.println("instanceVar: " + instanceVar);            System.out.println("staticVar: " + staticVar);            System.out.println("localVar: " + localVar);        };        myLambda.doSomething();    }    public static void main(String[] args) {        LambdaScopeExample example = new LambdaScopeExample();        example.lambdaInMethod();    }    @FunctionalInterface    interface MyFunctionalInterface {        void doSomething();    }}</code></pre><p>在这个示例中，Lambda表达式 <code>myLambda</code> 可以访问 <code>instanceVar</code>（成员变量）、<code>staticVar</code>（静态变量），以及 <code>localVar</code>（局部变量），因为它们都符合Lambda表达式的作用域规则。如果你尝试在Lambda表达式内部修改 <code>localVar</code> 的值，将会导致编译错误，因为它不是<code>final</code>或<code>effectively final</code>的。</p><blockquote><p>相对于普通的类方法，Lambda表达式的主要区别在于它们可以访问外部作用域的变量，这是通过闭包实现的。以下是Lambda表达式与普通类方法之间的主要区别：</p><ol><li><strong>变量访问</strong>：<ul><li><strong>Lambda表达式</strong>：Lambda表达式可以访问包含它们的方法的局部变量（必须是<code>final</code>或<code>effectively final</code>），成员变量，以及静态变量。</li><li><strong>普通类方法</strong>：普通类方法只能访问它们所属类的成员变量和静态变量，不能直接访问方法中的局部变量。</li></ul></li><li><strong>this关键字</strong>：<ul><li><strong>Lambda表达式</strong>：Lambda表达式中的<code>this</code>关键字指向它所在的外部类。</li><li><strong>普通类方法</strong>：普通类方法中的<code>this</code>关键字指向该类的实例。</li></ul></li><li><strong>对接口的依赖</strong>：<ul><li><strong>Lambda表达式</strong>：Lambda表达式依赖于函数式接口，即接口中只有一个抽象方法。它们可以实现该接口并提供方法实现。</li><li><strong>普通类方法</strong>：普通类方法可以属于任何类，无需依赖于特定的接口。</li></ul></li><li><strong>简洁性</strong>：<ul><li><strong>Lambda表达式</strong>：Lambda表达式通常比传统的匿名内部类更为简洁，可以在更少的代码行中表达相同的逻辑。</li></ul></li><li><strong>使用场景</strong>：<ul><li><strong>Lambda表达式</strong>：适用于简单的功能接口实现，尤其是在集合处理、线程处理等函数式编程场景中。</li><li><strong>普通类方法</strong>：适用于一般的方法实现，可能需要较多的代码和复杂的逻辑。</li></ul></li></ol><p>总的来说，Lambda表达式提供了一种更简洁、更函数式的方法来实现特定的功能接口，特别适用于对集合进行操作或实现简单功能的情况。它们使得代码更为紧凑，更容易理解和维护。然而，在某些情况下，传统的类方法可能更适合复杂的业务逻辑或需要多个方法的情况。</p></blockquote><h2 id="6-3-方法引用"><a href="#6-3-方法引用" class="headerlink" title="6.3 方法引用"></a>6.3 方法引用</h2><p>在Java中，方法引用是一种简化Lambda表达式的语法，用于调用已经存在的方法。它可以替代Lambda表达式，使代码更加简洁易读。</p><p>方法引用通常用于函数式接口的实例化，函数式接口是只包含一个抽象方法的接口。方法引用可以用来引用以下类型的方法：</p><ol><li>静态方法引用：引用静态方法。</li><li>对象方法引用：引用特定对象的实例方法。</li><li>类型方法引用：引用特定类型的任意对象的实例方法。</li></ol><p>以下是一些方法引用的示例：</p><ul><li><p>静态方法引用：</p><pre><code class="java">// 使用方法引用调用静态方法Function&lt;Integer, Integer&gt; square = Math::square;</code></pre></li><li><p>对象方法引用：</p><pre><code class="java">// 使用方法引用调用实例方法List&lt;String&gt; names = Arrays.asList("Alice", "Bob", "Charlie");names.forEach(System.out::println);</code></pre></li><li><p>类型方法引用：</p><pre><code class="java">// 使用方法引用调用类型方法Comparator&lt;String&gt; stringComparator = String::compareToIgnoreCase;</code></pre></li></ul><p>方法引用通过<code>::</code>符号后跟方法名来引用方法，而不需要提供方法的具体实现，编译器会根据上下文自动推断。</p><h2 id="6-4-函数式编程"><a href="#6-4-函数式编程" class="headerlink" title="6.4 函数式编程"></a>6.4 函数式编程</h2><p><code>java.util.Function</code> 是一个函数式接口，它接受一个输入参数并返回一个结果。它定义了一个名为 <code>apply</code> 的抽象方法，用于将输入转换为输出。</p><p>该接口通常用于将操作作为参数传递给其他方法，例如在 Stream API 中进行数据处理，或者在函数式编程中进行函数组合。</p><p>以下是一个简单的示例，演示了如何使用 <code>java.util.Function</code> 接口：</p><pre><code class="java">import java.util.function.Function;public class FunctionExample {    public static void main(String[] args) {        // 创建一个 Function，将输入值乘以2并返回        Function&lt;Integer, Integer&gt; multiplyBy2 = x -&gt; x * 2;        // 使用 apply 方法应用函数        int result = multiplyBy2.apply(5); // 结果为 10        System.out.println(result);    }}</code></pre><p>在这个例子中，我们首先创建了一个 <code>Function</code> 对象 <code>multiplyBy2</code>，它将输入值乘以2。然后，我们调用 <code>apply</code> 方法将输入值 <code>5</code> 应用到函数上，得到了结果 <code>10</code>。</p><ol><li><strong>Consumer (消费者)：</strong><ul><li><strong>描述：</strong> 表示接受单个输入参数并且不返回结果的操作。</li><li><strong>接口方法：</strong> <code>void accept(T t)</code></li></ul></li><li><strong>Function (函数)：</strong><ul><li><strong>描述：</strong> 表示接受一个输入参数并产生一个结果的函数。</li><li><strong>接口方法：</strong> <code>R apply(T t)</code></li></ul></li><li><strong>Supplier (供应商)：</strong><ul><li><strong>描述：</strong> 表示一个供应商，不接受任何参数，但返回一个结果。</li><li><strong>接口方法：</strong> <code>T get()</code></li></ul></li><li><strong>Predicate (断言)：</strong><ul><li><strong>描述：</strong> 表示一个断言（布尔值函数），接受一个参数并返回一个布尔值结果。</li><li><strong>接口方法：</strong> <code>boolean test(T t)</code></li></ul></li><li><strong>UnaryOperator (一元操作符)：</strong><ul><li><strong>描述：</strong> 表示一个一元操作符，接受一个参数并返回与该参数相同类型的结果。</li><li><strong>接口方法：</strong> <code>T apply(T t)</code></li></ul></li><li><strong>BinaryOperator (二元操作符)：</strong><ul><li><strong>描述：</strong> 表示一个二元操作符，接受两个参数并返回与参数相同类型的结果。</li><li><strong>接口方法：</strong> <code>T apply(T t1, T t2)</code></li></ul></li></ol><pre><code class="java">import java.util.Arrays;import java.util.List;import java.util.function.Predicate;public class FunctionTest {   public static void main(String args[]){      // 创建一个包含整数的列表      List&lt;Integer&gt; list = Arrays.asList(0, 1, 2, 3, 4, 5, 6, 7, 8, 9);      System.out.println("All of the numbers:");      // 使用 Predicate 过滤并打印所有数字      eval(list, n-&gt;true);      System.out.println("Even numbers:");      // 使用 Predicate 过滤并打印偶数      eval(list, n-&gt; n%2 == 0 );      System.out.println("Numbers that are greater than 5:");      // 使用 Predicate 过滤并打印大于5的数字      eval(list, n -&gt; n &gt; 5 );   }   // 通用的方法，接受列表和 Predicate，用于过滤和打印符合条件的元素   public static void eval(List&lt;Integer&gt; list, Predicate&lt;Integer&gt; predicate) {      for(Integer n: list) {         // 使用 Predicate 测试元素是否满足条件，然后打印符合条件的元素         if(predicate.test(n)) {            System.out.println(n);         }      }   }}</code></pre><h1 id="7-Stream"><a href="#7-Stream" class="headerlink" title="7 Stream"></a>7 Stream</h1><h2 id="7-1-创建流"><a href="#7-1-创建流" class="headerlink" title="7.1 创建流"></a>7.1 创建流</h2><p>要创建一个流（Stream）对象，你可以使用以下方式：</p><ol><li>从集合创建流：你可以从集合（如List、Set、Map等）创建一个流。Java中的集合提供了<code>stream()</code>方法来生成流。</li></ol><pre><code class="java">List&lt;String&gt; myList = Arrays.asList("apple", "banana", "cherry");Stream&lt;String&gt; stream = myList.stream();</code></pre><ol><li>从数组创建流：你也可以从数组创建流，使用<code>Arrays.stream()</code>方法。</li></ol><pre><code class="java">int[] numbers = {1, 2, 3, 4, 5};IntStream stream = Arrays.stream(numbers);</code></pre><ol><li>使用Stream.of()创建流：你可以使用<code>Stream.of()</code>方法创建一个包含指定元素的流。</li></ol><pre><code class="java">Stream&lt;String&gt; stream = Stream.of("apple", "banana", "cherry");</code></pre><ol><li>使用Stream.generate()创建无限流：如果需要创建一个无限流，可以使用<code>Stream.generate()</code>方法，并传入一个生成元素的Supplier。</li></ol><pre><code class="java">Stream&lt;Integer&gt; infiniteStream = Stream.generate(() -&gt; 1);</code></pre><ol><li>使用Stream.iterate()创建无限流：类似于<code>Stream.generate()</code>，你也可以使用<code>Stream.iterate()</code>创建一个无限流，但需要提供一个初始值和一个UnaryOperator来生成后续的值。</li></ol><pre><code class="java">Stream&lt;Integer&gt; infiniteStream = Stream.iterate(1, n -&gt; n + 1);</code></pre><h2 id="7-2-操作流"><a href="#7-2-操作流" class="headerlink" title="7.2 操作流"></a>7.2 操作流</h2><p>当使用Java中的<code>Stream</code>时，你可以执行各种操作，包括中间操作和终端操作。以下是一些<code>Stream</code>的常见用法，以及相应的示例：</p><p><strong>1. 过滤（Filter）：</strong> 使用<code>filter</code>中间操作来筛选出满足条件的元素。</p><pre><code class="java">List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);List&lt;Integer&gt; evenNumbers = numbers.stream()    .filter(n -&gt; n % 2 == 0)    .collect(Collectors.toList());// evenNumbers 现在包含 [2, 4, 6, 8, 10]</code></pre><p><strong>2. 映射（Map）：</strong> 使用<code>map</code>中间操作将元素映射成新的值。</p><pre><code class="java">List&lt;String&gt; names = Arrays.asList("Alice", "Bob", "Charlie");List&lt;Integer&gt; nameLengths = names.stream()    .map(String::length)    .collect(Collectors.toList());// nameLengths 现在包含 [5, 3, 7]</code></pre><p><strong>3. 排序（Sort）：</strong> 使用<code>sorted</code>中间操作对元素进行排序。</p><pre><code class="java">List&lt;Integer&gt; numbers = Arrays.asList(5, 2, 8, 1, 9);List&lt;Integer&gt; sortedNumbers = numbers.stream()    .sorted()    .collect(Collectors.toList());// sortedNumbers 现在包含 [1, 2, 5, 8, 9]</code></pre><p><strong>4. 聚合（Reduce）：</strong> 使用<code>reduce</code>终端操作对元素进行聚合操作，如求和、求最大值、求最小值等。</p><pre><code class="java">List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5);int sum = numbers.stream()    .reduce(0, (a, b) -&gt; a + b);// sum 现在等于 15</code></pre><p><strong>5. 收集（Collect）：</strong> 使用<code>collect</code>终端操作将流中的元素收集到一个集合中。</p><pre><code class="java">List&lt;String&gt; fruits = Arrays.asList("apple", "banana", "cherry");Set&lt;String&gt; fruitSet = fruits.stream()    .collect(Collectors.toSet());// fruitSet 现在包含 {"apple", "banana", "cherry"}</code></pre><p><strong>6. 遍历（ForEach）：</strong> 使用<code>forEach</code>终端操作对流中的每个元素执行指定操作。</p><pre><code class="java">List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5);numbers.stream()    .forEach(System.out::println);// 将每个数字打印到控制台</code></pre><p>在Java中，<code>peek()</code> 方法是Java流（Stream）类提供的一个中间操作方法之一。它允许你在流的每个元素被处理时执行一个操作，但不会改变流的内容，而是返回原始流。<code>peek()</code> 方法通常用于调试和观察流的操作，以便查看流的中间状态，而不会影响流的最终结果。</p><p>该方法的签名如下：</p><pre><code class="java">Stream&lt;T&gt; peek(Consumer&lt;? super T&gt; action)</code></pre><p>其中，<code>action</code> 是一个接受类型为 <code>T</code> 的元素的消费者函数，你可以在这个函数中执行任何你想要的操作。</p><p>例如，假设你有一个整数流，你可以使用 <code>peek()</code> 方法来打印每个元素，并查看它们的值，而不改变流的内容：</p><pre><code class="java">List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5);numbers.stream()       .peek(num -&gt; System.out.println("Processing: " + num))       .map(num -&gt; num * 2)       .forEach(System.out::println);</code></pre><p>在上面的示例中，<code>peek()</code> 方法用于输出每个元素的处理状态，但不会更改流的元素。然后，<code>map()</code> 方法将每个元素乘以2，最后使用 <code>forEach()</code> 方法打印结果。这个操作链允许你在流的处理过程中观察元素的中间状态。</p><h2 id="7-3-Collectors"><a href="#7-3-Collectors" class="headerlink" title="7.3 Collectors"></a>7.3 Collectors</h2><p><code>Collectors</code> 是 Java 中用于收集（或汇总）流中元素的工具类，它提供了各种用于收集数据的静态方法。<code>Collectors</code> 的主要用法包括：</p><p><strong>1. 收集到List、Set或其他集合类型：</strong></p><ul><li><code>Collectors.toList()</code>：将流中的元素收集到一个<code>List</code>中。</li><li><code>Collectors.toSet()</code>：将流中的元素收集到一个<code>Set</code>中。</li><li><code>Collectors.toCollection(collectionFactory)</code>：将流中的元素收集到指定类型的集合中。</li></ul><p>示例：</p><pre><code class="java">List&lt;String&gt; names = Stream.of("Alice", "Bob", "Charlie")    .collect(Collectors.toList());</code></pre><p><strong>2. 收集到Map：</strong></p><ul><li><code>Collectors.toMap(keyMapper, valueMapper)</code>：将流中的元素收集到一个<code>Map</code>中，可以指定如何映射键和值。</li><li><code>Collectors.toConcurrentMap(keyMapper, valueMapper)</code>：类似于<code>toMap</code>，但返回的是一个并发安全的<code>ConcurrentMap</code>。</li></ul><p>示例：</p><pre><code class="java">Map&lt;String, Integer&gt; nameLengthMap = Stream.of("Alice", "Bob", "Charlie")    .collect(Collectors.toMap(name -&gt; name, String::length));</code></pre><p><strong>3. 字符串连接：</strong></p><ul><li><code>Collectors.joining(delimiter)</code>：将流中的元素连接成一个字符串，可以指定连接符。</li></ul><p>示例：</p><pre><code class="java">String joinedNames = Stream.of("Alice", "Bob", "Charlie")    .collect(Collectors.joining(", "));// joinedNames 现在等于 "Alice, Bob, Charlie"</code></pre><p><strong>4. 统计汇总信息：</strong></p><ul><li><code>Collectors.summarizingInt(ToIntFunction)</code>：对<code>int</code>类型的元素进行汇总，包括计数、总和、最大值、最小值、平均值等信息。</li><li><code>Collectors.summarizingDouble(ToDoubleFunction)</code>：类似于<code>summarizingInt</code>，但适用于<code>double</code>类型的元素。</li></ul><p>示例：</p><pre><code class="java">IntSummaryStatistics stats = Stream.of(1, 2, 3, 4, 5)    .collect(Collectors.summarizingInt(Integer::intValue));</code></pre><p><strong>5. 分组和分区：</strong></p><ul><li><code>Collectors.groupingBy(classifier)</code>：根据指定条件对元素进行分组，返回一个<code>Map</code>，键是分组条件，值是分组的元素列表。</li><li><code>Collectors.partitioningBy(predicate)</code>：根据指定条件将元素分成两组（true和false），返回一个<code>Map</code>，键是true或false，值是符合条件的元素列表。</li></ul><p>示例：</p><pre><code class="java">Map&lt;Integer, List&lt;String&gt;&gt; groupByLength = Stream.of("Alice", "Bob", "Charlie")    .collect(Collectors.groupingBy(String::length));Map&lt;Boolean, List&lt;String&gt;&gt; partitionByLength = Stream.of("Alice", "Bob", "Charlie")    .collect(Collectors.partitioningBy(name -&gt; name.length() &gt; 4));</code></pre><h2 id="7-4-flatMap"><a href="#7-4-flatMap" class="headerlink" title="7.4 flatMap"></a>7.4 flatMap</h2><p>你可以使用Java中的Stream API中的<code>flatMap</code>方法来操作流并实现合并和转换的功能。下面是使用<code>flatMap</code>的一些常见示例和用法：</p><p><strong>示例1：合并多个流</strong></p><p>假设你有多个字符串流，想将它们合并成一个单一的字符串流：</p><pre><code class="java">Stream&lt;String&gt; stream1 = Stream.of("Hello", "World");Stream&lt;String&gt; stream2 = Stream.of("Java", "Programming");Stream&lt;String&gt; mergedStream = Stream.of(stream1, stream2)    .flatMap(Function.identity());mergedStream.forEach(System.out::println);</code></pre><p>这会输出：</p><pre><code class="java">HelloWorldJavaProgramming</code></pre><p>在这个示例中，我们使用<code>flatMap</code>合并了<code>stream1</code>和<code>stream2</code>，并通过<code>Function.identity()</code>函数将它们扁平化。</p><p><strong>示例2：元素转换</strong></p><p>假设你有一个字符串流，想将每个字符串拆分为单词并得到单词的流：</p><pre><code class="java">Stream&lt;String&gt; stringStream = Stream.of("Hello World", "Java Programming");Stream&lt;String&gt; wordStream = stringStream    .flatMap(str -&gt; Stream.of(str.split(" ")));wordStream.forEach(System.out::println);</code></pre><p>这会输出：</p><pre><code class="java">HelloWorldJavaProgramming</code></pre><p>在这个示例中，我们使用<code>flatMap</code>将每个字符串分割为单词，并将它们合并成一个单词流。</p><p><strong>示例3：扁平化嵌套集合</strong></p><p>假设你有一个包含多个子集合的集合，想将它们扁平化为单一流：</p><pre><code class="java">List&lt;List&lt;Integer&gt;&gt; nestedList = Arrays.asList(    Arrays.asList(1, 2, 3),    Arrays.asList(4, 5),    Arrays.asList(6, 7, 8));Stream&lt;Integer&gt; flattenedStream = nestedList    .stream()    .flatMap(List::stream);flattenedStream.forEach(System.out::println);</code></pre><p>这会输出：</p><pre><code class="java">12345678</code></pre><p>在这个示例中，我们使用<code>flatMap</code>将嵌套的列表转换为单一流，以便更容易处理其中的元素。</p><h2 id="7-5-实例"><a href="#7-5-实例" class="headerlink" title="7.5 实例"></a>7.5 实例</h2><pre><code class="java">import java.util.ArrayList;import java.util.Arrays;import java.util.IntSummaryStatistics;import java.util.List;import java.util.Random;import java.util.stream.Collectors;import java.util.Map;public class StreamTest {    public static void main(String args[]) {        System.out.println("Using Java 7: ");        // 统计空字符串的数量        List&lt;String&gt; strings = Arrays.asList("efg", "", "abc", "bc", "ghij", "", "lmn");        System.out.println("List: " + strings);        long count = getCountEmptyStringUsingJava7(strings);        System.out.println("Empty Strings: " + count);        count = getCountLength3UsingJava7(strings);        System.out.println("Strings of length 3: " + count);        // 消除空字符串        List&lt;String&gt; filtered = deleteEmptyStringsUsingJava7(strings);        System.out.println("Filtered List: " + filtered);        // 消除空字符串，同时使用逗号来连接        String mergedString = getMergedStringUsingJava7(strings, ", ");        System.out.println("Merged String: " + mergedString);        List&lt;Integer&gt; numbers = Arrays.asList(2, 3, 3, 2, 5, 2, 7);        // 获得不同数字的平方的列表        List&lt;Integer&gt; squaresList = getSquares(numbers);        System.out.println("Squares List: " + squaresList);        List&lt;Integer&gt; integers = Arrays.asList(1, 2, 13, 4, 15, 6, 17, 8, 19);        System.out.println("List: " + integers);        System.out.println("Highest number in List : " + getMax(integers));        System.out.println("Lowest number in List : " + getMin(integers));        System.out.println("Sum of all numbers : " + getSum(integers));        System.out.println("Average of all numbers : " + getAverage(integers));        // 输出10个随机数        System.out.println("Random Numbers: ");        Random random = new Random();        for (int i = 0; i &lt; 10; i++) {            System.out.println(random.nextInt());        }        // 使用Java 8的新特性        System.out.println("Using Java 8: ");        System.out.println("List: " + strings);        count = strings.stream().filter(string -&gt; string.isEmpty()).count();        System.out.println("Empty Strings: " + count);        count = strings.stream().filter(string -&gt; string.length() == 3).count();        System.out.println("Strings of length 3: " + count);        filtered = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.toList());        System.out.println("Filtered List: " + filtered);        mergedString = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.joining(", "));        System.out.println("Merged String: " + mergedString);        squaresList = numbers.stream().map(i -&gt; i * i).distinct().collect(Collectors.toList());        System.out.println("Squares List: " + squaresList);        System.out.println("List: " + integers);        IntSummaryStatistics stats = integers.stream().mapToInt((x) -&gt; x).summaryStatistics();        // 输出结果        System.out.println("Highest number in List : " + stats.getMax());        System.out.println("Lowest number in List : " + stats.getMin());        System.out.println("Sum of all numbers : " + stats.getSum());        System.out.println("Average of all numbers : " + stats.getAverage());        System.out.println("Random Numbers: ");        random.ints().limit(10).sorted().forEach(System.out::println);        // 并行处理        count = strings.parallelStream().filter(string -&gt; string.isEmpty()).count();        System.out.println("Empty Strings: " + count);    }    // 使用Java 7版本就提供的API来计算空串数量    private static int getCountEmptyStringUsingJava7(List&lt;String&gt; strings) {        int count = 0;        for (String string : strings) {            if (string.isEmpty()) {                count++;            }        }        return count;    }    // 使用Java 7版本就提供的API来计算长度为3字符的字符串数量    private static int getCountLength3UsingJava7(List&lt;String&gt; strings) {        int count = 0;        for (String string : strings) {            if (string.length() == 3) {                count++;            }        }        return count;    }    // 使用Java 7版本就提供的API来删除空串    private static List&lt;String&gt; deleteEmptyStringsUsingJava7(List&lt;String&gt; strings) {        List&lt;String&gt; filteredList = new ArrayList&lt;String&gt;();        for (String string : strings) {            if (!string.isEmpty()) {                filteredList.add(string);            }        }        return filteredList;    }    // 使用Java 7版本就提供的API来获取合并后的字符串    private static String getMergedStringUsingJava7(List&lt;String&gt; strings, String separator) {        StringBuilder stringBuilder = new StringBuilder();        for (String string : strings) {            if (!string.isEmpty()) {                stringBuilder.append(string);                stringBuilder.append(separator);            }        }        String mergedString = stringBuilder.toString();        return mergedString.substring(0, mergedString.length() - 2);    }    // 自定义的用于计算数字的平方的方法    private static List&lt;Integer&gt; getSquares(List&lt;Integer&gt; numbers) {        List&lt;Integer&gt; squaresList = new ArrayList&lt;Integer&gt;();        for (Integer number : numbers) {            Integer square = new Integer(number.intValue() * number.intValue());            if (!squaresList.contains(square)) {                squaresList.add(square);            }        }        return squaresList;    }    // 自定义的用于获得List中最大值的方法    private static int getMax(List&lt;Integer&gt; numbers) {        int max = numbers.get(0);        for (int i = 1; i &lt; numbers.size(); i++) {            Integer number = numbers.get(i);            if (number.intValue() &gt; max) {                max = number.intValue();            }        }        return max;    }    // 自定义的用于获得List中最小值的方法    private static int getMin(List&lt;Integer&gt; numbers) {        int min = numbers.get(0);        for (int i = 1; i &lt; numbers.size(); i++) {            Integer number = numbers.get(i);            if (number.intValue() &lt; min) {                min = number.intValue();            }        }        return min;    }    // 自定义的用于获得List中各个数字的和的方法    private static int getSum(List&lt;Integer&gt; numbers) {        int sum = (int) (numbers.get(0));        for (int i = 1; i &lt; numbers.size(); i++) {            sum += (int) numbers.get(i);        }        return sum;    }    // 自定义的用于获得List中各个数字的平均值的方法    private static int getAverage(List&lt;Integer&gt; numbers) {        return getSum(numbers) / numbers.size();    }}</code></pre><h1 id="8-IO"><a href="#8-IO" class="headerlink" title="8 IO"></a>8 IO</h1><h2 id="8-1-文件"><a href="#8-1-文件" class="headerlink" title="8.1 文件"></a>8.1 文件</h2><p><code>java.io.File</code> 类是 Java 中用于操作文件和目录的基本类之一。它允许你创建、删除、重命名、查询文件和目录的属性等操作。以下是一些常见的 <code>File</code> 类的用法和示例：</p><ol><li><p>创建 <code>File</code> 对象：</p><ul><li>通过指定文件或目录的路径来创建 <code>File</code> 对象。</li></ul><pre><code class="java">File file = new File("/path/to/file.txt");File directory = new File("/path/to/directory");</code></pre></li><li><p>检查文件或目录是否存在：</p><ul><li>使用 <code>exists()</code> 方法检查文件或目录是否存在。</li></ul><pre><code class="java">boolean exists = file.exists();</code></pre></li><li><p>创建文件或目录：</p><ul><li>使用 <code>createNewFile()</code> 方法创建文件。</li></ul><pre><code class="java">boolean created = file.createNewFile();</code></pre><ul><li>使用 <code>mkdir()</code> 方法创建目录。</li></ul><pre><code class="java">boolean created = directory.mkdir();</code></pre></li><li><p>删除文件或目录：</p><ul><li>使用 <code>delete()</code> 方法删除文件或目录。</li></ul><pre><code class="java">boolean deleted = file.delete();</code></pre></li><li><p>获取文件或目录的属性：</p><ul><li>使用 <code>getName()</code> 方法获取文件或目录的名称。</li></ul><pre><code class="java">String name = file.getName();</code></pre><ul><li>使用 <code>isFile()</code> 和 <code>isDirectory()</code> 方法检查文件或目录的类型。</li></ul><pre><code class="java">boolean isFile = file.isFile();boolean isDirectory = directory.isDirectory();</code></pre></li><li><p>获取文件大小和最后修改时间：</p><ul><li>使用 <code>length()</code> 方法获取文件大小（字节数）。</li></ul><pre><code class="java">long fileSize = file.length();</code></pre><ul><li>使用 <code>lastModified()</code> 方法获取文件的最后修改时间戳。</li></ul><pre><code class="java">long lastModifiedTime = file.lastModified();</code></pre></li><li><p>列出目录中的文件和子目录：</p><ul><li>使用 <code>list()</code> 方法获取目录中的所有文件和子目录的名称。</li></ul><pre><code class="java">String[] contents = directory.list();</code></pre><ul><li>使用 <code>listFiles()</code> 方法获取目录中的所有文件和子目录的 <code>File</code> 对象。</li></ul><pre><code class="java">File[] files = directory.listFiles();</code></pre></li><li><p>重命名文件或目录：</p><ul><li>使用 <code>renameTo()</code> 方法重命名文件或目录。</li></ul><pre><code class="java">File newFile = new File("/path/to/new_name.txt");boolean renamed = file.renameTo(newFile);</code></pre></li></ol><h2 id="8-2-文件流"><a href="#8-2-文件流" class="headerlink" title="8.2 文件流"></a>8.2 文件流</h2><p>文件输入流（FileInputStream）：</p><ol><li><p>导入必要的输入输出流类：</p><pre><code class="java">import java.io.FileInputStream;import java.io.IOException;</code></pre></li><li><p>创建 <code>FileInputStream</code> 对象并打开文件：</p><pre><code class="java">FileInputStream fileInputStream = new FileInputStream("path/to/your/file.txt");</code></pre></li><li><p>读取文件内容：</p><ul><li>使用 <code>read()</code> 方法逐个字节读取文件内容。</li></ul><pre><code class="java">int data;while ((data = fileInputStream.read()) != -1) {    // 处理读取到的字节数据，可以将其转换成字符或做其他处理    char character = (char) data;    System.out.print(character);}</code></pre></li><li><p>关闭文件输入流：</p><pre><code class="java">fileInputStream.close();</code></pre></li></ol><p>文件输出流（FileOutputStream）：</p><ol><li><p>导入必要的输入输出流类：</p><pre><code class="java">import java.io.FileOutputStream;import java.io.IOException;</code></pre></li><li><p>创建 <code>FileOutputStream</code> 对象并打开文件：</p><pre><code class="java">FileOutputStream fileOutputStream = new FileOutputStream("path/to/your/output/file.txt");</code></pre></li><li><p>写入数据到文件：</p><ul><li>使用 <code>write()</code> 方法写入字节数组到文件。</li></ul><pre><code class="java">String text = "Hello, world!";byte[] bytes = text.getBytes();fileOutputStream.write(bytes);</code></pre></li><li><p>关闭文件输出流：</p><pre><code class="java">fileOutputStream.close();</code></pre></li></ol><p>3.<code>BufferedReader</code> 是 Java 中的一个字符缓冲输入流类，它用于高效读取文本文件的内容。它通常与其他字符输入流一起使用，如 <code>FileReader</code> 或 <code>InputStreamReader</code>，以提高读取性能和效率。</p><p><code>BufferedReader</code> 具有以下主要特点和功能：</p><ol><li>缓冲机制：<code>BufferedReader</code> 在内部维护一个缓冲区，可以一次性读取多个字符，然后逐个提供给程序。这减少了频繁的磁盘或网络访问，从而提高了读取效率。</li><li>逐行读取：<code>BufferedReader</code> 提供了 <code>readLine()</code> 方法，允许你逐行读取文本文件的内容，这在处理文本文件时非常常见。</li><li>自动字符编码：<code>BufferedReader</code> 默认会根据系统的字符编码自动处理字符解码，这意味着它可以正确处理不同字符编码的文本文件。</li><li>提供字符数组读取：除了逐行读取外，你还可以使用 <code>read(char[] cbuf, int off, int len)</code> 方法来读取指定数量的字符到字符数组中。</li><li>支持跳过字符：它还提供了 <code>skip(long n)</code> 方法，允许你跳过指定数量的字符。</li></ol><p>以下是创建和使用 <code>BufferedReader</code> 的基本示例：</p><pre><code class="java">import java.io.BufferedReader;import java.io.FileReader;import java.io.IOException;public class BufferedReaderExample {    public static void main(String[] args) {        try {            FileReader fileReader = new FileReader("path/to/your/textfile.txt");            BufferedReader bufferedReader = new BufferedReader(fileReader);                        String line;            while ((line = bufferedReader.readLine()) != null) {                // 处理每一行文本数据                System.out.println(line);            }                        bufferedReader.close();            fileReader.close();        } catch (IOException e) {            e.printStackTrace();        }    }}</code></pre><p>在上面的示例中，我们使用了 <code>BufferedReader</code> 来逐行读取文本文件的内容，并确保在使用完毕后关闭流以释放资源。</p><h2 id="8-3-RandomAccessFile"><a href="#8-3-RandomAccessFile" class="headerlink" title="8. 3 RandomAccessFile"></a>8. 3 RandomAccessFile</h2><p><code>RandomAccessFile</code> 是 Java 中用于随机访问文件的类，它允许你在文件中定位特定的位置并读取或写入数据。你可以使用 <code>RandomAccessFile</code> 执行以下操作：</p><ol><li>打开文件：使用 <code>RandomAccessFile</code> 的构造函数来打开文件，并指定文件名和打开模式（只读、读写等）。</li><li>定位文件指针：使用 <code>seek()</code> 方法来定位文件中的指针位置，以便读取或写入数据。</li><li>读取数据：使用 <code>read()</code> 方法来从文件中读取数据。</li><li>写入数据：使用 <code>write()</code> 方法来向文件中写入数据。</li><li>关闭文件：在完成操作后，使用 <code>close()</code> 方法关闭文件。</li></ol><p>以下是一个示例，演示如何使用 <code>RandomAccessFile</code> 来读取和写入文件：</p><pre><code class="java">import java.io.RandomAccessFile;import java.io.IOException;public class RandomAccessFileExample {    public static void main(String[] args) {        try {            // 打开文件，使用 "rw" 表示读写模式            RandomAccessFile file = new RandomAccessFile("path/to/your/file.txt", "rw");            // 定位文件指针到特定位置            file.seek(10); // 将文件指针定位到第11个字节的位置            // 读取数据            byte[] data = new byte[20];            int bytesRead = file.read(data); // 从当前文件指针位置读取20个字节的数据            System.out.println(new String(data, 0, bytesRead)); // 将读取的数据转换为字符串并输出            // 写入数据            file.seek(30); // 将文件指针定位到第31个字节的位置            String newData = "New data to write.";            file.write(newData.getBytes());            // 关闭文件            file.close();        } catch (IOException e) {            e.printStackTrace();        }    }}</code></pre><p>在上面的示例中，我们使用 <code>RandomAccessFile</code> 打开文件，定位文件指针，读取数据，写入数据，然后关闭文件。请注意，在实际应用中，你需要处理可能抛出的 <code>IOException</code> 异常，并确保在不再需要访问文件时关闭文件，以释放资源。</p><pre><code class="java">import java.io.RandomAccessFile;public class FileDemo {    public static void main(String[] args) {        int[] data_arr = {12, 32, 43, 45, 1, 5};        try {            // 打开一个名为 "temp.txt" 的文件，以读写模式打开            RandomAccessFile randomAccessFile = new RandomAccessFile("temp.txt", "rw");            // 循环遍历整数数组并将每个整数写入文件            for(int i = 0; i &lt; data_arr.length; i++){                randomAccessFile.writeInt(data_arr[i]);            }            // 从文件中逆序读取整数并打印它们            for(int i = data_arr.length-1; i &gt;= 0; i--){                // 定位文件指针到正确的位置，每个整数占用 4 个字节                randomAccessFile.seek(i * 4L);                                // 读取整数并打印                System.out.println(randomAccessFile.readInt());            }            // 关闭文件            randomAccessFile.close();        } catch (Exception e) {            e.printStackTrace();        }    }}</code></pre><h2 id="8-4-Files工具类"><a href="#8-4-Files工具类" class="headerlink" title="8.4 Files工具类"></a>8.4 Files工具类</h2><p>以下是一些常见的 <code>Files</code> 工具类的用法：</p><ol><li><p>复制文件或目录：</p><pre><code class="java">Path source = Paths.get("source.txt");Path target = Paths.get("target.txt");Files.copy(source, target, StandardCopyOption.REPLACE_EXISTING);</code></pre></li><li><p>移动文件或目录：</p><pre><code class="java">Path source = Paths.get("source.txt");Path target = Paths.get("new_directory/target.txt");Files.move(source, target, StandardCopyOption.REPLACE_EXISTING);</code></pre></li><li><p>删除文件或目录：</p><pre><code class="java">Path path = Paths.get("file_or_directory_to_delete.txt");Files.delete(path);</code></pre></li><li><p>创建文件：</p><pre><code class="java">Path file = Paths.get("new_file.txt");Files.createFile(file);</code></pre></li><li><p>创建目录：</p><pre><code class="java">Path directory = Paths.get("new_directory");Files.createDirectory(directory);</code></pre></li><li><p>创建多层次目录：</p><pre><code class="java">Path directories = Paths.get("parent_directory/child_directory");Files.createDirectories(directories);</code></pre></li><li><p>读取文件内容：</p><pre><code class="java">Path file = Paths.get("file.txt");List&lt;String&gt; lines = Files.readAllLines(file, StandardCharsets.UTF_8);</code></pre></li><li><p>写入文件内容：</p><pre><code class="java">Path file = Paths.get("file.txt");List&lt;String&gt; lines = Arrays.asList("Line 1", "Line 2", "Line 3");Files.write(file, lines, StandardCharsets.UTF_8);</code></pre></li><li><p>检查文件或目录是否存在：</p><pre><code class="java">Path path = Paths.get("file_or_directory.txt");boolean exists = Files.exists(path);</code></pre></li><li><p>获取文件属性：</p><pre><code class="java">Path file = Paths.get("file.txt");BasicFileAttributes attributes = Files.readAttributes(file, BasicFileAttributes.class);</code></pre></li></ol><h2 id="8-5-file"><a href="#8-5-file" class="headerlink" title="8.5 file"></a>8.5 file</h2><pre><code class="java">import java.io.IOException;import java.nio.file.Files;import java.nio.file.Paths;import java.nio.file.StandardCopyOption;public class CopyDemo {    public static void main(String[] args) {        try {            //被拷贝的文件一定要存在 否则会抛出异常  这里的1.txt一定要存在            Files.copy(Paths.get("/home/project/1.txt"), Paths.get("/home/project/2.txt"), StandardCopyOption.REPLACE_EXISTING);        } catch (IOException e) {            e.printStackTrace();        }    }}</code></pre><pre><code class="java">import java.io.IOException;import java.nio.file.Files;import java.nio.file.Paths;import java.nio.file.StandardCopyOption;public class MoveDemo {    public static void main(String[] args) {        try {            //将1.txt 重命名为3.txt 如果只需要移动到不同的目录，文件名不变即可            Files.move(Paths.get("/home/project/1.txt"), Paths.get("/home/project/3.txt"), StandardCopyOption.REPLACE_EXISTING);        //将2.txt 重命名为4.txt 如果只需要移动到不同的目录，文件名不变即可        Files.move(Paths.get("/home/project/2.txt"), Paths.get("/home/project/4.txt"), StandardCopyOption.REPLACE_EXISTING);        } catch (IOException e) {            e.printStackTrace();        }    }}</code></pre><pre><code class="java">import java.io.File;import java.io.IOException;import java.nio.file.Files;import java.nio.file.Paths;public class DeleteDemo {    public static void main(String[] args) {        try {            //删除文件，文件必须存在，否则抛出异常            Files.delete(Paths.get("/home/project/3.txt"));            //删除文件，返回是否删除成功 即使文件不存在，也不会保存，直接返回false            System.out.println(Files.deleteIfExists(Paths.get("/home/project/3.txt")));            //或者使用File类的delete方法            File file = new File("/home/project/4.txt");            System.out.println(file.delete());        } catch (IOException e) {            e.printStackTrace();        }    }}</code></pre><pre><code class="java">import java.io.File;import java.util.Arrays;public class FileInfo {    public static void main(String[] args) {        File file = new File("/home/project");        System.out.println("文件或者目录名：" + file.getName());        System.out.println("绝对路径：" + file.getAbsolutePath());        System.out.println("父目录：" + file.getParent());        System.out.println("文件路径：" + file.getPath());        //判断文件是否是目录        if (file.isDirectory()) {            //打印目录中的文件            Arrays.stream(file.list()).forEach(System.out::println);        }        System.out.println("是否隐藏：" + file.isHidden());        System.out.println("是否存在：" + file.exists());    }}</code></pre><pre><code class="java">import java.io.File;public class ReadDir {    public static void main(String[] args) {        // 调用readDir方法，传入指定目录的File对象        readDir(new File("/home"));    }    /**     * 递归地读取目录和文件，并输出它们的类型和名称     *     * @param file 要处理的File对象     */    public static void readDir(File file) {        // 如果传入的File对象为null，则直接返回        if (file == null) return;                // 如果File对象表示一个目录        if (file.isDirectory()) {            // 输出目录的信息（名称）            System.out.println("目录" + file.getName());                        // 获取目录下的所有文件和子目录            File[] files = file.listFiles();                        // 遍历每一个文件或子目录并递归调用readDir方法            for (File file2 : files) {                readDir(file2);            }        } else {            // 如果File对象表示一个文件，输出文件的信息（名称）            System.out.println("文件" + file.getName());        }    }}</code></pre><h2 id="8-6-分类"><a href="#8-6-分类" class="headerlink" title="8.6 分类"></a>8.6 分类</h2><p>IO流分为字节流和字符流的分类是基于处理数据的单位和性质来划分的。</p><ol><li><strong>字节流 (Byte Stream)</strong>:<ul><li><strong>处理单位</strong>: 以字节（8位）为单位进行数据处理，适用于处理二进制数据或者文本文件。</li><li><strong>性质</strong>: 字节流是原始的、底层的输入输出，直接操作字节数据。</li><li><strong>InputStream和OutputStream</strong>: 主要使用<code>InputStream</code>和<code>OutputStream</code>类及其子类来实现字节流。例如，<code>FileInputStream</code>用于从文件读取字节，<code>FileOutputStream</code>用于写入字节到文件。</li></ul></li><li><strong>字符流 (Character Stream)</strong>:<ul><li><strong>处理单位</strong>: 以字符为单位进行数据处理，适用于处理文本数据。</li><li><strong>性质</strong>: 字符流是高级的，能够按照字符编码方式处理数据，适合文本数据处理。</li><li><strong>Reader和Writer</strong>: 主要使用<code>Reader</code>和<code>Writer</code>类及其子类来实现字符流。例如，<code>FileReader</code>用于从文件读取字符，<code>FileWriter</code>用于写入字符到文件。</li></ul></li></ol><p>字符流的存在是为了解决字节流在处理文本数据时可能会遇到字符编码的问题。字符流能够根据指定的字符编码（如UTF-8、ASCII等）将字符转换为字节，并且能够以字符为单位更好地处理文本数据，避免乱码等问题。</p><blockquote><p><img src="C:\Users\7878\AppData\Roaming\Typora\typora-user-images\image-20231009190751075.png" alt="image-20231009190751075"></p></blockquote><h2 id="8-7-缓冲流"><a href="#8-7-缓冲流" class="headerlink" title="8.7 缓冲流"></a>8.7 缓冲流</h2><p>在Java中，缓冲流用于提高读取和写入性能，通过将数据缓存到内存中来减少与磁盘或网络的交互次数。主要有<code>BufferedReader</code>和<code>BufferedWriter</code>用于字符流的缓冲，以及<code>BufferedInputStream</code>和<code>BufferedOutputStream</code>用于字节流的缓冲。以下是如何使用Java缓冲流的基本步骤：</p><ol><li><p><strong>导入必要的类</strong>： 首先，确保导入Java IO包中的相关类。根据您的需求，您需要导入以下类之一：</p><ul><li><p>对于字符流的缓冲：</p><pre><code class="java">import java.io.BufferedReader;import java.io.BufferedWriter;</code></pre></li><li><p>对于字节流的缓冲：</p><pre><code class="java">import java.io.BufferedInputStream;import java.io.BufferedOutputStream;</code></pre></li></ul></li><li><p><strong>创建底层流</strong>： 首先，创建底层的输入流（如<code>FileInputStream</code>或<code>FileReader</code>）或输出流（如<code>FileOutputStream</code>或<code>FileWriter</code>），这些流将连接到缓冲流。</p></li><li><p><strong>创建缓冲流</strong>： 使用底层流来创建缓冲流。例如，对于字符输入流：</p><pre><code class="java">BufferedReader bufferedReader = new BufferedReader(new FileReader("文件路径"));</code></pre><p>对于字符输出流：</p><pre><code class="java">BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter("文件路径"));</code></pre><p>对于字节输入流：</p><pre><code class="java">BufferedInputStream bufferedInputStream = new BufferedInputStream(new FileInputStream("文件路径"));</code></pre><p>对于字节输出流：</p><pre><code class="java">BufferedOutputStream bufferedOutputStream = new BufferedOutputStream(new FileOutputStream("文件路径"));</code></pre></li><li><p><strong>使用缓冲流</strong>： 现在，您可以使用缓冲流来读取或写入数据，它们提供了一些方便的方法。例如，使用<code>readLine()</code>来逐行读取文本文件，或使用<code>write()</code>来写入数据。</p><p>示例：</p><pre><code class="java">String line;while ((line = bufferedReader.readLine()) != null) {    // 处理读取的行数据    bufferedWriter.write(line);    bufferedWriter.newLine(); // 写入换行符}</code></pre></li><li><p><strong>关闭流</strong>： 使用完缓冲流后，务必关闭它们以释放资源。可以使用<code>close()</code>方法来关闭流，它也会自动关闭底层的基本流。</p><pre><code class="java">bufferedReader.close();bufferedWriter.close();</code></pre></li><li><p><strong>刷新流</strong>（可选）： 如果您在写入数据后需要立即将数据刷新到磁盘或网络，请调用<code>flush()</code>方法。</p><pre><code class="java">bufferedWriter.flush();</code></pre></li></ol><h2 id="8-8-ObjectStream"><a href="#8-8-ObjectStream" class="headerlink" title="8.8 ObjectStream"></a>8.8 ObjectStream</h2><p><code>ObjectInputStream</code> 和 <code>ObjectOutputStream</code> 是 Java 中用于序列化和反序列化对象的类。它们可以将对象转换为字节流以便于存储和传输，并在需要时将字节流还原为对象。以下是如何使用这两个类的基本示例：</p><p><strong>对象的序列化（写入）：</strong></p><pre><code class="java">import java.io.*;public class ObjectSerialization {    public static void main(String[] args) {        try (FileOutputStream fileOutputStream = new FileOutputStream("object.ser");             ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream)) {            // 创建一个对象            Person person = new Person("Alice", 30);            // 将对象序列化并写入文件            objectOutputStream.writeObject(person);            System.out.println("对象已成功序列化");        } catch (IOException e) {            e.printStackTrace();        }    }}</code></pre><p><strong>对象的反序列化（读取）：</strong></p><pre><code class="java">import java.io.*;public class ObjectDeserialization {    public static void main(String[] args) {        try (FileInputStream fileInputStream = new FileInputStream("object.ser");             ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream)) {            // 从文件中读取序列化的对象            Person person = (Person) objectInputStream.readObject();            System.out.println("对象已成功反序列化");            System.out.println("Name: " + person.getName());            System.out.println("Age: " + person.getAge());        } catch (IOException | ClassNotFoundException e) {            e.printStackTrace();        }    }}</code></pre><p>上述示例中，<code>Person</code> 类是一个简单的自定义类，用于演示对象的序列化和反序列化。在实际应用中，您可以替换成您需要序列化的自定义对象。</p><p>要成功序列化对象，确保被序列化的对象及其成员都是可序列化的。为此，您可以实现 <code>Serializable</code> 接口，并在需要的情况下自定义 <code>serialVersionUID</code> 字段以控制版本兼容性。</p><pre><code class="java">public static class User implements Serializable {        private String name;        private String id;        public User(String name, String id){            this.id = id;            this.name = name;        }        @Override         public String toString(){            return "User =" + name + "\nid = " + id + "\n";        }    }</code></pre><h1 id="9-网络"><a href="#9-网络" class="headerlink" title="9 网络"></a>9 网络</h1><h2 id="9-1-HttpURLConnection"><a href="#9-1-HttpURLConnection" class="headerlink" title="9.1 HttpURLConnection"></a>9.1 HttpURLConnection</h2><pre><code class="java">import java.io.BufferedReader;import java.io.InputStreamReader;import java.net.HttpURLConnection;import java.net.URL;public class HttpClientExample {    public static void main(String[] args) {        try {            // 创建一个URL对象，指定要发送HTTP GET请求的目标地址            URL url = new URL("https://example.com");            // 打开HTTP连接            HttpURLConnection connection = (HttpURLConnection) url.openConnection();            // 设置HTTP请求方法为GET            connection.setRequestMethod("GET");            // 获取HTTP响应码            int responseCode = connection.getResponseCode();            if (responseCode == HttpURLConnection.HTTP_OK) {                // 如果响应码为200，表示请求成功                // 创建一个BufferedReader对象来读取响应内容                BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));                String inputLine;                StringBuilder content = new StringBuilder();                // 逐行读取响应内容并存储在StringBuilder中                while ((inputLine = in.readLine()) != null) {                    content.append(inputLine);                }                in.close();                // 打印响应内容                System.out.println(content.toString());            } else {                // 如果响应码不为200，打印HTTP请求失败信息                System.out.println("HTTP request failed with response code: " + responseCode);            }        } catch (Exception e) {            // 捕获并打印任何异常            e.printStackTrace();        }    }}</code></pre><h2 id="9-2-InetAddress"><a href="#9-2-InetAddress" class="headerlink" title="9.2 InetAddress"></a>9.2 InetAddress</h2><p><code>InetAddress</code> 是 Java 中用于表示 IP 地址的类。它提供了一种在网络应用程序中操作 IP 地址的方式。你可以使用 <code>InetAddress</code> 来获取主机名和 IP 地址之间的映射，以及执行网络通信时需要的地址解析。</p><p>以下是一些常见的 <code>InetAddress</code> 类的用法示例：</p><p><strong>获取本地主机的 InetAddress 对象</strong>：</p><pre><code class="java">InetAddress localHost = InetAddress.getLocalHost();System.out.println("本地主机的主机名：" + localHost.getHostName());System.out.println("本地主机的IP地址：" + localHost.getHostAddress());</code></pre><p><strong>通过主机名获取 InetAddress 对象</strong>：</p><pre><code class="java">String hostname = "www.example.com";InetAddress address = InetAddress.getByName(hostname);System.out.println("主机名：" + address.getHostName());System.out.println("IP地址：" + address.getHostAddress());</code></pre><p><strong>获取主机的所有 IP 地址</strong>：</p><pre><code class="java">String hostname = "www.example.com";InetAddress[] addresses = InetAddress.getAllByName(hostname);for (InetAddress addr : addresses) {    System.out.println("主机名：" + addr.getHostName());    System.out.println("IP地址：" + addr.getHostAddress());}</code></pre><p><strong>检查主机是否可达</strong>：</p><pre><code class="java">String hostname = "www.example.com";InetAddress address = InetAddress.getByName(hostname);if (address.isReachable(5000)) {    System.out.println("主机可达");} else {    System.out.println("主机不可达");}</code></pre><h2 id="9-3-Socket"><a href="#9-3-Socket" class="headerlink" title="9.3 Socket"></a>9.3 Socket</h2><p>使用 Java 中的 <code>Socket</code> 进行网络编程涉及以下步骤：</p><ol><li><p><strong>创建客户端套接字</strong>：如果你要编写客户端应用程序，首先需要创建一个 <code>Socket</code> 对象，以便连接到远程服务器。使用以下代码创建客户端套接字：</p><pre><code class="java">String serverHost = "example.com";int serverPort = 8080;try {    Socket socket = new Socket(serverHost, serverPort);    // 现在你可以使用 socket 进行数据发送和接收} catch (IOException e) {    e.printStackTrace();}</code></pre></li><li><p><strong>创建服务器套接字</strong>：如果你要编写服务器应用程序，首先需要创建一个 <code>ServerSocket</code> 对象，以便侦听客户端的连接请求。使用以下代码创建服务器套接字：</p><pre><code class="java">int serverPort = 8080;try {    ServerSocket serverSocket = new ServerSocket(serverPort);    // 服务器套接字现在正在侦听客户端的连接请求} catch (IOException e) {    e.printStackTrace();}</code></pre></li><li><p><strong>与套接字进行数据通信</strong>：一旦套接字建立连接，你可以使用 <code>InputStream</code> 和 <code>OutputStream</code> 来在客户端和服务器之间进行数据传输。例如，客户端可以使用 <code>socket.getOutputStream()</code> 发送数据，服务器可以使用 <code>socket.getInputStream()</code> 接收数据。</p><pre><code class="java">// 客户端发送数据示例OutputStream outputStream = socket.getOutputStream();PrintWriter writer = new PrintWriter(outputStream);writer.println("Hello, Server!");writer.flush();// 服务器接收数据示例InputStream inputStream = socket.getInputStream();BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));String clientMessage = reader.readLine();</code></pre></li><li><p><strong>关闭套接字</strong>：在通信完成后，务必关闭套接字以释放资源。通常在 <code>try-catch-finally</code> 块中进行套接字关闭操作。</p><pre><code class="java">try {    // 关闭套接字    socket.close();} catch (IOException e) {    e.printStackTrace();}</code></pre></li></ol><h2 id="9-4-ServerSocket"><a href="#9-4-ServerSocket" class="headerlink" title="9.4 ServerSocket"></a>9.4 ServerSocket</h2><p>在 Java 中，<code>ServerSocket</code> 类用于创建服务器套接字，以侦听客户端的连接请求。一旦建立连接，就可以创建与客户端的通信套接字，允许数据交换。以下是使用 <code>ServerSocket</code> 的基本步骤：</p><ol><li><p><strong>创建 ServerSocket 实例</strong>：首先，实例化 <code>ServerSocket</code> 并指定服务器将侦听的端口号。</p><pre><code class="java">int serverPort = 8080;ServerSocket serverSocket = new ServerSocket(serverPort);</code></pre></li><li><p><strong>等待客户端连接</strong>：使用 <code>accept()</code> 方法等待客户端连接请求。此方法会阻塞，直到有客户端连接到服务器。</p><pre><code class="java">Socket clientSocket = serverSocket.accept();</code></pre></li><li><p><strong>与客户端进行通信</strong>：一旦客户端连接成功，就可以使用 <code>InputStream</code> 和 <code>OutputStream</code> 与客户端进行数据交换。</p><pre><code class="java">InputStream inputStream = clientSocket.getInputStream();OutputStream outputStream = clientSocket.getOutputStream();</code></pre></li><li><p><strong>接收和发送数据</strong>：使用 <code>InputStream</code> 从客户端接收数据，并使用 <code>OutputStream</code> 向客户端发送数据。</p><pre><code class="java">// 从客户端接收数据BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));String clientMessage = reader.readLine();// 向客户端发送数据PrintWriter writer = new PrintWriter(outputStream);writer.println("Hello, Client!");writer.flush();</code></pre></li><li><p><strong>关闭连接</strong>：在通信完成后，关闭客户端套接字和服务器套接字。</p><pre><code class="java">clientSocket.close();serverSocket.close();</code></pre></li></ol><p>完整示例代码如下所示：</p><pre><code class="java">import java.io.*;import java.net.*;public class ServerExample {    public static void main(String[] args) {        int serverPort = 8080;        try {            ServerSocket serverSocket = new ServerSocket(serverPort);            System.out.println("Server listening on port " + serverPort);            // 等待客户端连接            Socket clientSocket = serverSocket.accept();            System.out.println("Client connected: " + clientSocket.getInetAddress());            // 获取输入流和输出流            InputStream inputStream = clientSocket.getInputStream();            OutputStream outputStream = clientSocket.getOutputStream();            // 从客户端接收数据            BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));            String clientMessage = reader.readLine();            System.out.println("Received from client: " + clientMessage);            // 向客户端发送数据            PrintWriter writer = new PrintWriter(outputStream);            writer.println("Hello, Client!");            writer.flush();            // 关闭套接字            clientSocket.close();            serverSocket.close();        } catch (IOException e) {            e.printStackTrace();        }    }}</code></pre><p>服务端和客户端信息发送</p><pre><code class="java">import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.PrintWriter;import java.net.ServerSocket;import java.net.Socket;public class EchoServer {    public static void main(String[] args) {        try {            // 创建服务器套接字并指定端口号 1080            ServerSocket serverSocket = new ServerSocket(1080);            // 等待客户端连接            Socket client = serverSocket.accept();            // 创建用于向客户端发送数据的 PrintWriter            PrintWriter out = new PrintWriter(client.getOutputStream(), true);            // 创建用于从客户端接收数据的 BufferedReader            BufferedReader in = new BufferedReader(new InputStreamReader(client.getInputStream()));            String userIn;            // 循环读取客户端发送的数据            while ((userIn = in.readLine()) != null) {                System.out.println("收到客户端消息：" + userIn);                // 发回客户端相同的消息                out.println(userIn);            }            // 关闭套接字            client.close();            serverSocket.close();        } catch (IOException e) {            e.printStackTrace();        }    }}</code></pre><pre><code class="java">import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.PrintWriter;import java.net.Socket;import java.util.Scanner;public class EchoClient {    public static void main(String[] args) {        // 服务器主机名        String hostname = "127.0.0.1";        // 服务器端口        int port = 1080;        // 用于从用户获取输入的 Scanner 对象        Scanner userIn = new Scanner(System.in);        try {            // 建立与服务器的 socket 连接            Socket socket = new Socket(hostname, port);            // 获取 socket 输出流，用于向服务器发送数据            PrintWriter out = new PrintWriter(socket.getOutputStream(), true);            // 获取 socket 输入流，用于接收服务器返回的数据            BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));            String userInput;            System.out.println("请输入信息：");            // 当用户输入 "exit" 时退出循环            while (!"exit".equals(userInput = userIn.nextLine())) {                // 将用户输入发送到服务器                out.println(userInput);                // 从服务器接收并打印回应                System.out.println("收到服务端回应:" + in.readLine());            }            // 关闭 socket 连接            socket.close();        } catch (IOException e) {            e.printStackTrace();        }    }}</code></pre><h1 id="10-多线程"><a href="#10-多线程" class="headerlink" title="10 多线程"></a>10 多线程</h1><h2 id="10-1-实现"><a href="#10-1-实现" class="headerlink" title="10.1 实现"></a>10.1 实现</h2><ol><li><strong>继承Thread类</strong>（<code>Thread1</code>类）：<ul><li>当一个类继承自<code>Thread</code>类时，它成为一个线程类，可以直接通过创建该类的对象并调用<code>start()</code>方法来启动线程。这是一种较为简单的方式，但有一个缺点，即Java不支持多重继承，因此如果一个类已经继承了其他类，就不能再继承<code>Thread</code>类。</li></ul></li><li><strong>实现Runnable接口</strong>（<code>Thread2</code>类）：<ul><li>如果一个类已经有了一个父类或者你想要更好地分离线程的行为和类本身的行为，那么你可以选择实现<code>Runnable</code>接口。这允许你将线程的任务独立出来，以实现更灵活的多线程编程。你需要创建一个实现<code>Runnable</code>接口的类，然后将该类的实例传递给一个<code>Thread</code>对象来启动线程。这种方式避免了单一继承的限制。</li></ul></li></ol><pre><code class="java">public class CreateThread {    public static void main(String[] args) {        Thread1 thread1 = new Thread1();        //声明一个Thread1对象，这个Thread1类继承自Thread类的        Thread thread2 = new Thread(new Thread2());        //传递一个匿名对象作为参数        thread1.start();        thread2.start();        //启动线程    }}class Thread1 extends Thread {    @Override    public void run() {        //在run()方法中放入线程要完成的工作        //这里我们把两个线程各自的工作设置为打印100次信息        for (int i = 0; i &lt; 100; ++i) {            System.out.println("Hello! This is " + i);        }        //在这个循环结束后，线程便会自动结束    }}class Thread2 implements Runnable {    //与Thread1不同，如果当一个线程已经继承了另一个类时，就建议你通过实现Runnable接口来构造    @Override    public void run() {        for (int i = 0; i &lt; 100; ++i) {            System.out.println("Thanks. There is " + i);        }    }}</code></pre><h2 id="10-2-线程变量"><a href="#10-2-线程变量" class="headerlink" title="10.2 线程变量"></a>10.2 线程变量</h2><p>线程变量（Thread-local variables）是一种在多线程编程中用于在不同线程之间存储独立数据的机制。每个线程都有自己独立的变量副本，而不会相互干扰。这对于需要在线程间隔离数据的场景非常有用。</p><p>在Java中，你可以使用<code>ThreadLocal</code>类来创建线程变量。以下是使用<code>ThreadLocal</code>的基本步骤以及如何使用线程变量：</p><ol><li><p><strong>创建 ThreadLocal 对象</strong>： 首先，你需要创建一个<code>ThreadLocal</code>对象，用于存储线程本地变量。</p><pre><code class="java">ThreadLocal&lt;String&gt; threadLocalVariable = new ThreadLocal&lt;&gt;();</code></pre></li><li><p><strong>设置线程变量的值</strong>： 使用<code>ThreadLocal</code>对象的<code>set()</code>方法可以设置当前线程的变量值。</p><pre><code class="java">threadLocalVariable.set("This is thread-local data.");</code></pre></li><li><p><strong>获取线程变量的值</strong>： 使用<code>ThreadLocal</code>对象的<code>get()</code>方法可以获取当前线程的变量值。</p><pre><code class="java">String data = threadLocalVariable.get();</code></pre></li><li><p><strong>移除线程变量的值</strong>（可选）： 你也可以使用<code>ThreadLocal</code>对象的<code>remove()</code>方法来移除当前线程的变量值。</p><pre><code class="java">threadLocalVariable.remove();</code></pre></li><li><p><strong>示例代码</strong>： 下面是一个示例，演示如何在多线程环境中使用<code>ThreadLocal</code>来存储线程本地数据：</p><pre><code class="java">public class ThreadLocalExample {    private static ThreadLocal&lt;String&gt; threadLocalVariable = ThreadLocal.withInitial(() -&gt; "Default Value");    public static void main(String[] args) {        // 设置线程1的变量值        threadLocalVariable.set("Thread 1 Data");        // 启动线程2并获取其变量值        Thread thread2 = new Thread(() -&gt; {            String data = threadLocalVariable.get();            System.out.println("Thread 2 Data: " + data);        });        thread2.start();    }}</code></pre></li></ol><p>在这个示例中，线程1设置了线程变量的值，然后线程2在不影响线程1的情况下获取了自己的线程变量值。这样，每个线程都有自己独立的线程变量，互不干扰。线程变量通常用于保存线程特定的上下文信息或状态。</p><h2 id="10-3-线程同步"><a href="#10-3-线程同步" class="headerlink" title="10.3 线程同步"></a>10.3 线程同步</h2><p>线程同步是一种用于控制多个线程在共享资源上的访问以防止竞争条件和数据不一致性的机制。在Java中，你可以使用以下方式来实现线程同步：</p><p><strong>使用synchronized关键字</strong>：</p><ul><li>在方法上使用<code>synchronized</code>关键字，或者在代码块内使用<code>synchronized</code>关键字，可以确保只有一个线程可以访问被标记为<code>synchronized</code>的方法或代码块。这种方式常用于同步对象的访问。</li></ul><pre><code class="java">public synchronized void synchronizedMethod() {    // 同步的方法内容}</code></pre><pre><code class="java">synchronized (lockObject) {    // 同步的代码块}</code></pre><pre><code class="java">public class SynchronizedExample {    private int counter = 0;    public synchronized void increment() {        counter++;    }    public synchronized int getCounter() {        return counter;    }    public static void main(String[] args) {        SynchronizedExample example = new SynchronizedExample();        // 创建多个线程并启动它们        Thread thread1 = new Thread(() -&gt; {            for (int i = 0; i &lt; 1000; i++) {                example.increment();            }        });        Thread thread2 = new Thread(() -&gt; {            for (int i = 0; i &lt; 1000; i++) {                example.increment();            }        });        thread1.start();        thread2.start();        try {            // 等待两个线程执行完毕            thread1.join();            thread2.join();        } catch (InterruptedException e) {            e.printStackTrace();        }        // 输出最终计数器的值        System.out.println("Final Counter Value: " + example.getCounter());    }}</code></pre><p><strong>使用ReentrantLock</strong>：</p><ul><li><code>java.util.concurrent.locks.ReentrantLock</code>是一个更灵活的同步机制，可以用于替代<code>synchronized</code>关键字。它提供了更多的控制选项，如尝试获取锁、设置锁超时等。</li></ul><pre><code class="java">private final ReentrantLock lock = new ReentrantLock();public void synchronizedMethod() {    lock.lock();    try {        // 同步的方法内容    } finally {        lock.unlock();    }}</code></pre><pre><code class="java">import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;public class ReentrantLockExample {    private int counter = 0;    private Lock lock = new ReentrantLock(); // 创建一个ReentrantLock对象    public void increment() {        lock.lock(); // 获取锁        try {            counter++;        } finally {            lock.unlock(); // 释放锁        }    }    public int getCounter() {        lock.lock(); // 获取锁        try {            return counter;        } finally {            lock.unlock(); // 释放锁        }    }    public static void main(String[] args) {        ReentrantLockExample example = new ReentrantLockExample();        // 创建多个线程并启动它们        Thread thread1 = new Thread(() -&gt; {            for (int i = 0; i &lt; 1000; i++) {                example.increment();            }        });        Thread thread2 = new Thread(() -&gt; {            for (int i = 0; i &lt; 1000; i++) {                example.increment();            }        });        thread1.start();        thread2.start();        try {            // 等待两个线程执行完毕            thread1.join();            thread2.join();        } catch (InterruptedException e) {            e.printStackTrace();        }        // 输出最终计数器的值        System.out.println("Final Counter Value: " + example.getCounter());    }}</code></pre><p>在多线程编程中，<code>thread.join()</code> 是一个用于等待线程完成的方法。当一个线程调用另一个线程的 <code>join()</code> 方法时，它会被阻塞，直到被调用的线程执行完毕。这意味着程序会等待被调用的线程完成它的任务，然后再继续执行接下来的代码。</p><p>通常情况下，<code>thread.join()</code> 用于确保主线程等待所有其他线程完成之后再继续执行，这对于需要协调多个线程之间的操作非常有用。例如，如果你有一个主线程和多个工作线程，你可以使用 <code>join()</code> 来等待所有工作线程完成它们的任务，然后再进行结果的汇总或其他操作。</p><p>在Java中，<code>Condition</code> 是在多线程编程中用于控制线程之间协作和同步的一种机制。<code>Condition</code> 通常与 <code>ReentrantLock</code> 结合使用，以替代传统的 <code>synchronized</code> 块来实现更灵活的线程同步。</p><p><code>Condition</code> 提供了类似于 <code>wait()</code> 和 <code>notify()</code> 方法的功能，但比它们更灵活。下面是一些关于 <code>Condition</code> 的基本用法：</p><ol><li><p>创建 <code>Condition</code>： 通常，你需要与一个 <code>ReentrantLock</code> 关联来创建一个 <code>Condition</code>。这可以通过调用 <code>ReentrantLock</code> 的 <code>newCondition()</code> 方法来实现。例如：</p><pre><code class="java">ReentrantLock lock = new ReentrantLock();Condition condition = lock.newCondition();</code></pre></li><li><p>等待条件： 你可以使用 <code>await()</code> 方法来让线程等待某个条件变为真。线程将被阻塞，直到其他线程调用 <code>signal()</code> 或 <code>signalAll()</code> 来通知等待的线程条件已满足。例如：</p><pre><code class="java">lock.lock();try {    while (conditionNotMet) {        condition.await();    }    // 执行条件已满足时的操作} finally {    lock.unlock();}</code></pre></li><li><p>通知条件： 当某个条件发生变化时，可以使用 <code>signal()</code> 或 <code>signalAll()</code> 方法来通知等待的线程。<code>signal()</code> 通知一个等待线程，而 <code>signalAll()</code> 通知所有等待线程。例如：</p><pre><code class="java">lock.lock();try {    // 更新条件    conditionNotMet = false;    // 通知等待的线程条件已满足    condition.signal();} finally {    lock.unlock();}</code></pre></li></ol><p><code>Condition</code> 的使用允许更细粒度的线程同步，因为你可以选择哪个条件需要等待或被通知，而不是像传统的 <code>wait()</code> 和 <code>notify()</code> 那样只能等待或通知一个条件。这使得线程的管理和同步更加灵活和精确。</p><p>需要注意的是，<code>Condition</code> 通常与 <code>ReentrantLock</code> 配合使用，而不是与传统的 <code>synchronized</code> 关键字。这是因为 <code>Condition</code> 提供了更多的控制权和灵活性，适用于更复杂的多线程场景。</p><pre><code class="java">import java.util.LinkedList;import java.util.Queue;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.ReentrantLock;public class ProducerConsumerExample {    private static final int CAPACITY = 5;  // 缓冲区容量    private final Queue&lt;Integer&gt; buffer = new LinkedList&lt;&gt;();  // 缓冲区队列    private final ReentrantLock lock = new ReentrantLock();  // 重入锁    private final Condition notFull = lock.newCondition();  // 缓冲区不满的条件    private final Condition notEmpty = lock.newCondition();  // 缓冲区不空的条件    // 生产者方法：往缓冲区中添加数据    public void produce(int item) throws InterruptedException {        lock.lock();  // 获取锁        try {            while (buffer.size() == CAPACITY) {                System.out.println("Buffer is full. Producer is waiting.");                notFull.await();  // 缓冲区已满，生产者等待            }            buffer.offer(item);            System.out.println("Produced: " + item);            notEmpty.signal();  // 通知等待的消费者        } finally {            lock.unlock();  // 释放锁        }    }    // 消费者方法：从缓冲区中取出数据    public int consume() throws InterruptedException {        lock.lock();  // 获取锁        try {            while (buffer.isEmpty()) {                System.out.println("Buffer is empty. Consumer is waiting.");                notEmpty.await();  // 缓冲区为空，消费者等待            }            int item = buffer.poll();            System.out.println("Consumed: " + item);            notFull.signal();  // 通知等待的生产者            return item;        } finally {            lock.unlock();  // 释放锁        }    }    public static void main(String[] args) {        ProducerConsumerExample example = new ProducerConsumerExample();        // 创建生产者线程        Thread producerThread = new Thread(() -&gt; {            try {                for (int i = 1; i &lt;= 10; i++) {                    example.produce(i);                    Thread.sleep(1000);                }            } catch (InterruptedException e) {                e.printStackTrace();            }        });        // 创建消费者线程        Thread consumerThread = new Thread(() -&gt; {            try {                for (int i = 1; i &lt;= 10; i++) {                    int item = example.consume();                    Thread.sleep(1000);                }            } catch (InterruptedException e) {                e.printStackTrace();            }        });        producerThread.start();  // 启动生产者线程        consumerThread.start();  // 启动消费者线程        try {            producerThread.join();  // 等待生产者线程结束            consumerThread.join();  // 等待消费者线程结束        } catch (InterruptedException e) {            e.printStackTrace();        }    }}</code></pre><h2 id="10-4-死锁"><a href="#10-4-死锁" class="headerlink" title="10.4 死锁"></a>10.4 死锁</h2><pre><code class="java">public class DeadlockExample {    public static void main(String[] args) {        // 创建两个资源        Object resource1 = new Object();        Object resource2 = new Object();        // 线程1尝试获取资源1，然后资源2        Thread thread1 = new Thread(() -&gt; {            synchronized (resource1) {                System.out.println("Thread 1: Holding resource 1...");                try {                    Thread.sleep(100); // 为了增加死锁发生的机会                } catch (InterruptedException e) {                    e.printStackTrace();                }                System.out.println("Thread 1: Waiting for resource 2...");                synchronized (resource2) {                    System.out.println("Thread 1: Acquired resource 2.");                }            }        });        // 线程2尝试获取资源2，然后资源1        Thread thread2 = new Thread(() -&gt; {            synchronized (resource2) {                System.out.println("Thread 2: Holding resource 2...");                try {                    Thread.sleep(100); // 为了增加死锁发生的机会                } catch (InterruptedException e) {                    e.printStackTrace();                }                System.out.println("Thread 2: Waiting for resource 1...");                synchronized (resource1) {                    System.out.println("Thread 2: Acquired resource 1.");                }            }        });        // 启动两个线程        thread1.start();        thread2.start();        // 等待两个线程完成        try {            thread1.join();            thread2.join();        } catch (InterruptedException e) {            e.printStackTrace();        }        System.out.println("Both threads have finished.");    }}</code></pre><h2 id="10-5-ArrayBlockingQueue"><a href="#10-5-ArrayBlockingQueue" class="headerlink" title="10.5  ArrayBlockingQueue"></a>10.5  ArrayBlockingQueue</h2><p><code>ArrayBlockingQueue</code> 是 Java 标准库中的一个有界阻塞队列，用于多线程编程中的生产者-消费者问题或其他线程协作场景。它基于数组实现，具有固定的容量，并且当队列已满时，生产者将被阻塞，当队列为空时，消费者将被阻塞。这种队列的特性使得它适用于限制资源的共享。</p><p>以下是如何创建和使用 <code>ArrayBlockingQueue</code> 的基本示例：</p><p>导入 <code>java.util.concurrent</code> 包：</p><pre><code class="java">import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.BlockingQueue;</code></pre><p>创建 <code>ArrayBlockingQueue</code> 对象，并指定队列容量：</p><pre><code class="java">BlockingQueue&lt;Integer&gt; queue = new ArrayBlockingQueue&lt;&gt;(10); // 创建容量为10的队列</code></pre><p>在生产者线程中往队列中添加元素，可以使用 <code>put()</code> 方法来添加，如果队列已满，它将等待：</p><pre><code class="java">try {    queue.put(1); // 将元素1放入队列} catch (InterruptedException e) {    // 处理异常}</code></pre><p>在消费者线程中从队列中取出元素，可以使用 <code>take()</code> 方法来取出，如果队列为空，它将等待：</p><pre><code class="java">try {    int item = queue.take(); // 从队列中取出元素    // 处理取出的元素} catch (InterruptedException e) {    // 处理异常}</code></pre><p>你还可以使用 <code>offer()</code> 方法尝试往队列中添加元素，如果队列已满，它会立即返回 <code>false</code>，或者使用 <code>poll()</code> 方法尝试取出元素，如果队列为空，它会立即返回 <code>null</code>。</p><pre><code class="java">boolean added = queue.offer(2); // 尝试将元素2放入队列，如果队列已满返回falseInteger item = queue.poll(); // 尝试从队列中取出元素，如果队列为空返回null</code></pre><p><code>ArrayBlockingQueue</code> 还提供了其他一些方法，如 <code>offer(E e, long timeout, TimeUnit unit)</code> 和 <code>poll(long timeout, TimeUnit unit)</code>，它们允许你在超时时间内尝试添加或取出元素。此外，你还可以使用 <code>remainingCapacity()</code> 方法来获取队列中剩余可用空间的数量。</p><h2 id="10-6-生产消费者"><a href="#10-6-生产消费者" class="headerlink" title="10.6 生产消费者"></a>10.6 生产消费者</h2><pre><code class="java">import java.util.Random;import java.util.concurrent.LinkedBlockingQueue;public class PCModel {    private static LinkedBlockingQueue&lt;Integer&gt; queue = new LinkedBlockingQueue&lt;&gt;();    String[] arr = {"生产一", "生产二", "消费一", "消费二"};    public static void main(String[] args) {        PCModel pcModel = new PCModel();        Provider provider1 = pcModel.new Provider();        Thread threadProvider1 = new Thread(provider1);                Consumer consumer1 = pcModel.new Consumer();        Thread threadConsumer1 = new Thread(consumer1);                Provider provider2 = pcModel.new Provider();        Thread threadProvider2 = new Thread(provider2);                Consumer consumer2 = pcModel.new Consumer();        Thread threadConsumer2 = new Thread(consumer2);                provider1.setS1("生产一");        consumer1.setS1("消费一");        provider2.setS1("生产二");        consumer2.setS1("消费二");        try {            Thread.sleep(500);        } catch (InterruptedException e) {                        e.printStackTrace();        }        threadProvider1.start();        threadConsumer1.start();        threadProvider2.start();        threadConsumer2.start();    }    class Provider  implements Runnable {        ThreadLocal&lt;String&gt; s = new ThreadLocal&lt;&gt;();        private String s1;        public void setS(String str) {            s.set(str);        }        public void setS1(String str){            this.s1 = str;        }        @Override        public void run() {            for(int i = 1; i &lt;= 5; i++) {                Integer integer = new Random().nextInt(100);                queue.add(integer);                System.out.println(s1 + "制做了" + integer);                try {                    Thread.sleep(1000);                } catch (InterruptedException e) {                    e.printStackTrace();                }            }        }    }    class Consumer implements Runnable {        ThreadLocal&lt;String&gt; s = new ThreadLocal&lt;&gt;();        private String s2;        public void setS(String str) {            s.set(str);        }        public void setS1(String str){            this.s2 = str;        }        @Override        public void run() {                        for(int i = 1; i &lt;= 5; i++) {                while(queue.size() == 0) {                    System.out.println(s2 + "正在等待");                    try {                        Thread.sleep(500);                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                }                Integer integer;                try {                    integer = queue.take();                    System.out.println(s2 + "获取了" + integer);                } catch (InterruptedException e) {                    e.printStackTrace();                }            }        }    }}</code></pre><h2 id="10-7-线程池"><a href="#10-7-线程池" class="headerlink" title="10.7 线程池"></a>10.7 线程池</h2><p>线程池是一种用于管理和重用线程的机制，它可以帮助你更有效地管理多线程任务，减少线程的创建和销毁开销。Java 提供了 <code>java.util.concurrent</code> 包，其中包含了线程池的实现，使其在多线程应用程序中更容易使用。</p><p>下面是如何在Java中使用线程池的一般步骤：</p><ol><li>创建线程池：你可以使用 <code>ExecutorService</code> 接口的工厂方法来创建线程池，通常有以下几种类型：<ul><li><code>Executors.newFixedThreadPool(int nThreads)</code>: 创建一个具有固定线程数的线程池，线程数不会变化。</li><li><code>Executors.newCachedThreadPool()</code>: 创建一个具有可根据需要创建新线程的线程池，适用于短期异步任务。</li><li><code>Executors.newSingleThreadExecutor()</code>: 创建一个仅包含一个线程的线程池，用于按顺序执行任务。</li><li><code>Executors.newScheduledThreadPool(int corePoolSize)</code>: 创建一个固定大小的线程池，用于调度定时任务。</li></ul></li><li>提交任务：使用线程池的 <code>submit</code> 或 <code>execute</code> 方法提交需要执行的任务。</li><li>关闭线程池：当不再需要线程池时，应该调用线程池的 <code>shutdown</code> 或 <code>shutdownNow</code> 方法来关闭线程池。这将停止线程池中的所有线程并释放资源。</li></ol><p>以下是一个简单示例：</p><pre><code class="java">import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class ThreadPoolExample {    public static void main(String[] args) {        // 创建一个固定大小为3的线程池        ExecutorService threadPool = Executors.newFixedThreadPool(3);        // 提交任务给线程池        for (int i = 1; i &lt;= 5; i++) {            final int task = i;            threadPool.submit(() -&gt; {                System.out.println("Task " + task + " is executing by thread " + Thread.currentThread().getId());            });        }        // 关闭线程池        threadPool.shutdown();    }}</code></pre><p>在这个示例中，我们创建了一个固定大小为3的线程池，然后提交了5个任务。线程池会自动分配任务给可用的线程，执行完任务后关闭线程池。</p><p>使用线程池可以提高多线程应用程序的性能和可维护性，因为它可以避免频繁创建和销毁线程，以及管理线程的生命周期。</p><h1 id="11-JDBC"><a href="#11-JDBC" class="headerlink" title="11 JDBC"></a>11 JDBC</h1><h2 id="11-1-JDBC"><a href="#11-1-JDBC" class="headerlink" title="11.1 JDBC"></a>11.1 JDBC</h2><p>JDBC 是 Java Database Connectivity 的缩写，是 Java 编程语言用于与关系型数据库进行连接和交互的标准 API（应用程序接口）。JDBC 允许 Java 应用程序通过标准接口访问和操作数据库，而不依赖于特定数据库系统。</p><p>JDBC 提供了一组类和接口，使开发人员能够执行以下任务：</p><ol><li>建立数据库连接：通过 JDBC，你可以创建与数据库的连接，这通常涉及到提供数据库的连接 URL、用户名和密码。</li><li>执行 SQL 查询：你可以使用 JDBC 来执行 SQL 查询，包括 SELECT 查询用于检索数据和 INSERT、UPDATE、DELETE 查询用于修改数据。</li><li>处理结果集：JDBC 允许你从数据库中检索查询结果，并将结果封装为 Java 对象，以便在应用程序中处理。</li><li>处理事务：JDBC 支持事务处理，你可以使用它来控制多个 SQL 操作的原子性和一致性。</li><li>处理异常：JDBC 引发异常来处理各种数据库操作可能遇到的问题，开发人员可以捕获和处理这些异常以实现错误处理和故障恢复。</li></ol><p>JDBC 是一种非常强大和灵活的工具，它允许 Java 应用程序与各种关系型数据库（如Oracle、MySQL、SQL Server、PostgreSQL等）进行集成。使用 JDBC，开发人员可以编写数据库无关的代码，从而能够轻松切换和连接到不同的数据库系统，而不必修改应用程序的大部分代码。</p><p>JDBC 驱动程序是用于不同数据库系统的具体实现，它们充当 JDBC API 和数据库之间的桥梁，允许 Java 应用程序与特定数据库进行通信。常见的 JDBC 驱动程序包括MySQL Connector/J、Oracle JDBC 驱动程序等。开发人员需要根据使用的数据库系统选择合适的 JDBC 驱动程序来建立连接。</p><h2 id="11-2-连接"><a href="#11-2-连接" class="headerlink" title="11.2 连接"></a>11.2 连接</h2><p>使用Java中的JDBC（Java Database Connectivity）来连接和操作数据库通常需要以下步骤：</p><ol><li><p><strong>导入JDBC库</strong>：首先，你需要导入JDBC库，通常包括Java的<code>java.sql</code>包和特定数据库的JDBC驱动程序库。你可以通过在Java项目中添加JAR文件或使用Maven等构建工具来引入所需的JDBC库。</p></li><li><p><strong>加载数据库驱动程序</strong>：在你的Java应用程序中，使用<code>Class.forName()</code>方法来加载特定数据库的JDBC驱动程序。不同的数据库有不同的驱动程序类名。例如，对于MySQL数据库，你可以加载MySQL的JDBC驱动程序如下：</p><pre><code class="java">Class.forName("com.mysql.cj.jdbc.Driver");</code></pre></li><li><p><strong>建立数据库连接</strong>：使用<code>DriverManager.getConnection()</code>方法来建立与数据库的连接。你需要提供数据库的连接字符串、用户名和密码。连接字符串的格式会根据使用的数据库类型而有所不同。例如，连接到MySQL数据库可以如下所示：</p><pre><code class="java">String url = "jdbc:mysql://localhost:3306/your_database";String username = "your_username";String password = "your_password";Connection connection = DriverManager.getConnection(url, username, password);</code></pre></li><li><p><strong>创建和执行SQL语句</strong>：使用<code>Connection</code>对象来创建<code>Statement</code>、<code>PreparedStatement</code>或<code>CallableStatement</code>对象，然后使用它们来执行SQL查询或更新操作。例如，执行一个简单的查询：</p><pre><code class="java">Statement statement = connection.createStatement();ResultSet resultSet = statement.executeQuery("SELECT * FROM your_table");while (resultSet.next()) {    // 处理查询结果}</code></pre></li><li><p><strong>处理结果</strong>：如果你执行的是查询操作，你可以使用<code>ResultSet</code>对象来获取查询结果。如果执行的是更新操作，你可以检查受影响的行数。</p></li><li><p><strong>关闭连接和资源</strong>：使用完数据库连接和其他资源后，记得关闭它们，以释放资源并确保安全关闭。通常，你需要在<code>finally</code>块中关闭连接、语句和结果集。</p><pre><code class="java">if (resultSet != null) {    resultSet.close();}if (statement != null) {    statement.close();}if (connection != null) {    connection.close();}</code></pre></li><li><p><strong>异常处理</strong>：务必处理可能抛出的异常，以确保程序的健壮性。你可以使用<code>try-catch</code>块来捕获异常。</p></li></ol><h2 id="11-3-Statement"><a href="#11-3-Statement" class="headerlink" title="11.3 Statement"></a>11.3 Statement</h2><ol><li><p><strong>execute(String sql)</strong> 示例：</p><pre><code class="java">Statement statement = connection.createStatement();boolean isResultSet = statement.execute("SELECT * FROM your_table");if (isResultSet) {    ResultSet resultSet = statement.getResultSet();    // 处理查询结果...} else {    int rowsAffected = statement.getUpdateCount();    System.out.println(rowsAffected + " rows updated.");}statement.close();</code></pre></li><li><p><strong>executeQuery(String sql)</strong> 示例：</p><pre><code class="java">Statement statement = connection.createStatement();ResultSet resultSet = statement.executeQuery("SELECT * FROM your_table");while (resultSet.next()) {    int id = resultSet.getInt("id");    String name = resultSet.getString("name");    // 处理查询结果...}statement.close();</code></pre></li><li><p><strong>executeUpdate(String sql)</strong> 示例：</p><pre><code class="java">Statement statement = connection.createStatement();int rowsAffected = statement.executeUpdate("UPDATE your_table SET column1 = 'value' WHERE column2 = 'criteria'");System.out.println(rowsAffected + " rows updated.");statement.close();</code></pre></li><li><p><strong>addBatch(String sql) 和 executeBatch() 示例</strong>：</p><pre><code class="java">Statement statement = connection.createStatement();statement.addBatch("INSERT INTO your_table (column1, column2) VALUES ('value1', 'value2')");statement.addBatch("UPDATE your_table SET column1 = 'new_value' WHERE column2 = 'criteria'");int[] batchResults = statement.executeBatch();// 处理批处理结果...statement.close();</code></pre></li><li><p><strong>setMaxRows(int max)</strong> 示例：</p><pre><code class="java">Statement statement = connection.createStatement();statement.setMaxRows(10); // 限制结果集最多返回 10 行ResultSet resultSet = statement.executeQuery("SELECT * FROM your_table");while (resultSet.next()) {    int id = resultSet.getInt("id");    String name = resultSet.getString("name");    // 处理查询结果...}statement.close();</code></pre></li></ol><h2 id="11-4-PreparedStatement"><a href="#11-4-PreparedStatement" class="headerlink" title="11.4 PreparedStatement"></a>11.4 PreparedStatement</h2><blockquote><ol><li><strong>预编译性</strong>：<ul><li><code>Statement</code> 是动态 SQL 语句，每次执行 SQL 查询时，都需要将 SQL 字符串发送到数据库进行解析和编译。这可能会导致性能下降，特别是在频繁执行相同查询时。</li><li><code>PreparedStatement</code> 是预编译的 SQL 语句，它在数据库中已经编译好了。你可以在 SQL 语句中使用占位符（如 <code>?</code>），然后在执行时提供具体的值，而不需要重新编译 SQL 语句。这提高了性能并减少了潜在的 SQL 注入风险。</li></ul></li><li><strong>SQL 注入</strong>：<ul><li><code>Statement</code> 在构造 SQL 查询时直接将变量值插入到查询字符串中，如果不谨慎处理输入数据，可能会导致 SQL 注入攻击。</li><li><code>PreparedStatement</code> 使用占位符来分离 SQL 查询和数据值，从而减少了 SQL 注入风险。数据库会安全处理占位符中的数据值。</li></ul></li><li><strong>可读性和维护性</strong>：<ul><li><code>Statement</code> 可能会导致更复杂的 SQL 查询字符串，因为你需要手动将值嵌入到查询中。</li><li><code>PreparedStatement</code> 更容易维护，因为 SQL 查询和数据值是分开的。</li></ul></li><li><strong>性能</strong>：<ul><li><code>PreparedStatement</code> 通常比 <code>Statement</code> 更快，特别是在重复执行相同的查询时，因为它允许数据库进行查询缓存和优化。</li></ul></li></ol></blockquote><pre><code class="java">import java.sql.Connection;import java.sql.DriverManager;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;public class PreparedStatementExample {    private static final String JDBC_URL = "jdbc:mysql://localhost:3306/your_database";    private static final String USERNAME = "your_username";    private static final String PASSWORD = "your_password";    public static void main(String[] args) {        try {            // 1. 创建数据库连接            Connection connection = DriverManager.getConnection(JDBC_URL, USERNAME, PASSWORD);            // 2. 插入数据            insertData(connection, "john_doe", "john@example.com");            // 3. 查询数据            retrieveData(connection, "john_doe");            // 4. 更新数据            updateData(connection, "john_doe", "new_email@example.com");            // 5. 删除数据            deleteData(connection, "john_doe");            // 6. 关闭连接            connection.close();        } catch (Exception e) {            e.printStackTrace();        }    }    // 插入数据    private static void insertData(Connection connection, String username, String email) throws SQLException {        String insertSQL = "INSERT INTO users (username, email) VALUES (?, ?)";        PreparedStatement preparedStatement = connection.prepareStatement(insertSQL);        preparedStatement.setString(1, username);        preparedStatement.setString(2, email);        int rowsInserted = preparedStatement.executeUpdate();        System.out.println(rowsInserted + " row(s) inserted.");        preparedStatement.close();    }    // 查询数据    private static void retrieveData(Connection connection, String username) throws SQLException {        String selectSQL = "SELECT * FROM users WHERE username = ?";        PreparedStatement preparedStatement = connection.prepareStatement(selectSQL);        preparedStatement.setString(1, username);        ResultSet resultSet = preparedStatement.executeQuery();        while (resultSet.next()) {            System.out.println("User ID: " + resultSet.getInt("id"));            System.out.println("Username: " + resultSet.getString("username"));            System.out.println("Email: " + resultSet.getString("email"));        }        preparedStatement.close();    }    // 更新数据    private static void updateData(Connection connection, String username, String newEmail) throws SQLException {        String updateSQL = "UPDATE users SET email = ? WHERE username = ?";        PreparedStatement preparedStatement = connection.prepareStatement(updateSQL);        preparedStatement.setString(1, newEmail);        preparedStatement.setString(2, username);        int rowsUpdated = preparedStatement.executeUpdate();        System.out.println(rowsUpdated + " row(s) updated.");        preparedStatement.close();    }    // 删除数据    private static void deleteData(Connection connection, String username) throws SQLException {        String deleteSQL = "DELETE FROM users WHERE username = ?";        PreparedStatement preparedStatement = connection.prepareStatement(deleteSQL);        preparedStatement.setString(1, username);        int rowsDeleted = preparedStatement.executeUpdate();        System.out.println(rowsDeleted + " row(s) deleted.");        preparedStatement.close();    }}</code></pre><h2 id="11-5-ResultSet"><a href="#11-5-ResultSet" class="headerlink" title="11.5 ResultSet"></a>11.5 ResultSet</h2><p>在 Java 中，你可以使用 <code>ResultSet</code> 对象来处理从数据库查询中获取的结果集。以下是一些常见的 <code>ResultSet</code> 操作：</p><ol><li><p><strong>遍历结果集</strong>：你可以使用 <code>while</code> 循环和 <code>resultSet.next()</code> 方法遍历结果集的每一行。在循环内部，你可以使用不同的 <code>getXXX</code> 方法来获取不同列的数据，例如 <code>getInt()</code>, <code>getString()</code>, <code>getDouble()</code> 等。</p><pre><code class="java">ResultSet resultSet = statement.executeQuery("SELECT * FROM my_table");while (resultSet.next()) {    int id = resultSet.getInt("id");    String name = resultSet.getString("name");    // 处理每一行数据}</code></pre></li><li><p><strong>获取单个列的数据</strong>：你可以使用 <code>getXXX</code> 方法来获取单个列的数据，例如 <code>getInt()</code>, <code>getString()</code>, <code>getDouble()</code> 等。方法的参数是列名或列索引。</p><pre><code class="java">int id = resultSet.getInt("id");String name = resultSet.getString("name");</code></pre></li><li><p><strong>检查列是否存在</strong>：你可以使用 <code>ResultSet</code> 的 <code>findColumn()</code> 方法来检查某列是否存在。</p><pre><code class="java">int columnIndex = resultSet.findColumn("columnName");if (columnIndex &gt; 0) {    // 列存在} else {    // 列不存在}</code></pre></li><li><p><strong>获取结果集的元数据</strong>：你可以使用 <code>ResultSet</code> 的 <code>getMetaData()</code> 方法来获取结果集的元数据，包括列数、列名等。</p><pre><code class="java">ResultSetMetaData metaData = resultSet.getMetaData();int columnCount = metaData.getColumnCount();String columnName = metaData.getColumnName(1);</code></pre></li><li><p><strong>定位到特定行</strong>：你可以使用 <code>ResultSet</code> 的 <code>absolute()</code> 方法将游标移动到结果集中的指定行。</p><pre><code class="java">resultSet.absolute(3); // 将游标移动到第 3 行</code></pre></li><li><p>**关闭 <code>ResultSet</code>**：在使用完 <code>ResultSet</code> 后，务必调用 <code>close()</code> 方法来释放资源。</p><pre><code class="java">resultSet.close();</code></pre></li></ol><h2 id="11-6-查询案例"><a href="#11-6-查询案例" class="headerlink" title="11.6 查询案例"></a>11.6 查询案例</h2><pre><code class="mysql">create database test;use test;CREATE TABLE user(    id int PRIMARY KEY,    name varchar(50),    age int,    sex varchar(50));alter table user change sex sex varchar(50) character set utf8;INSERT INTO `user`(`id`, `name`, `age`, `sex`) VALUES (1, 'shi', 20, '男');INSERT INTO `user`(`id`, `name`, `age`, `sex`) VALUES (2, 'yan', 13, '女');INSERT INTO `user`(`id`, `name`, `age`, `sex`) VALUES (3, 'lou', 22, '女');INSERT INTO `user`(`id`, `name`, `age`, `sex`) VALUES (4, 'admin', 50, '男');</code></pre><ul><li>查询 Id 为 1 的用户。</li><li>查询年龄为 13 岁，名字为 yan 的用户。</li></ul><pre><code class="java">import java.sql.Connection;import java.sql.DriverManager;import java.sql.PreparedStatement;import java.sql.ResultSet;public class JdbcTest {    static final String DB_URL = "jdbc:mysql://localhost/test";    static final String USER = "root";    static final String PASS = "";    public static void main(String[] args) {        try {            // 1. 创建数据库连接            Connection connection = DriverManager.getConnection(DB_URL, USER, PASS);            // 2. 执行第一个查询            String sql1 = "SELECT name FROM user WHERE id &gt;= 1";            PreparedStatement preparedStatement1 = connection.prepareStatement(sql1);            ResultSet resultSet1 = preparedStatement1.executeQuery();            System.out.println("id &gt;= 1");            while (resultSet1.next()) {                System.out.println(resultSet1.getString("name"));            }            // 3. 执行第二个查询            String sql2 = "SELECT * FROM user WHERE age = 13 and name = 'yan'";            PreparedStatement preparedStatement2 = connection.prepareStatement(sql2);            ResultSet resultSet2 = preparedStatement2.executeQuery();            System.out.println("find");            while (resultSet2.next()) {                System.out.println("name = " + resultSet2.getString("name"));                System.out.println("sex = " + resultSet2.getString("sex"));            }            // 4. 关闭资源            resultSet1.close();            preparedStatement1.close();            resultSet2.close();            preparedStatement2.close();            connection.close();        } catch (Exception e) {            e.printStackTrace();        }    }}</code></pre><h2 id="11-7-事务管理"><a href="#11-7-事务管理" class="headerlink" title="11.7 事务管理"></a>11.7 事务管理</h2><p>在 JDBC 中，你可以使用事务来管理数据库操作，以确保一组相关操作要么都成功提交，要么都回滚（撤销）。这是保证数据库操作的一致性和完整性的重要方式。</p><p>以下是在 JDBC 中进行事务管理的一般步骤：</p><ol><li><p><strong>开启事务</strong>：在执行 SQL 操作之前，你可以通过将自动提交（Auto-Commit）设置为 <code>false</code> 来开启事务。默认情况下，JDBC 是自动提交的，每个 SQL 语句都会立即生效。</p><pre><code class="java">connection.setAutoCommit(false); // 关闭自动提交</code></pre></li><li><p><strong>执行数据库操作</strong>：在事务中执行你的数据库操作，包括插入、更新、删除等。</p><pre><code class="java">// 执行数据库操作，例如 INSERT、UPDATE、DELETE</code></pre></li><li><p><strong>提交事务</strong>：如果所有的数据库操作都成功，你可以使用 <code>commit</code> 方法提交事务，使更改永久生效。</p><pre><code class="java">connection.commit(); // 提交事务</code></pre></li><li><p><strong>回滚事务</strong>：如果发生错误或某些操作失败，你可以使用 <code>rollback</code> 方法来回滚事务，使之前的更改不会生效。</p><pre><code class="java">connection.rollback(); // 回滚事务</code></pre></li><li><p><strong>关闭连接</strong>：最后，记得在完成事务后关闭数据库连接。</p><pre><code class="java">connection.close(); // 关闭数据库连接</code></pre></li></ol><p>下面是一个示例代码，演示了如何在 JDBC 中管理事务：</p><pre><code class="java">import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;import java.sql.Statement;public class JdbcTransactionExample {    public static void main(String[] args) {        String jdbcUrl = "jdbc:mysql://localhost:3306/your_database";        String username = "your_username";        String password = "your_password";        try (Connection connection = DriverManager.getConnection(jdbcUrl, username, password)) {            connection.setAutoCommit(false); // 开启事务            try {                // 执行一些数据库操作                Statement statement = connection.createStatement();                statement.execute("INSERT INTO users (name, age) VALUES ('John', 30)");                statement.execute("UPDATE users SET age = 31 WHERE name = 'John'");                statement.execute("DELETE FROM users WHERE name = 'John'");                connection.commit(); // 提交事务                System.out.println("Transaction committed successfully.");            } catch (SQLException e) {                connection.rollback(); // 回滚事务                System.err.println("Transaction rolled back due to an error: " + e.getMessage());            }        } catch (SQLException e) {            e.printStackTrace();        }    }}</code></pre><p>在这个示例中，我们首先将自动提交关闭，然后执行一系列数据库操作。如果操作都成功，我们提交事务。如果任何操作失败，我们回滚事务，以确保之前的更改不会生效。这样，你可以确保一组相关的操作要么全部成功，要么全部失败。</p><h1 id="12-反射"><a href="#12-反射" class="headerlink" title="12 反射"></a>12 反射</h1><p>在Java中，反射（Reflection）是一种强大的机制，允许程序在运行时检查、获取和操作类、对象、方法、字段等程序元素的信息，而不需要在编译时确定这些元素的类型。反射提供了一种途径，使你能够在运行时动态地获取和操作类的成员，而不必事先知道这些成员的名称或类型。这对于编写通用工具、框架和调试器非常有用。</p><p>在Java的反射机制中，有一些常用的类和接口，以下是其中一些主要的类和它们的用途：</p><ol><li>**<code>java.lang.Class</code>**：<code>Class</code>类代表一个类的运行时类型信息。你可以使用它来获取类的各种信息，如类名、字段、方法、构造方法、父类、接口等。</li><li>**<code>java.lang.reflect.Field</code>**：<code>Field</code>类用于表示类中的字段（成员变量）。你可以使用它来获取和设置字段的值，包括私有字段。</li><li>**<code>java.lang.reflect.Method</code>**：<code>Method</code>类用于表示类中的方法。你可以使用它来调用类的方法，包括私有方法。</li><li>**<code>java.lang.reflect.Constructor</code>**：<code>Constructor</code>类用于表示类的构造方法。你可以使用它来实例化类的对象。</li><li>**<code>java.lang.reflect.Modifier</code>**：<code>Modifier</code>类包含了一组用于解析修饰符的静态方法，如<code>isPublic()</code>、<code>isStatic()</code>等。</li><li>**<code>java.lang.reflect.Array</code>**：<code>Array</code>类提供了创建和操作数组的静态方法，如<code>newInstance()</code>和<code>getLength()</code>。</li></ol><p>使用这些类，你可以实现反射的各种功能。以下是使用反射的一般步骤：</p><ol><li>获取类的<code>Class</code>对象，通常使用<code>.class</code>关键字或<code>getClass()</code>方法。</li><li>使用<code>Class</code>对象获取类的信息，如字段、方法或构造方法，通过<code>getFields()</code>, <code>getDeclaredFields()</code>, <code>getMethods()</code>, <code>getDeclaredMethods()</code>, <code>getConstructors()</code>, <code>getDeclaredConstructors()</code>等方法。</li><li>创建类的对象，可以使用<code>Constructor</code>对象的<code>newInstance()</code>方法。</li><li>操作字段和调用方法，使用<code>Field</code>对象的<code>get()</code>和<code>set()</code>方法，以及<code>Method</code>对象的<code>invoke()</code>方法。</li><li>处理异常，因为反射可能引发<code>NoSuchMethodException</code>、<code>IllegalAccessException</code>等异常，需要适当捕获和处理。</li></ol><pre><code class="JAVA">public class Person {    private String name;    private int age;    public Person(String name, int age) {        this.name = name;        this.age = age;    }    public String getName() {        return name;    }    public int getAge() {        return age;    }    public void sayHello() {        System.out.println("Hello, my name is " + name);    }}</code></pre><pre><code class="JAVA">import java.lang.reflect.*;public class ReflectionExample {    public static void main(String[] args) throws Exception {        // 1. 获取类的Class对象        Class&lt;?&gt; personClass = Class.forName("Person");        // 2. 创建对象        Constructor&lt;?&gt; constructor = personClass.getConstructor(String.class, int.class);        Object person = constructor.newInstance("Alice", 30);        // 3. 访问字段        Field nameField = personClass.getDeclaredField("name");        nameField.setAccessible(true);        String name = (String) nameField.get(person);        Field ageField = personClass.getDeclaredField("age");        ageField.setAccessible(true);        int age = (int) ageField.get(person);        System.out.println("Name: " + name);        System.out.println("Age: " + age);        // 4. 调用方法        Method sayHelloMethod = personClass.getDeclaredMethod("sayHello");        sayHelloMethod.setAccessible(true);        sayHelloMethod.invoke(person);    }}</code></pre><h2 id="13-正则表达式"><a href="#13-正则表达式" class="headerlink" title="13 正则表达式"></a>13 正则表达式</h2><h2 id="13-1-用法"><a href="#13-1-用法" class="headerlink" title="13.1 用法"></a>13.1 用法</h2><ol><li>导入正则表达式的库：</li></ol><pre><code class="java">import java.util.regex.*;</code></pre><ol><li>创建正则表达式模式对象（Pattern对象）：</li></ol><pre><code class="java">Pattern pattern = Pattern.compile("正则表达式");</code></pre><ol><li>创建匹配器对象（Matcher对象）并使用模式匹配字符串：</li></ol><pre><code class="java">Matcher matcher = pattern.matcher("要匹配的字符串");</code></pre><ol><li>使用匹配器对象进行匹配操作，并根据需要获取匹配结果：</li></ol><pre><code class="java">if (matcher.find()) {    // 找到匹配    String matchedText = matcher.group(); // 获取匹配的文本    // 进行其他操作} else {    // 没有找到匹配}</code></pre><p>以下是一些常见的正则表达式用法示例：</p><ul><li><strong>查找匹配</strong>：使用 <code>find()</code> 方法查找字符串中是否包含匹配正则表达式的部分。</li></ul><pre><code class="java">Pattern pattern = Pattern.compile("\\d+"); // 匹配一个或多个数字Matcher matcher = pattern.matcher("12345 Hello 6789");while (matcher.find()) {    String matchedText = matcher.group();    System.out.println("匹配到: " + matchedText);}</code></pre><ul><li><strong>替换</strong>：使用 <code>replaceAll()</code> 方法将匹配的部分替换为指定的文本。</li></ul><pre><code class="java">String input = "Hello, World!";String result = input.replaceAll("World", "Java");System.out.println(result); // 输出: "Hello, Java!"</code></pre><ul><li><strong>分割</strong>：使用 <code>split()</code> 方法根据正则表达式分割字符串。</li></ul><pre><code class="java">String input = "apple,banana,grape";String[] fruits = input.split(",");for (String fruit : fruits) {    System.out.println(fruit);}</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/09/18/guai/"/>
      <url>/2023/09/18/guai/</url>
      
        <content type="html"><![CDATA[<h1 id="发现了一只乖乖猪"><a href="#发现了一只乖乖猪" class="headerlink" title="发现了一只乖乖猪~"></a>发现了一只乖乖猪~</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/09/18/text/"/>
      <url>/2023/09/18/text/</url>
      
        <content type="html"><![CDATA[<h1 id="大标题"><a href="#大标题" class="headerlink" title="大标题"></a>大标题</h1><h2 id="小标题"><a href="#小标题" class="headerlink" title="小标题"></a>小标题</h2><p>正文</p><pre><code class="c++">#include &lt;isotream&gt;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/09/18/hello-world/"/>
      <url>/2023/09/18/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new "My New Post"</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
