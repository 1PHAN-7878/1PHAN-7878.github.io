<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>链表相关练习汇总</title>
      <link href="/2024/03/13/%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%85%B3%E7%BB%83%E4%B9%A0%E6%B1%87%E6%80%BB/"/>
      <url>/2024/03/13/%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%85%B3%E7%BB%83%E4%B9%A0%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<p>来源为：LeetCode图解算法数据结构</p><h1 id="图书整理-I"><a href="#图书整理-I" class="headerlink" title="图书整理 I"></a>图书整理 I</h1><p>书店店员有一张链表形式的书单，每个节点代表一本书，节点中的值表示书的编号。为更方便整理书架，店员需要将书单倒过来排列，就可以从最后一本书开始整理，逐一将书放回到书架上。请倒序返回这个书单链表。</p><blockquote><p>示例 1：</p><p>输入：head = [3,6,4,1]</p><p>输出：[1,4,6,3]</p><p>提示：</p><p>0 &lt;= 链表长度 &lt;= 10000</p></blockquote><pre><code class="java">/** * Definition for singly-linked list. * public class ListNode { *     int val; *     ListNode next; *     ListNode() {} *     ListNode(int val) { this.val = val; } *     ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */import java.util.ArrayList;import java.util.List;class Solution {    public int[] reverseBookList(ListNode head) {        List&lt;Integer&gt; li = new ArrayList&lt;&gt;();        ListNode tem = head;        while(tem != null){            li.add(tem.val);            tem = tem.next;        }        // if (li.isEmpty()) return null; // 处理空链表的情况        // ListNode ans = new ListNode(li.get(li.size() - 1));        // for(int i = li.size() - 2; i &gt;= 0; i--){        //     ListNode ne = new ListNode(li.get(i));        //     ne.next = ans;        //     ans = ne;        // }        // return ans;        for(int i = 0; i &lt; li.size() / 2; i++){            Collections.swap(li, i, li.size() - i - 1);        }        int[] arr = li.stream().mapToInt(Integer::intValue).toArray();        return arr;    }}</code></pre><p>改进：</p><pre><code class="java">/** * Definition for singly-linked list. * public class ListNode { *     int val; *     ListNode next; *     ListNode() {} *     ListNode(int val) { this.val = val; } *     ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */import java.util.ArrayList;import java.util.List;class Solution {    public int[] reverseBookList(ListNode head) {        //count计数，倒序即可        int count = 0;        ListNode tem = head;        while(tem != null){            count++;            tem = tem.next;        }        int[] arr = new int[count];        tem = head;        while(tem != null){            arr[--count] = tem.val;            tem = tem.next;        }        return arr;    }}</code></pre><h1 id="删除链表节点"><a href="#删除链表节点" class="headerlink" title="删除链表节点"></a>删除链表节点</h1><blockquote><p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</p><p>返回删除后的链表的头节点。</p><p>示例 1:</p><p>输入: head = [4,5,1,9], val = 5<br>输出: [4,1,9]<br>解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.<br>示例 2:</p><p>输入: head = [4,5,1,9], val = 1<br>输出: [4,5,9]<br>解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</p></blockquote><pre><code class="java">/** * Definition for singly-linked list. * public class ListNode { *     int val; *     ListNode next; *     ListNode(int x) { val = x; } * } */class Solution {    public ListNode deleteNode(ListNode head, int val) {        ListNode tem = new ListNode();        tem = head;        //找到第一个看有么有，没有直接不彳亍        while(head != null){            if(head.val != val){                tem.val = head.val;                head = head.next;                break;            }            head = head.next;        }        ListNode ans = tem;//有了头部新建就好        while(head != null){            if(head.val != val){                ListNode li = new ListNode(head.val);                tem.next = li;                                tem = li;                            }            head = head.next;        }        return ans;    }}</code></pre><p>更新：</p><pre><code class="java">class Solution {    public ListNode deleteNode(ListNode head, int val) {        ListNode dummy = new ListNode(0);        //哑节点        dummy.next = head;        ListNode prev = dummy;                while (prev.next != null) {            if (prev.next.val == val) {                prev.next = prev.next.next; // 跳过当前节点            } else {//注意这里的else，极端情况下出现空指针。                prev = prev.next;            }        }                return dummy.next;    }}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习记录之vue</title>
      <link href="/2024/03/11/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E4%B9%8Bvue/"/>
      <url>/2024/03/11/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E4%B9%8Bvue/</url>
      
        <content type="html"><![CDATA[<h1 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h1><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;    &lt;script src="https://cdn.bootcdn.net/ajax/libs/vue/2.7.0/vue.js"&gt;&lt;/script&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id="container"&gt;                &lt;h1&gt;{{message}}&lt;/h1&gt;    &lt;/div&gt;        &lt;script&gt;        new Vue({            el: "#container",            data: {                message: "aaa"            }        });    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>一个 <code>&lt;h1&gt;</code> 标题元素，其中的文本内容通过 Vue 实例的 <code>message</code> 属性动态绑定。</p><ul><li><code>el: "#container"</code>：指定 Vue 实例的挂载点，即将 Vue 实例绑定到具有 <code>id</code> 为 <code>container</code> 的 <code>&lt;div&gt;</code> 元素上。</li><li><code>data: { message: "aaa" }</code>：定义了 Vue 实例的数据对象，其中包含一个名为 <code>message</code> 的属性，其初始值为 <code>"aaa"</code>。</li><li>当 Vue 实例挂载到页面后，<code>{{message}}</code> 中的 <code>message</code> 将会被替换为数据对象中 <code>message</code> 属性的值，即显示为 <code>"aaa"</code>。</li></ul><h2 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h2><ol><li><p><strong>插值表达式（Interpolation）：</strong></p><ul><li><p>插值表达式是 Vue.js 中最基本的数据绑定方式，它使用双大括号 <code>{{ }}</code> 将表达式包裹在 HTML 标签中。例如，<code>{{ message }}</code> 将会被替换为 Vue 实例中 <code>message</code> 属性的值。</p></li><li><p>插值表达式可以直接放置在 HTML 元素的文本内容、属性值、以及某些标签的特定属性内。</p></li><li><p>例如：</p><pre><code class="html">Copy code&lt;div&gt;  &lt;p&gt;{{ message }}&lt;/p&gt;  &lt;input type="text" v-model="message"&gt;&lt;/div&gt;</code></pre></li><li><p>在这个例子中，<code>{{ message }}</code> 将会被替换为 Vue 实例中 <code>message</code> 属性的值，并显示在 <code>&lt;p&gt;</code> 元素中。同时，<code>&lt;input&gt;</code> 元素的 <code>value</code> 属性将会与 <code>message</code> 属性保持同步。</p></li></ul></li><li><p><strong>指令（Directives）：</strong></p><ul><li><p>指令是以 <code>v-</code> 开头的特殊属性，它们提供了对 DOM 元素进行动态绑定的能力。指令的主要目的是响应式地将 Vue 实例中的数据绑定到 DOM 元素上。</p></li><li><p>Vue.js 提供了一系列内置指令，如 <code>v-bind</code>、<code>v-on</code>、<code>v-model</code> 等。</p></li><li><p><code>v-bind</code> 指令用于动态地绑定 HTML 属性，<code>v-on</code> 指令用于绑定事件处理器，<code>v-model</code> 指令用于实现双向数据绑定等。</p></li><li><p>例如：</p><pre><code class="html">htmlCopy code&lt;div&gt;  &lt;p v-bind:title="message"&gt;Hover me&lt;/p&gt;  &lt;button v-on:click="changeMessage"&gt;Change Message&lt;/button&gt;  &lt;input type="text" v-model="message"&gt;&lt;/div&gt;</code></pre></li><li><p>在这个例子中，<code>v-bind:title="message"</code> 将会动态地将 <code>&lt;p&gt;</code> 元素的 <code>title</code> 属性绑定到 Vue 实例中 <code>message</code> 属性的值上。<code>v-on:click="changeMessage"</code> 将会在按钮被点击时调用 Vue 实例中的 <code>changeMessage</code> 方法。<code>v-model="message"</code> 则实现了输入框的双向数据绑定，保持输入框中的值与 Vue 实例中 <code>message</code> 属性的值同步。</p></li></ul></li></ol><p>例子：</p><pre><code class="html">&lt;input type="text" v-model:value="name"&gt;&lt;input type="text" v-bind:value="name2"&gt;</code></pre><p>相当于会从data中获取数据，v-model会保持同步。</p><h1 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h1><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><ul><li><p>v-on:xxx或者 @xxx绑定事件。</p></li><li><p>事件回调在methods对象中，最终显示在vm上。</p></li><li><p>methods配置的函数不要用箭头函数。</p></li><li><p>例如<code>@click="func"</code>与<code>@click="func($event)"</code>相同，但是后者可以传参</p></li></ul><pre><code class="vue">&lt;button @click="showInfo2($event, 1)"&gt;show一下&lt;/button&gt;&lt;script&gt;        new Vue({            el: "#container",            data: {                message: "aaa",                name: "123",                name2: "456"            },            methods: {                showInfo1(event){                    console.log(event);                    alert("this is info1");                },                showInfo2(event, num){                    console.log(event);                    console.log(num);                    alert("this is info1");                }            }                    });    &lt;/script&gt;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jquery中的fadeIn/fadeOut与fadeTo区别</title>
      <link href="/2024/03/06/jquery%E4%B8%AD%E7%9A%84fadeIn-fadeOut%E4%B8%8EfadeTo%E5%8C%BA%E5%88%AB/"/>
      <url>/2024/03/06/jquery%E4%B8%AD%E7%9A%84fadeIn-fadeOut%E4%B8%8EfadeTo%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="问题发现"><a href="#问题发现" class="headerlink" title="问题发现"></a>问题发现</h1><p>打算创建表格，控制删除与增加时添加渐变的效果，本能的使用了fadein，fadeout，但发现会更改display的css属性，由于我使用了bootstrap框架，更改这个属性会让表格变得无法看到。所以继而更换了fadeto，又发现fadeto是通过更改css的opacity属性实现的效果。如此一来，不会对本身的框架产生影响。</p><h1 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h1><ol><li><strong>fadeIn()</strong>: 这个方法用于将元素淡入显示。当元素最初处于隐藏状态时（比如通过CSS设置<code>display: none</code>），调用<code>fadeIn()</code>方法将使其逐渐变得可见。它不需要传递透明度参数，因为它会自动将元素的透明度从0逐渐增加到1。</li><li><strong>fadeOut()</strong>: 这个方法与<code>fadeIn()</code>相反，用于将元素淡出隐藏。调用<code>fadeOut()</code>方法将使元素逐渐变得不可见，并最终完全隐藏。同样，它不需要传递透明度参数，因为它会自动将元素的透明度从1逐渐减少到0。</li><li><strong>fadeTo()</strong>: 与前两者不同，<code>fadeTo()</code>方法允许您直接指定元素的目标透明度。您需要传递两个参数：目标透明度值（0到1之间的数字）和动画持续时间（以毫秒为单位）。调用<code>fadeTo()</code>将使元素的透明度从当前值渐变到指定的目标透明度值。</li></ol><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><pre><code class="JavaScript">$("#searchresult tbody").append(newTr);//对应关系是不同的//opacity是fadeTo//display是displaynewTr.css("opacity", "0");//newTr.fadeIn(1000);newTr.fadeTo(1000, 1);</code></pre><pre><code class="JavaScript">$("#clear").click(function (){  //fadeinout更改属性，用fadeTo只改变透明度  // $("#searchresult tbody").empty().fadeOut(1000, function (){  //   $(this).css("display", "block");  // });  $("#searchresult tbody").fadeTo(1000, 0, function (){    $(this).empty();    //默认的opacity设置为0了，后续添加新的表格不显示了    $(this).css("opacity", "1");  })});</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pr手写字效果</title>
      <link href="/2024/03/03/pr%E6%89%8B%E5%86%99%E5%AD%97%E6%95%88%E6%9E%9C/"/>
      <url>/2024/03/03/pr%E6%89%8B%E5%86%99%E5%AD%97%E6%95%88%E6%9E%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="手写字效果"><a href="#手写字效果" class="headerlink" title="手写字效果"></a>手写字效果</h1><p><img src="/../images/image-20240303194245652.png" alt="image-20240303194245652"></p><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><p>1.找到相应的文字，添加书写效果。</p><p><img src="/../images/image-20240303194532416.png" alt="image-20240303194532416"></p><p>2.添加后根据关键帧调节相应的位置。显示文字。</p><p><img src="/../images/image-20240303194614641.png" alt="image-20240303194614641"></p><p>3.选择绘制样式作为显示原始图像。</p><p><img src="/../images/image-20240303194630801.png" alt="image-20240303194630801"></p>]]></content>
      
      
      
        <tags>
            
            <tag> pr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pr进度条效果</title>
      <link href="/2024/02/16/pr%E8%BF%9B%E5%BA%A6%E6%9D%A1%E6%95%88%E6%9E%9C/"/>
      <url>/2024/02/16/pr%E8%BF%9B%E5%BA%A6%E6%9D%A1%E6%95%88%E6%9E%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="进度条效果"><a href="#进度条效果" class="headerlink" title="进度条效果"></a>进度条效果</h1><p><img src="/../images/image-20240216191139075.png" alt="image-20240216191139075"></p><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><p>选择旧版标题中的圆角矩形，添加阴影。</p><p><img src="/../images/image-20240216191220511.png" alt="image-20240216191220511"></p><p>这一份去掉中间的填充，透明度为0。赋值一份拖到上面，把透明度重新改为100。两个重叠。</p><p><img src="/../images/image-20240216191321049.png" alt="image-20240216191321049"></p><p>最后将上面的添加裁剪效果，逐渐产生进度条的效果。</p><p><img src="/../images/image-20240216191357443.png" alt="image-20240216191357443"></p>]]></content>
      
      
      
        <tags>
            
            <tag> pr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pr分屏效果</title>
      <link href="/2024/02/16/pr%E5%88%86%E5%B1%8F%E6%95%88%E6%9E%9C/"/>
      <url>/2024/02/16/pr%E5%88%86%E5%B1%8F%E6%95%88%E6%9E%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="分屏效果"><a href="#分屏效果" class="headerlink" title="分屏效果"></a>分屏效果</h1><p><img src="/../images/image-20240216140608189.png" alt="image-20240216140608189"></p><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><p>找到素材</p><p><img src="/../images/image-20240216140627414.png" alt="image-20240216140627414"></p><p>添加线性擦除效果</p><p><img src="/../images/image-20240216140728983.png" alt="image-20240216140728983"></p><p>从矩形设置旧版标题</p><p><img src="/../images/image-20240216141047264.png" alt="image-20240216141047264"></p>]]></content>
      
      
      
        <tags>
            
            <tag> pr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pr分屏弹出效果</title>
      <link href="/2024/02/02/pr%E5%88%86%E5%B1%8F%E5%BC%B9%E5%87%BA%E6%95%88%E6%9E%9C/"/>
      <url>/2024/02/02/pr%E5%88%86%E5%B1%8F%E5%BC%B9%E5%87%BA%E6%95%88%E6%9E%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="分屏弹出效果"><a href="#分屏弹出效果" class="headerlink" title="分屏弹出效果"></a>分屏弹出效果</h1><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><p>1.选择基本图形（没有就在窗口新建），新建一个矩形，调整。</p><p><img src="/../images/image-20240202140214212.png" alt="image-20240202140214212"></p><p>2.选择轨道遮罩键。</p><p><img src="/../images/image-20240202140302680.png" alt="image-20240202140302680"></p><p>3.多选择几组素材。</p><p>每一组作为一个嵌套序列。</p><p><img src="/../images/image-20240202140459345.png" alt="image-20240202140459345"></p><p>​4.按时间进行排列。</p><p><img src="/../images/image-20240202142145929.png" alt="image-20240202142145929"></p><h1 id="成果"><a href="#成果" class="headerlink" title="成果"></a>成果</h1><p><img src="/../images/image-20240202142203984.png" alt="image-20240202142203984"></p>]]></content>
      
      
      
        <tags>
            
            <tag> pr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pr打字机效果</title>
      <link href="/2024/02/02/pr%E6%89%93%E5%AD%97%E6%9C%BA%E6%95%88%E6%9E%9C/"/>
      <url>/2024/02/02/pr%E6%89%93%E5%AD%97%E6%9C%BA%E6%95%88%E6%9E%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="打字机效果"><a href="#打字机效果" class="headerlink" title="打字机效果"></a>打字机效果</h1><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><p>1.添加一个旧版标题，输入要写的文字。</p><p><img src="/../images/image-20240202131656295.png" alt="image-20240202131656295"></p><p>2.找到线性擦除效果。</p><p><img src="/../images/image-20240202132220802.png" alt="image-20240202132220802"></p><p>3.擦除角度选择-90°，添加关键帧让其出现。<img src="/../images/image-20240202132619981.png" alt="image-20240202132619981"></p><h1 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h1><p><img src="/../images/image-20240202132636616.png" alt="image-20240202132636616"></p>]]></content>
      
      
      
        <tags>
            
            <tag> pr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring之MVC</title>
      <link href="/2024/01/30/Spring%E4%B9%8BMVC/"/>
      <url>/2024/01/30/Spring%E4%B9%8BMVC/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h1><p>基于Spring的javaweb</p><h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><h2 id="添加依赖，不要加这么多"><a href="#添加依赖，不要加这么多" class="headerlink" title="添加依赖，不要加这么多"></a>添加依赖，不要加这么多</h2><pre><code class="xml">&lt;dependencies&gt;    &lt;!-- Spring MVC --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;        &lt;version&gt;5.3.10&lt;/version&gt; &lt;!-- 使用适用于 Java 17 的 Spring 版本 --&gt;    &lt;/dependency&gt;    &lt;!-- Spring Context --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;        &lt;version&gt;5.3.10&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- Spring Core --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-core&lt;/artifactId&gt;        &lt;version&gt;5.3.10&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- Spring Beans --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;        &lt;version&gt;5.3.10&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- Spring Web --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-web&lt;/artifactId&gt;        &lt;version&gt;5.3.10&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- Spring Expression Language (SpEL) --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-expression&lt;/artifactId&gt;        &lt;version&gt;5.3.10&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><pre><code class="xml">    &lt;dependency&gt;      &lt;groupId&gt;javax.servlet&lt;/groupId&gt;      &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;      &lt;version&gt;4.0.1&lt;/version&gt;      &lt;scope&gt;provided&lt;/scope&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;      &lt;version&gt;5.2.10.RELEASE&lt;/version&gt; &lt;!-- 使用适用于 Java 11 的 Spring 版本 --&gt;    &lt;/dependency&gt;</code></pre><h2 id="创建SpringMVC控制器"><a href="#创建SpringMVC控制器" class="headerlink" title="创建SpringMVC控制器"></a>创建SpringMVC控制器</h2><pre><code class="java">package com.iphan.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;//控制器@Controllerpublic class UserController {    //匹配路径    @RequestMapping("/test")    //表示返回值写入响应体    @ResponseBody    public String save(){        System.out.println("user is saving");        return "{'info': 'SringMVC'}";    }}</code></pre><h2 id="配置SpringConfig"><a href="#配置SpringConfig" class="headerlink" title="配置SpringConfig"></a>配置SpringConfig</h2><pre><code class="java">package com.iphan.config;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;@Configuration@ComponentScan({"com.iphan.controller"})public class SpringMvcConfig {}</code></pre><h2 id="配置SpringMvcConfig"><a href="#配置SpringMvcConfig" class="headerlink" title="配置SpringMvcConfig"></a>配置SpringMvcConfig</h2><pre><code class="java">package com.iphan.config;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.EnableWebMvc;@Configuration@ComponentScan({"com.iphan.controller", "com.iphan.config"})@EnableWebMvcpublic class SpringMvcConfig {}</code></pre><h2 id="配置Servlet容器Config"><a href="#配置Servlet容器Config" class="headerlink" title="配置Servlet容器Config"></a>配置Servlet容器Config</h2><pre><code class="java">package com.iphan.config;import org.springframework.stereotype.Component;import org.springframework.web.context.WebApplicationContext;import org.springframework.web.context.support.AnnotationConfigWebApplicationContext;import org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;import org.springframework.web.servlet.support.AbstractDispatcherServletInitializer;//通过注解类完成注册public class ServletContainersInitConfig extends AbstractAnnotationConfigDispatcherServletInitializer {    @Override    protected Class&lt;?&gt;[] getRootConfigClasses() {        return new Class[0];    }        @Override    protected Class&lt;?&gt;[] getServletConfigClasses() {        return new Class[]{SpringMvcConfig.class};    }    @Override    protected String[] getServletMappings() {        return new String[]{"/"};    }}////public class ServletContainersInitConfig extends AbstractDispatcherServletInitializer {//    @Override//    protected WebApplicationContext createServletApplicationContext() {//        AnnotationConfigWebApplicationContext ctx = new AnnotationConfigWebApplicationContext();//////        AnnotationConfigWebApplicationContext ctx;//        ctx.register(SpringMvcConfig.class);//        return ctx;//    }////    @Override//    protected String[] getServletMappings() {//        return new String[]{"/"};//    }////    @Override//    protected WebApplicationContext createRootApplicationContext() {//        return null;//    }//}</code></pre><h2 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h2><p>访问相应路径，SpringMvc处理请求并返回。</p><p><img src="/../images/image-20240131141757725.png" alt="image-20240131141757725"></p><h1 id="Bean控制"><a href="#Bean控制" class="headerlink" title="Bean控制"></a>Bean控制</h1><p><img src="/../images/image-20240131141812443.png" alt="image-20240131141812443"></p><p><img src="/../images/image-20240131142107077.png" alt="image-20240131142107077"></p><p>在SpringConfig中完成对于业务层数据层的Bean控制</p><pre><code class="java">package com.iphan.config;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;@Configuration@ComponentScan({"com.iphan.service","com.iphan.dao"})public class SpringConfig {}</code></pre><p>在SpringMvcConfig中完成表现层控制</p><pre><code class="java">package com.iphan.config;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.EnableWebMvc;@Configuration@ComponentScan("com.iphan.controller")public class SpringMvcConfig {}</code></pre><p>进行注册</p><pre><code class="java">package com.iphan.config;import org.springframework.stereotype.Component;import org.springframework.web.context.WebApplicationContext;import org.springframework.web.context.support.AnnotationConfigWebApplicationContext;import org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;import org.springframework.web.servlet.support.AbstractDispatcherServletInitializer;public class ServletContainersInitConfig extends AbstractAnnotationConfigDispatcherServletInitializer {    @Override    protected Class&lt;?&gt;[] getRootConfigClasses() {        return new Class[]{SpringConfig.class};    }    @Override    protected Class&lt;?&gt;[] getServletConfigClasses() {        return new Class[]{SpringMvcConfig.class};    }    @Override    protected String[] getServletMappings() {        return new String[]{"/"};    }}////public class ServletContainersInitConfig extends AbstractDispatcherServletInitializer {//    @Override//    protected WebApplicationContext createServletApplicationContext() {//        AnnotationConfigWebApplicationContext ctx = new AnnotationConfigWebApplicationContext();//////        AnnotationConfigWebApplicationContext ctx;//        ctx.register(SpringMvcConfig.class);//        return ctx;//    }////    @Override//    protected String[] getServletMappings() {//        return new String[]{"/"};//    }////    @Override//    protected WebApplicationContext createRootApplicationContext() {//        return null;//    }//}</code></pre><h1 id="请求映射路径"><a href="#请求映射路径" class="headerlink" title="请求映射路径"></a>请求映射路径</h1><p>如果目前有很多的controller，每一个都有重复的功能，访问路径相同，例如save，delete。可以再类前注解加上相应类名区分，访问时也要加上类的路径以及方法的路径。</p><pre><code class="java">package com.iphan.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;@Controller//加上类的访问路径@RequestMapping("/user")public class UserController {    @RequestMapping("/save")    @ResponseBody    public String save(String name){        System.out.println("this is save");        System.out.println(name);        return "{'model':'spring'}";    }}</code></pre><h1 id="接受参数"><a href="#接受参数" class="headerlink" title="接受参数"></a>接受参数</h1><p><code>@RequestParam</code></p><p><code>@RequestBody</code></p><p><code>@PathVariable</code></p><p><img src="/../images/image-20240131202454898.png" alt="image-20240131202454898"></p><p>直接写方法中的参数即可。可以通过post或者get请求获得。</p><ul><li>GET 请求：<code>/user/save?name=John</code></li><li>POST 请求（使用表单数据或 JSON 数据）。</li></ul><p>中文编码问题，在连接配置中，增加过滤器。</p><pre><code class="java">public class ServletContainersInitConfig extends AbstractAnnotationConfigDispatcherServletInitializer {    @Override    protected Class&lt;?&gt;[] getRootConfigClasses() {        return new Class[]{SpringConfig.class};    }    @Override    protected Class&lt;?&gt;[] getServletConfigClasses() {        return new Class[]{SpringMvcConfig.class};    }    @Override    protected String[] getServletMappings() {        return new String[]{"/"};    }    @Override    protected Filter[] getServletFilters() {        CharacterEncodingFilter filter = new CharacterEncodingFilter();        filter.setEncoding("UTF-8");        return new Filter[]{filter};    }}</code></pre><p>1.普通参数，请求名与形参相同，直接接受。</p><p>2.普通参数，请求名与形参不相同，使用参数绑定。</p><pre><code class="java">@ResponseBody@RequestMapping(value = "/testdiffname")public String testdiffname(@RequestParam("name") String diff){    System.out.println(diff);    return "it 's ok";}</code></pre><p>3.pojo类，请求参数与形参相同。</p><pre><code class="java">@ResponseBody@RequestMapping(value = "/testpojo")public String testpojo(Man man){    System.out.println(man);    return "ok";}</code></pre><pre><code class="java">package com.iphan.pojo;public class Man {    public String name;    public int id;    public String getName() {        return name;    }    @Override    public String toString() {        return "Man{" +                "name='" + name + '\'' +                ", id=" + id +                '}';    }    public void setName(String name) {        this.name = name;    }    public int getId() {        return id;    }    public void setId(int id) {        this.id = id;    }    public Man(String name, int id) {        this.name = name;        this.id = id;    }}</code></pre><p>4.数组，直接形参与变量名对应即可。</p><p>5.List，接受时前加<code>@RequestParam</code></p><p>6.JSON类型</p><ul><li><p>添加依赖</p><pre><code class="xml">&lt;dependency&gt;  &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;  &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;  &lt;version&gt;2.13.0&lt;/version&gt;&lt;/dependency&gt;</code></pre></li><li><p>==开始<code>@EnableWebMvc</code>==</p></li><li><p>设置JSON数据</p></li><li><p><img src="/../images/image-20240131162216162.png" alt="image-20240131162216162"></p></li><li><p>JSON接受的pojo类中要有无参构造</p><pre><code class="java">public Man(){};</code></pre></li><li><pre><code class="java">@ResponseBody@RequestMapping(value = "/testjson")public String testjson(@RequestBody Man man){    return "this JSON ok";}</code></pre></li></ul><p>7.日期</p><p><img src="/../images/image-20240131170118252.png" alt="image-20240131170118252"></p><h1 id="REST风格"><a href="#REST风格" class="headerlink" title="REST风格"></a>REST风格</h1><p>表现形式状态转换。</p><ul><li>隐藏资源的访问，无法通过URL知道资源是什么，安全性。</li><li>书写简化。</li></ul><p>通过不同的method进行确定。</p><p>==模块名一般使用/****s==复数形式加以描述</p><p><img src="/../images/image-20240131195531382.png" alt="image-20240131195531382"></p><pre><code class="java">package com.iphan.controller;import com.iphan.pojo.Book;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.*;import java.util.ArrayList;import java.util.List;//表示了@Controller以及@ResponseBody@RestController@RequestMapping("/books")public class BookController {    //表示是post请求，用于添加    @PostMapping()    public String addBook(@RequestBody Book book){        System.out.println("book is added!");        System.out.println(book);        return "book add is ok";    }    //GET表示查询请求    @GetMapping()    public List&lt;Book&gt; showAll(){        Book book1 = new Book("book1", 1);        Book book2 = new Book("Book2:)", 2);        List&lt;Book&gt; list = new ArrayList&lt;&gt;();        list.add(book1);        list.add(book2);        System.out.println("books are found");        return list;    }    //Delete表示删除请求    @DeleteMapping("/{id}")    public String deleteBook(@PathVariable int id){        System.out.println("delete " + id +"is ok");        return "delete" + id;    }    //Put表示修改请求    @PutMapping()    public String setBook(@RequestBody Book book){        System.out.println("set book " + book);        return "book set have done";    }}</code></pre><h1 id="资源访问筛选"><a href="#资源访问筛选" class="headerlink" title="资源访问筛选"></a>资源访问筛选</h1><p>一些静态资源不希望经过DispatcherServlet，而是直接由容器处理，可以通过配置 <code>ResourceHandler</code> 来实现。这样，当请求匹配到静态资源路径时，容器将直接提供这些资源，而不需要通过 DispatcherServlet。</p><pre><code class="java">package com.iphan.config;import org.springframework.stereotype.Component;import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;//作为配置类@Componentpublic class SpringMvcSupport extends WebMvcConfigurationSupport {    @Override    protected void addResourceHandlers(ResourceHandlerRegistry registry) {        registry.addResourceHandler("/hello/**").addResourceLocations("/hello/");    }}</code></pre><p>SpringMvcConfig中进行扫描。</p><pre><code class="java">package com.iphan.config;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.EnableWebMvc;@Configuration@ComponentScan({"com.iphan.controller", "com.iphan.config"})@EnableWebMvcpublic class SpringMvcConfig {}</code></pre><p><img src="/../images/image-20240131204002584.png" alt="image-20240131204002584"></p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pr玻璃装饰效果</title>
      <link href="/2024/01/28/pr%E7%8E%BB%E7%92%83%E8%A3%85%E9%A5%B0%E6%95%88%E6%9E%9C/"/>
      <url>/2024/01/28/pr%E7%8E%BB%E7%92%83%E8%A3%85%E9%A5%B0%E6%95%88%E6%9E%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="玻璃装饰"><a href="#玻璃装饰" class="headerlink" title="玻璃装饰"></a>玻璃装饰</h1><p><img src="/../images/image-20240128144621941.png" alt="image-20240128144621941"></p><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><p>1.新建旧版字幕，选择矩形，取消填充，增加内描边。<img src="/../images/image-20240128144718759.png" alt="image-20240128144718759"></p><p>2.复制一份，添加轨道遮罩键。</p><p><img src="/../images/image-20240128145325571.png" alt="image-20240128145325571"></p><p>3.添加斜面alpha效果，产生玻璃的感觉。</p><p><img src="/../images/image-20240128145357332.png" alt="image-20240128145357332"></p><p>4.增加相应文字等。</p><p><img src="/../images/image-20240128150648636.png" alt="image-20240128150648636"></p>]]></content>
      
      
      
        <tags>
            
            <tag> pr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pr玻璃文字效果</title>
      <link href="/2024/01/28/pr%E7%8E%BB%E7%92%83%E6%96%87%E5%AD%97%E6%95%88%E6%9E%9C/"/>
      <url>/2024/01/28/pr%E7%8E%BB%E7%92%83%E6%96%87%E5%AD%97%E6%95%88%E6%9E%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="玻璃文字"><a href="#玻璃文字" class="headerlink" title="玻璃文字"></a>玻璃文字</h1><p><img src="/../images/image-20240128142454002.png" alt="image-20240128142454002"></p><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><p>1.复制一份，添加翻转效果</p><p><img src="/../images/image-20240128142738505.png" alt="image-20240128142738505"></p><p>2.添加文字</p><p><img src="/../images/image-20240128142908384.png" alt="image-20240128142908384"></p><p>3.选择轨道遮罩效果为视频添加。</p><p><img src="/../images/image-20240128143056040.png" alt="image-20240128143056040"></p><p>4.增强效果，选择斜面alpha。</p><p><img src="/../images/image-20240128143215518.png" alt="image-20240128143215518"></p><p>进行调整即可，边缘会更加明显。</p><h1 id="成品"><a href="#成品" class="headerlink" title="成品"></a>成品</h1><p><img src="/../images/image-20240128144317956.png" alt="image-20240128144317956"></p>]]></content>
      
      
      
        <tags>
            
            <tag> pr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pr玻璃画面分隔转场</title>
      <link href="/2024/01/28/pr%E7%8E%BB%E7%92%83%E7%94%BB%E9%9D%A2%E5%88%86%E9%9A%94%E8%BD%AC%E5%9C%BA/"/>
      <url>/2024/01/28/pr%E7%8E%BB%E7%92%83%E7%94%BB%E9%9D%A2%E5%88%86%E9%9A%94%E8%BD%AC%E5%9C%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="玻璃分隔"><a href="#玻璃分隔" class="headerlink" title="玻璃分隔"></a>玻璃分隔</h1><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><p>1.新建一个颜色遮罩为他添加蒙版</p><p><img src="/../images/image-20240128115744616.png" alt="image-20240128115744616"></p><p>2.调整蒙版的形状</p><p><img src="/../images/image-20240128115816991.png" alt="image-20240128115816991"></p><p>3.添加效果，轨道遮罩。并进行错位排列</p><p><img src="/../images/image-20240128142213894.png" alt="image-20240128142213894"></p><p>4.设置运动</p><p><img src="/../images/image-20240128142241123.png" alt="image-20240128142241123"></p><p>5.调整出现时机。</p><p><img src="/../images/image-20240128142259554.png" alt="image-20240128142259554"></p><h1 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h1><p><img src="/../images/image-20240128142313367.png" alt="image-20240128142313367"></p>]]></content>
      
      
      
        <tags>
            
            <tag> pr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pr玻璃划过效果</title>
      <link href="/2024/01/28/pr%E7%8E%BB%E7%92%83%E5%88%92%E8%BF%87%E6%95%88%E6%9E%9C/"/>
      <url>/2024/01/28/pr%E7%8E%BB%E7%92%83%E5%88%92%E8%BF%87%E6%95%88%E6%9E%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="玻璃划过"><a href="#玻璃划过" class="headerlink" title="玻璃划过"></a>玻璃划过</h1><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><p>1.文件-&gt;新建-&gt;旧版标题</p><p><img src="/../images/image-20240128113653858.png" alt="image-20240128113653858"></p><p>做出上述效果，同时记得更改为纯黑色。</p><p>2.放入视频中并且复制一份。<img src="/../images/image-20240128113935693.png" alt="image-20240128113935693"></p><p>3.为下方添加轨道遮罩键。同时将其缩放调整。</p><p><img src="/../images/image-20240128114050540.png" alt="image-20240128114050540"></p><p>4.完善，增加投影效果到视频中。</p><p><img src="/../images/image-20240128114224828.png" alt="image-20240128114224828"></p><p>5.调节遮罩的位置。</p><p><img src="/../images/image-20240128114504181.png" alt="image-20240128114504181"></p><h1 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h1><p><img src="/../images/image-20240128114454786.png" alt="image-20240128114454786"></p>]]></content>
      
      
      
        <tags>
            
            <tag> pr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pr百叶窗效果</title>
      <link href="/2024/01/25/pr%E7%99%BE%E5%8F%B6%E7%AA%97%E6%95%88%E6%9E%9C/"/>
      <url>/2024/01/25/pr%E7%99%BE%E5%8F%B6%E7%AA%97%E6%95%88%E6%9E%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="百叶窗效果"><a href="#百叶窗效果" class="headerlink" title="百叶窗效果"></a>百叶窗效果</h1><p>是利用颜色的遮罩完成的。</p><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><p>1.创建一个颜色遮罩。</p><p><img src="/../images/image-20240125220407881.png" alt="image-20240125220407881"></p><p>2.再对遮罩添加百叶窗效果。</p><p><img src="/../images/image-20240125221133126.png" alt="image-20240125221133126"></p><p>3.调整百叶窗效果，让其与视频相协调。</p><p><img src="/../images/image-20240125221236451.png" alt="image-20240125221236451"></p><p><img src="/../images/image-20240125221248010.png" alt="image-20240125221248010"></p>]]></content>
      
      
      
        <tags>
            
            <tag> pr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习记录之python</title>
      <link href="/2024/01/25/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E4%B9%8Bpython/"/>
      <url>/2024/01/25/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E4%B9%8Bpython/</url>
      
        <content type="html"><![CDATA[<h1 id="1-入"><a href="#1-入" class="headerlink" title="1 入"></a>1 入</h1><pre><code class="python">print('Hello World!')</code></pre><p>python可视化：pythontutor.com</p><h2 id="1-1-注释"><a href="#1-1-注释" class="headerlink" title="1.1 注释"></a>1.1 注释</h2><ul><li><p>单行注释 #</p></li><li><p>多行注释 ‘’’ “””</p><pre><code class="python"># 这是单行注释'''多行注释'''"""多行注释"""</code></pre></li></ul><h2 id="1-2-拷贝"><a href="#1-2-拷贝" class="headerlink" title="1.2 拷贝"></a>1.2 拷贝</h2><ul><li><p>浅拷贝（Shallow Copy）：浅拷贝创建一个新的对象，但是它只复制了原始对象中的引用。也就是说，新对象和原始对象<strong>共享相同的数据</strong>。浅拷贝通常适用于简单的数据结构，如列表、字典等。（一个修改了，另一个也修改了）</p><pre><code class="python">import copy# 列表的浅拷贝list1 = [1, 2, 3]list2 = copy.copy(list1)print(list2)  # 输出 [1, 2, 3]# 字典的浅拷贝dict1 = {'name': 'Alice', 'age': 20}dict2 = copy.copy(dict1)print(dict2)  # 输出 {'name': 'Alice', 'age': 20}</code></pre></li><li><p>深拷贝（Deep Copy）：深拷贝创建一个完全独立的新对象，并且递归地复制原始对象及其所有嵌套的对象。深拷贝在处理复杂的数据结构时非常有用，如嵌套的列表、字典等。</p><pre><code class="python">import copy# 列表的深拷贝list1 = [1, 2, [3, 4]]list2 = copy.deepcopy(list1)print(list2)  # 输出 [1, 2, [3, 4]]# 字典的深拷贝dict1 = {'name': 'Alice', 'info': {'age': 20}}dict2 = copy.deepcopy(dict1)print(dict2)  # 输出 {'name': 'Alice', 'info': {'age': 20}}</code></pre></li></ul><h1 id="2-变量"><a href="#2-变量" class="headerlink" title="2 变量"></a>2 变量</h1><p>无需定义变量类型</p><pre><code class="python">name = "chichu"age = 18num = 4.3a, b = 23, 4.2</code></pre><p>输出</p><pre><code class="python">print(name1, name2) # 默认空格分隔print(name1, name2, sep = '$$')  # 分隔是$$print(name1, name2, end='333') # 默认结尾'\n'</code></pre><h2 id="2-1-变量类型"><a href="#2-1-变量类型" class="headerlink" title="2.1 变量类型"></a>2.1 变量类型</h2><ul><li><p>Number 数字</p><ul><li>int float bool</li></ul><pre><code class="python">a = 1, b = 2, bool = True</code></pre></li><li><p>String </p><pre><code class="python">str1 = 'H1'str2 = '''duoduoshaos'''</code></pre></li><li><p>List 列表</p></li><li><p>Tuple 元组</p></li><li><p>Dict 字典</p></li><li><p>Set 集合</p></li></ul><h2 id="2-2-输入"><a href="#2-2-输入" class="headerlink" title="2.2 输入"></a>2.2 输入</h2><p>input 函数</p><pre><code class="python">name = input('请输入您的姓名：')print(f'Hello, {name}!')</code></pre><h2 id="2-3-强制类型转化"><a href="#2-3-强制类型转化" class="headerlink" title="2.3 强制类型转化"></a>2.3 强制类型转化</h2><ul><li><p>整形转化</p><pre><code class="python">x = int(3.14)  # 将浮点型转换为整型，结果为 3y = int('123')  # 将字符串转换为整型，结果为 123</code></pre></li><li><p>浮点型转化</p><pre><code>x = float(3)  # 将整型转换为浮点型，结果为 3.0y = float('3.14')  # 将字符串转换为浮点型，结果为 3.14</code></pre></li><li><p>字符串</p><pre><code class="python">x = str(123)  # 将整型转换为字符串，结果为 '123'y = str(3.14)  # 将浮点型转换为字符串，结果为 '3.14'</code></pre></li><li><p>列表</p><pre><code class="python">str1 = 'hello1'print(list(str1)) # ['h', 'e', 'l', 'l', 'o', '1']</code></pre></li></ul><h2 id="2-4-隐式转换"><a href="#2-4-隐式转换" class="headerlink" title="2.4 隐式转换"></a>2.4 隐式转换</h2><ul><li><p>整形浮点型</p><pre><code class="python">a = 10b = 3.14c = a + b  # a 会被自动转换为 10.0，结果为 13.14</code></pre></li><li><p>字符串与数字型</p><pre><code class="python">a = '10'b = 3.14c = a + b  # a 会被自动转换为整型，结果为 13.14</code></pre></li><li><p>布尔型与整型</p><pre><code class="python">a = Trueb = 3c = a + b  # True 会被自动转换为整型 1，结果为 4</code></pre></li></ul><h1 id="3-运算"><a href="#3-运算" class="headerlink" title="3 运算"></a>3 运算</h1><h2 id="3-1-算术运算"><a href="#3-1-算术运算" class="headerlink" title="3.1 算术运算"></a>3.1 算术运算</h2><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>+</td><td>加法</td></tr><tr><td>-</td><td>减法</td></tr><tr><td>*</td><td>乘法</td></tr><tr><td>/</td><td>除法</td></tr><tr><td>%</td><td>取余</td></tr><tr><td>**</td><td>幂运算</td></tr><tr><td>//</td><td>整数除法（向下取整）</td></tr></tbody></table><p>==python中没有a++，a–==</p><h2 id="3-2-关系运算符"><a href="#3-2-关系运算符" class="headerlink" title="3.2 关系运算符"></a>3.2 关系运算符</h2><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>==</td><td>检查两个值是否相等</td></tr><tr><td>!=</td><td>检查两个值是否不相等</td></tr><tr><td>&gt;</td><td>检查左操作数是否大于右操作数</td></tr><tr><td>&lt;</td><td>检查左操作数是否小于右操作数</td></tr><tr><td>&gt;=</td><td>检查左操作数是否大于或等于右操作数</td></tr><tr><td>&lt;=</td><td>检查左操作数是否小于或等于右操作数</td></tr></tbody></table><h2 id="3-3-成员运算符"><a href="#3-3-成员运算符" class="headerlink" title="3.3 成员运算符"></a>3.3 成员运算符</h2><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>in</td><td>如果在序列中找到具有相应值的项，则为 True</td></tr><tr><td>not in</td><td>如果在序列中没有找到具有相应值的项，则为 True</td></tr><tr><td>is</td><td>判断两个变量是否引用了同一个对象（通常用于判断 None 变量）</td></tr><tr><td>is not</td><td>判断两个变量是否没有引用同一个对象</td></tr></tbody></table><pre><code class="python"># 检查元素是否在列表中fruits = ["apple", "banana", "cherry"]print("apple" in fruits)  # 输出 True# 检查键是否在字典中ages = {"Tom": 18, "Jack": 20, "Mary": 22}print("Tom" in ages)  # 输出 Trueprint("John" not in ages)  # 输出 True# 检查变量是否为 Nonex = Noneprint(x is None)  # 输出 True</code></pre><h2 id="3-4-逻辑运算符"><a href="#3-4-逻辑运算符" class="headerlink" title="3.4 逻辑运算符"></a>3.4 逻辑运算符</h2><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>and</td><td>如果两个操作数都为 True，则计算结果为 True</td></tr><tr><td>or</td><td>如果两个操作数中有任意一个为 True，则计算结果为 True</td></tr><tr><td>not</td><td>取反操作，如果操作数为 True，则返回 False</td></tr></tbody></table><pre><code class="python"># and 运算符，例如判断数值是否在指定范围内x = 5print(x &gt; 0 and x &lt; 10)  # 输出 True# or 运算符，例如判断字符串是否包含某个字符text = "Hello, world!"print("e" in text or "a" in text)  # 输出 True# not 运算符，例如取反操作is_valid = Trueprint(not is_valid)  # 输出 False</code></pre><h1 id="4-分支循环"><a href="#4-分支循环" class="headerlink" title="4 分支循环"></a>4 分支循环</h1><h2 id="4-1-分支结构"><a href="#4-1-分支结构" class="headerlink" title="4.1 分支结构"></a>4.1 分支结构</h2><pre><code class="python">score = 75if score &gt;= 90:    grade = 'A'elif score &gt;= 80:    grade = 'B'elif score &gt;= 70:    grade = 'C'elif score &gt;= 60:    grade = 'D'else:    grade = 'F'print("成绩等级是：", grade)</code></pre><h2 id="4-2-循环"><a href="#4-2-循环" class="headerlink" title="4.2 循环"></a>4.2 循环</h2><pre><code class="python">count = 0while count &lt; 5:    print("当前计数: ", count)    count += 1print("循环结束")</code></pre><pre><code class="python">fruits = ["apple", "banana", "cherry"]for fruit in fruits:    print(fruit)fruits = ["apple", "banana", "cherry"]for index, fruit in enumerate(fruits):    print(index, fruit)for i in range(5): # 0 ~ 4    print(i)for i in range(1, 6) # 1 ~ 5</code></pre><h1 id="5-字符串"><a href="#5-字符串" class="headerlink" title="5 字符串"></a>5 字符串</h1><ul><li>外面使用单引号，内部屏蔽单引号，双引号同理</li><li>转义字符</li></ul><ul><li>\`：反斜杠（用于表示反斜杠字符）。</li><li><code>\'</code>：单引号（用于表示单引号字符）。</li><li><code>\"</code>：双引号（用于表示双引号字符）。</li><li><code>\n</code>：换行符（将光标移到下一行的开头位置）。</li><li><code>\r</code>：回车符（将光标移到当前行的开头位置）。</li><li><code>\t</code>：制表符（在输出中创建水平制表或跳到下一个制表位置）。</li><li><code>\b</code>：退格符（将光标向左移动一个位置）。</li><li><code>\f</code>：换页符（在输出中创建一个新页）。</li></ul><p>加上r开头无视制表符</p><h2 id="5-1-格式化输出"><a href="#5-1-格式化输出" class="headerlink" title="5.1 格式化输出"></a>5.1 格式化输出</h2><pre><code class="python">name = "cc"print(f"my name is {name}")</code></pre><pre><code class="python">name = "John"age = 25print("My name is %s and I am %d years old." % (name, age))</code></pre><pre><code class="python">name = "John"age = 25print("My name is {} and I am {} years old.".format(name, age))</code></pre><h2 id="5-2-操作"><a href="#5-2-操作" class="headerlink" title="5.2 操作"></a>5.2 操作</h2><ul><li><p>下标访问</p><pre><code class="python">text = "Hello, World!"print(text[0])  # 访问第一个字符print(text[7])  # 访问第八个字符print(text[-1])  # 访问最后一个字符print(text[-6])  # 访问倒数第六个字符</code></pre></li><li><p>切片</p><p><code>[start:stop:step]</code> 格式，其中：</p><ul><li><code>start</code> 是起始索引（默认为 0）</li><li><code>stop</code> 是结束索引（不包含在切片结果中）</li><li><code>step</code> 是步长（默认为 1）</li></ul><pre><code class="python">text = "Hello, World!"print(text[7:12])   # 提取索引从7到11的字符print(text[-6:-1])    # 提取倒数第六个到倒数第二个字符my_list = [1, 2, 3, 4, 5]print(my_list[1:4])  # 提取索引从1到3的元素print(my_list[::-1])  # 逆序提取所有元素my_tuple = ('apple', 'banana', 'cherry', 'date')print(my_tuple[::2])  # 按照步长为2提取所有元素print(my_tuple[-2:-5:-1])  # 逆序提取倒数第二到倒数第四个元素</code></pre></li><li><p>操作函数</p><ol><li><p><code>len(string)</code>：返回字符串的长度。</p></li><li><p><code>string.lower()</code>：将字符串中的字符转换为小写形式。</p></li><li><p><code>string.upper()</code>：将字符串中的字符转换为大写形式。</p></li><li><p><code>string.capitalize()</code>：将字符串的首字母转换为大写形式，其余字符转换为小写形式。</p></li><li><p><code>string.title()</code>：将字符串中每个单词的首字母转换为大写形式，其余字符转换为小写形式。</p></li><li><p><code>string.strip()</code>：去除字符串开头和结尾的空格或指定字符。</p></li><li><p><code>string.split(sep)</code>：根据分隔符 <code>sep</code> 将字符串拆分成子字符串，并返回一个列表。</p></li><li><p><code>string.join(iterable)</code>：将可迭代对象 <code>iterable</code> 中的字符串元素连接起来，中间使用 <code>string</code> 分隔。</p><pre><code class="python">string = "-"my_list = ["apple", "banana", "cherry"]result = string.join(my_list)print(result) # apple-banana-cherry</code></pre></li><li><p><code>string.replace(old, new)</code>：将字符串中的所有匹配 <code>old</code> 的子串替换为 <code>new</code>。</p></li><li><p><code>string.startswith(prefix)</code>：检查字符串是否以指定的前缀 <code>prefix</code> 开头，返回布尔值。</p></li><li><p><code>string.endswith(suffix)</code>：检查字符串是否以指定的后缀 <code>suffix</code> 结尾，返回布尔值。</p></li><li><p><code>string.find(substring)</code>：在字符串中查找子串 <code>substring</code> 的第一个匹配位置，并返回索引值。</p></li><li><p><code>string.count(substring)</code>：统计字符串中子串 <code>substring</code> 出现的次数。</p></li><li><p><code>string.isalpha()</code>：检查字符串是否只包含字母字符。</p></li><li><p><code>string.isdigit()</code>：检查字符串是否只包含数字字符。</p></li></ol></li></ul><h2 id="5-3-编码解码"><a href="#5-3-编码解码" class="headerlink" title="5.3 编码解码"></a>5.3 编码解码</h2><pre><code class="python"># 编码示例string = "你好，世界！"  # 普通字符串byte_string = string.encode("utf-8")  # 编码为字节字符串print(byte_string)  # 输出：b'\xe4\xbd\xa0\xe5\xa5\xbd\xef\xbc\x8c\xe4\xb8\x96\xe7\x95\x8c\xef\xbc\x81'# 解码示例decoded_string = byte_string.decode("utf-8")  # 解码为普通字符串print(decoded_string)  # 输出：你好，世界！</code></pre><h2 id="5-4-ASCII-转换"><a href="#5-4-ASCII-转换" class="headerlink" title="5.4 ASCII 转换"></a>5.4 ASCII 转换</h2><pre><code class="python"># ASCII 码转字符示例ascii_value = 65  # ASCII 码值character = chr(ascii_value)  # 转换为字符print(character)  # 输出：A# 字符转 ASCII 码示例character = 'A'  # 字符ascii_value = ord(character)  # 转换为 ASCII 码值print(ascii_value)  # 输出：65</code></pre><h1 id="6-列表"><a href="#6-列表" class="headerlink" title="6 列表"></a>6 列表</h1><h2 id="6-1-特征"><a href="#6-1-特征" class="headerlink" title="6.1 特征"></a>6.1 特征</h2><ul><li>有序性：列表中的元素按照它们在列表中的位置顺序进行存储和访问，可以通过索引来访问和修改特定位置的元素。索引从 0 开始，第一个元素的索引为 0，第二个元素的索引为 1，依此类推。</li><li>可变性：列表中的元素可以随时被修改、替换或删除，也可以在任意位置插入新元素。这意味着列表的长度和内容都是可变的。</li><li>可重复性：列表中可以包含重复的元素，即同一个值可以出现多次。</li><li>多样性：列表可以容纳不同类型的元素，例如整数、浮点数、字符串、布尔值等。</li></ul><h2 id="6-2-常见操作"><a href="#6-2-常见操作" class="headerlink" title="6.2 常见操作"></a>6.2 常见操作</h2><p>创建列表：</p><pre><code class="python">empty_list = []  # 创建一个空列表my_list = [1, 2, 3, 'a', 'b', 'c']  # 创建一个包含元素的列表</code></pre><p>访问和修改元素：</p><pre><code class="python">my_list = ['a', 'b', 'c']print(my_list[0])  # 输出：'a'my_list[1] = 'd'print(my_list)  # 输出：['a', 'd', 'c']</code></pre><p>添加元素：</p><pre><code class="python">my_list = ['a', 'b', 'c']my_list.append('d')print(my_list)  # 输出：['a', 'b', 'c', 'd']# 如果直接append列表，就变成二维列表了list1 = my_list.copy()list1.append([23,43]) # ['a', 'b', 'c', 'd', [23, 43]]# 选择extend会进行一次拆分list2 = my_list.copy()list2.extend(["34", "34"]) # 等价于list2 += ["34", "34"], ['a', 'b', 'c', 'd', '34', '34']list2.extend("qqqe") # ['a', 'b', 'c', 'd', '34', '34']my_list = [1, 2, 3, 4]my_list.insert(2, 5)print(my_list) # [1, 2, 5, 3, 4]</code></pre><p>删除元素：</p><pre><code class="python">my_list = ['a', 'b', 'c']del my_list[1]  # 删除索引为1的元素print(my_list)  # 输出：['a', 'c']my_list.remove('a')  # 删除值为'a'的元素print(my_list)  # 输出：['c']my_list.pop(0)  # 删除索引0的位置的元素，无参数是删除最后一个my_list.clear()  # 清空</code></pre><p>切片操作：</p><pre><code class="python">my_list = [1, 2, 3, 4, 5]sub_list = my_list[1:3]  # 获取索引为1到2的子列表print(sub_list)  # 输出：[2, 3]</code></pre><p>列表长度：</p><pre><code class="python">my_list = [1, 2, 3, 4, 5]length = len(my_list)print(length)  # 输出：5</code></pre><p>其他操作：</p><pre><code class="python">my_list.reverse()  # 反转列表元素print(my_list)  # 输出：[5, 4, 3, 2, 1]another_list = [6, 7, 8]my_list.extend(another_list)  # 将另一个列表的元素添加到当前列表print(my_list)  # 输出：[5, 4, 3, 2, 1, 6, 7, 8]count = my_list.count(5)  # 统计5在列表中出现的次数print(count)  # 输出：1</code></pre><p>遍历：</p><pre><code class="python">my_list = ['a', 'b', 'c']for index, value in enumerate(my_list): # 获取索引和元素    print(index, value)</code></pre><p>排序：</p><pre><code class="python">my_list = [3, 1, 4, 2, 5]my_list.sort()  # 对列表进行升序排序my_list.sort(reverse=True)  # 进行降序print(my_list)  # 输出：[1, 2, 3, 4, 5]，对本身列表进行改变# sorted(iterable, key=None, reverse=False)list1 = sorted(my_list)  # 生成新的列表list1 = sorted(my_list, reverse=True)  # 降序my_list = ['apple', 'banana', 'cherry', 'date']sorted_list = sorted(my_list, key=len)print(sorted_list)  # ['date', 'apple', 'cherry', 'banana']</code></pre><p>列表生成：</p><pre><code class="python">list1 = [None] * 10list2 = list(range(1, 11))list3 = [i * 2 for i in range(1, 6)]</code></pre><h1 id="7-字典"><a href="#7-字典" class="headerlink" title="7 字典"></a>7 字典</h1><pre><code class="python">person = {    "name": "Alice",    "age": 27,    "city": "Beijing"}print(person["name"])  # 访问键为"name"的值："Alice"person["age"] = 28  # 修改键为"age"的值为28print(person)  # 打印整个字典：{'name': 'Alice', 'age': 28, 'city': 'Beijing'}person["email"] = "alice@example.com"  # 添加新的键值对print(person)  # 打印整个字典，包含新的键值对：{'name': 'Alice', 'age': 28, 'city': 'Beijing', 'email': 'alice@example.com'}del person["city"]  # 删除键为"city"的键值对print(person)  # 打印整个字典，不再包含"city"键值对：{'name': 'Alice', 'age': 28, 'email': 'alice@example.com'}length = len(person)  # 获取字典的长度print(length)  # 打印字典长度：3</code></pre><pre><code class="python">person.key()  # 所有的键person.value()  # 所有的键值person.item()  # 所有的项for i in person:  # 遍历所有的key()    print(i)for key, value in enumerate(person):  # 带下标的key    print(key, value)for key, value in person.items():  # 遍历所有    print(key, value)for v in person.value()  # 遍历键值    print(v)  # 合并dict1 = {"name": "Alice", "age": 27}dict2 = {"city": "Beijing", "email": "alice@example.com"}dict1.update(dict2)  # 合并字典print(dict1)  # 打印合并后的字典：{'name': 'Alice', 'age': 27, 'city': 'Beijing', 'email': 'alice@example.com'}</code></pre><h1 id="8-集合"><a href="#8-集合" class="headerlink" title="8 集合"></a>8 集合</h1><ol><li>无序性：集合中的元素没有固定的顺序，每次输出的顺序可能不同。</li><li>唯一性：集合中的元素是唯一的，不允许有重复的元素。</li><li>可变性：集合是可变的，可以通过添加或删除元素来修改集合。</li><li>集合元素必须是可哈希的：集合中的元素必须是可哈希的，即不可变的（例如数字、字符串、元组），但不支持可变类型（例如列表、字典）。</li><li>数学操作：可以进行集合间的数学操作，如并集、交集和差集等。</li></ol><pre><code class="python"># 创建集合set1 = {1, 2, 3}set2 = set([3, 4, 5])# 添加元素set1.add(4)print(set1)  # 输出 {1, 2, 3, 4}# 删除元素set2.remove(4)print(set2)  # 输出 {3, 5}# 集合运算union_set = set1.union(set2)  # 并集intersection_set = set1.intersection(set2)  # 交集difference_set = set1.difference(set2)  # 差集print(union_set)  # 输出 {1, 2, 3, 5}print(intersection_set)  # 输出 {3}print(difference_set)  # 输出 {1, 2, 4}</code></pre><h1 id="9-元组"><a href="#9-元组" class="headerlink" title="9 元组"></a>9 元组</h1><ol><li>有序性：元组中的元素按照定义的顺序排列，并且保持不变。</li><li>不可变性：元组的元素不能被修改，添加或删除。一旦创建，元组的内容就不可更改。</li><li>支持多种数据类型：元组可以包含不同类型的数据，例如整数、浮点数、字符串等。</li><li>可用于索引和切片：可以使用索引和切片操作访问元组中的元素。</li></ol><pre><code class="python"># 创建元组tuple1 = (1, 2, 3)tuple2 = tuple([4, 5, 6])# 访问元素print(tuple1[0])  # 输出 1print(tuple2[1:])  # 输出 (5, 6)# 元组拼接tuple3 = tuple1 + tuple2print(tuple3)  # 输出 (1, 2, 3, 4, 5, 6)# 元组解包a, b, c = tuple1print(a, b, c)  # 输出 1 2 3# 遍历元组for item in tuple2:    print(item)  # 输出 4 5 6</code></pre><ul><li>需要注意的是，元组是不可变的，这意味着一旦创建，就不能修改元组中的元素。如果需要修改元素，可以将元组转换为列表进行修改，然后再转换回元组。</li></ul><pre><code class="python">tuple4 = (1, 2, 3)list4 = list(tuple4)list4[0] = 4tuple4 = tuple(list4)print(tuple4)  # 输出 (4, 2, 3)</code></pre><h1 id="10-函数"><a href="#10-函数" class="headerlink" title="10 函数"></a>10 函数</h1><h2 id="10-1-基本调用"><a href="#10-1-基本调用" class="headerlink" title="10.1 基本调用"></a>10.1 基本调用</h2><p>定义函数：使用 <code>def</code> 关键字来定义一个函数，并给函数取一个名称。函数名称后面跟着一对圆括号 <code>()</code>，括号中可以包含参数（可选），参数用于接收传递给函数的值。函数体以冒号 <code>:</code> 开始，并通过缩进来表示函数体内的代码块。</p><pre><code class="python">def greet():    print("Hello, world!")def add(a, b):    return a + b</code></pre><p>调用函数：当需要执行函数内的代码时，通过函数名称后跟一对圆括号 <code>()</code> 来调用函数。如果函数有参数，需要在括号中传递相应的值。</p><pre><code class="python">greet()  # 调用 greet 函数，输出 "Hello, world!"result = add(3, 5)  # 调用 add 函数，并将返回值赋给 result 变量print(result)  # 输出 8</code></pre><h2 id="10-2-参数"><a href="#10-2-参数" class="headerlink" title="10.2 参数"></a>10.2 参数</h2><ul><li><p>默认参数</p><pre><code class="python">def greet(name, greeting="Hello"):    """    给定名称和问候语，打印出个性化的问候信息。        Args:        name (str): 要问候的人的名称。        greeting (str, optional): 问候语，默认为"Hello"。    """    message = f"{greeting}, {name}!"    print(message)# 不指定 greeting 参数的值，默认使用 "Hello"greet("Alice")  # 输出：Hello, Alice!# 传递自定义的 greeting 参数值greet("Bob", "Hi")  # 输出：Hi, Bob!</code></pre></li><li><p>不定长参数</p><pre><code class="python">def my_func(*args):    """    接收任意数量的位置参数，并打印出来。        Args:        *args: 任意数量的位置参数。    """    for arg in args:        print(arg)# 调用函数并传递不同数量的位置参数my_func(1, 2, 3)               # 输出：1 2 3my_func('Hello', 'World')      # 输出：Hello Worldmy_func('a', 'b', 'c', 'd')    # 输出：a b c d</code></pre><pre><code class="python">def my_func(**kwargs):    """    接收任意数量的关键字参数，并打印出来。        Args:        **kwargs: 任意数量的关键字参数。    """    for key, value in kwargs.items():        print(f"{key}: {value}")# 调用函数并传递不同的关键字参数my_func(name='Alice', age=25)          # 输出：name: Alice, age: 25my_func(city='New York', country='USA')# 输出：city: New York, country: USA</code></pre></li><li><p>匿名函数</p><pre><code class="python">square = lambda x: x**2print(square(4))  # 输出：16print(square(7))  # 输出：49</code></pre></li><li><p>回调函数</p><p>回调函数（Callback Function）是一种将函数作为参数传递给另一个函数，并在特定事件发生时被调用的函数。在 Python 中，可以使用回调函数来实现异步操作、事件处理、回调机制等。</p><pre><code class="python">def process_data(data, callback):    # 在处理数据之后，调用回调函数    result = data * 2    callback(result)def handle_result(result):    # 处理回调函数的结果    print("处理结果:", result)data = 5process_data(data, handle_result)</code></pre></li><li><p>闭包函数</p><p>闭包函数（Closure Function）是指在一个函数内部定义并使用了另一个函数，并且这个内部函数可以访问外部函数中的变量。换句话说，闭包函数可以捕获并存储其所在作用域的状态。</p><p>Python 中的闭包函数是一种非常有用的功能，它可以帮助我们实现某些高级的编程技巧和模式，例如装饰器、工厂函数等。闭包函数的特点是：</p><ol><li>内部函数可以访问外部函数定义的变量：闭包函数中的内部函数可以引用并访问外部函数中的变量，即使外部函数已经执行完毕，内部函数仍然可以访问到那些变量。</li><li>外部函数可以返回内部函数作为结果：外部函数可以返回其内部函数作为结果，使得内部函数在外部函数执行完毕后仍然可以被调用。</li></ol><pre><code class="python">def outer_function(x):    def inner_function(y):        return x + y    return inner_functionclosure = outer_function(5)  # 感觉这里返回的是这个函数的内函数result = closure(3)print(result)  # 输出 8</code></pre></li></ul><h2 id="10-3-使用全局变量"><a href="#10-3-使用全局变量" class="headerlink" title="10.3 使用全局变量"></a>10.3 使用全局变量</h2><ul><li><p>直接使用即可，但是局部变量不会改变全局变量的值</p></li><li><p><strong>global</strong></p></li></ul><pre><code>x = 10  # 全局变量def func():    global x  # 声明 x 是全局变量    x = 20   # 修改全局变量 x 的值print("Before calling func:", x)  # 输出：Before calling func: 10func()print("After calling func:", x)   # 输出：After calling func: 20</code></pre><h2 id="10-4-filter筛选函数"><a href="#10-4-filter筛选函数" class="headerlink" title="10.4 filter筛选函数"></a>10.4 filter筛选函数</h2><p><code>filter(function, iterable)</code></p><p>其中，<code>function</code> 是一个判断函数，用于指定筛选的条件；<code>iterable</code> 是一个可迭代对象，包含需要筛选的元素。</p><p><code>filter()</code> 函数将会返回一个 <code>filter</code> 对象，它是一个迭代器，可以通过遍历或转换为其他序列（如列表）来获取结果。在筛选过程中，只有满足 <code>function</code> 函数返回值为 <code>True</code> 的元素会被保留。</p><pre><code class="python">numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]def is_even(x):    return x % 2 == 0result = filter(is_even, numbers)print(list(result))  # 输出：[2, 4, 6, 8, 10]</code></pre><h2 id="10-5-map-函数"><a href="#10-5-map-函数" class="headerlink" title="10.5 map()函数"></a>10.5 map()函数</h2><p><code>map(function, iterable)</code></p><p>其中，<code>function</code> 是一个函数，用于对每个元素进行处理；<code>iterable</code> 是一个可迭代对象，包含需要处理的元素。</p><p><code>map()</code> 函数将会返回一个 <code>map</code> 对象，它是一个迭代器，可以通过遍历或转换为其他序列（如列表）来获取结果。在处理过程中，会将 <code>iterable</code> 中的每个元素依次传递给 <code>function</code> 函数进行处理，并将处理后的结果保存在 <code>map</code> 对象中。</p><pre><code class="python">numbers = [1, 2, 3, 4, 5]result = map(lambda x: x ** 2, numbers)print(list(result))  # 输出：[1, 4, 9, 16, 25]</code></pre><h2 id="10-6-装饰器函数"><a href="#10-6-装饰器函数" class="headerlink" title="10.6 装饰器函数"></a>10.6 装饰器函数</h2><p>装饰器函数通常采用一个函数作为输入参数，并返回一个新的函数作为输出结果。这样，我们可以使用装饰器函数来包装（decorate）其他函数，以添加一些额外的功能、修改其行为或执行其他操作。（相当于优雅地修改其他函数）</p><pre><code class="python">def decorator_function(original_function):    def wrapper_function():        # 在调用原始函数之前执行一些操作        print("执行装饰器添加的功能")                # 调用原始函数        original_function()                # 在调用原始函数之后执行一些操作        print("装饰器功能执行完毕")        # 返回包装后的函数对象    return wrapper_functiondef greet():    print("Hello, world!")# 使用装饰器函数来装饰 greet() 函数greet = decorator_function(greet)# 执行装饰后的函数greet()</code></pre><pre><code class="python">def decorator_function(original_function):    def wrapper_function():        print("执行装饰器添加的功能")        original_function()        print("装饰器功能执行完毕")    return wrapper_function@decorator_functiondef greet():    print("Hello, world!")greet()</code></pre><h1 id="11-模块"><a href="#11-模块" class="headerlink" title="11 模块"></a>11 模块</h1><h2 id="11-1-模块基本操作"><a href="#11-1-模块基本操作" class="headerlink" title="11.1 模块基本操作"></a>11.1 模块基本操作</h2><pre><code class="python"># 导入整个模块import math# 使用模块中的函数print(math.sqrt(16))  # 输出：4.0# 导入模块并指定别名import datetime as dt# 使用别名调用模块中的类today = dt.date.today()print(today)  # 输出当前日期# 导入模块中的特定成员（函数、类、变量等）from random import randint# 直接使用成员，无需再加模块前缀print(randint(1, 10))  # 输出一个随机整数# 导入模块中的所有成员（函数、类、变量等）from statistics import *# 直接使用所有成员，无需再加模块前缀data = [1, 2, 3, 4, 5]print(mean(data))  # 输出平均值</code></pre><h2 id="11-2-os模块"><a href="#11-2-os模块" class="headerlink" title="11. 2 os模块"></a>11. 2 os模块</h2><ol><li>文件和目录操作：<ul><li>创建目录：<code>os.mkdir(path)</code></li><li>删除目录：<code>os.rmdir(path)</code></li><li>列出目录下的文件和子目录：<code>os.listdir(path)</code></li><li>获取当前工作目录：<code>os.getcwd()</code></li><li>改变当前工作目录：<code>os.chdir(path)</code></li></ul></li></ol><ul><li><p>重命名文件或目录：<code>os.rename(src, dst)</code></p></li><li><p>删除文件：<code>os.remove(path)</code></p></li><li><p>检查文件是否存在：<code>os.path.exists(path)</code></p></li><li><p>检查是否为目录：<code>os.path.isdir(path)</code></p></li><li><p>检查是否为文件：<code>os.path.isfile(path)</code></p></li><li><p>获取文件大小：<code>os.path.getsize(path)</code></p></li><li><p>复制文件：可以使用<code>shutil</code>模块中的<code>shutil.copy(src, dst)</code>进行文件复制操作。</p></li><li><p>使用<code>os.system(command)</code>执行系统命令。例如：<code>os.system("ls")</code>会在终端运行<code>ls</code>命令。</p></li></ul><h2 id="11-3-random模块"><a href="#11-3-random模块" class="headerlink" title="11.3 random模块"></a>11.3 random模块</h2><p><code>random.random()</code>： 返回一个0到1之间（包括0但不包括1）的随机浮点数。</p><pre><code class="python">import randomnum = random.random()print(num)# 输出：0.123456789 （随机的0到1之间的浮点数）</code></pre><p><code>random.randint(a, b)</code>： 返回一个指定范围内的随机整数，包括边界值<code>a</code>和<code>b</code>。 </p><pre><code class="python">import randomnum = random.randint(1, 10)print(num)# 输出：4 （随机的1到10之间的整数）</code></pre><p><code>random.choice(seq)</code>： 从一个非空序列中随机选择一个元素，并返回。</p><pre><code class="python">import randomfruits = ['apple', 'banana', 'orange']choice = random.choice(fruits)print(choice)# 输出：'banana' （随机选择一个水果）</code></pre><p><code>random.shuffle(seq)</code>： 将一个序列中的元素随机打乱顺序，改变原序列，没有返回值。</p><pre><code class="python">import randomnumbers = [1, 2, 3, 4, 5]random.shuffle(numbers)print(numbers)# 输出类似于：[4, 2, 5, 1, 3] （随机打乱元素顺序）</code></pre><p><code>random.sample(population, k)</code>： 从给定的序列中随机选择<code>k</code>个元素并返回，不改变原序列。</p><pre><code class="python">import randomnumbers = [1, 2, 3, 4, 5]sample = random.sample(numbers, 3)print(sample)# 输出类似于：[4, 2, 5] （随机选择3个元素）</code></pre><h2 id="11-4-datetime模块"><a href="#11-4-datetime模块" class="headerlink" title="11. 4 datetime模块"></a>11. 4 datetime模块</h2><p><code>datetime.datetime.now()</code>： 返回当前的日期和时间。</p><pre><code class="python">import datetimenow = datetime.datetime.now()print(now)# 输出类似于：2023-07-13 11:46:28.123456 （当前的日期和时间）</code></pre><p><code>datetime.datetime(year, month, day[, hour[, minute[, second[, microsecond[, tzinfo]]]]])</code>： 创建一个表示指定日期和时间的<code>datetime</code>对象。</p><pre><code class="python">import datetimedt = datetime.datetime(2023, 7, 13, 12, 30)print(dt)# 输出：2023-07-13 12:30:00 （表示指定日期和时间的datetime对象）</code></pre><p><code>datetime.timedelta(days[, seconds[, microseconds[, milliseconds[, minutes[, hours[, weeks]]]]]])</code>： 表示时间间隔的类，可以用于进行日期和时间的计算。</p><pre><code class="python">import datetimedelta = datetime.timedelta(days=7)one_week_later = datetime.datetime.now() + deltaprint(one_week_later)# 输出：2023-07-20 11:46:28.123456 （当前时间的一周后）</code></pre><p><code>datetime.strftime(format)</code>与<code>datetime.strptime(date_string, format)</code>： <code>strftime</code>方法将<code>datetime</code>对象格式化为字符串，而<code>strptime</code>方法将字符串解析为<code>datetime</code>对象。</p><pre><code class="python">import datetimedt = datetime.datetime.now()dt_str = dt.strftime('%Y-%m-%d %H:%M:%S')print(dt_str)# 输出类似于：2023-07-13 11:46:28 （将datetime对象格式化为字符串）dt_parsed = datetime.datetime.strptime('2023-07-13 12:30:00', '%Y-%m-%d %H:%M:%S')print(dt_parsed)# 输出：2023-07-13 12:30:00 （将字符串解析为datetime对象）</code></pre><h2 id="11-5-time模块"><a href="#11-5-time模块" class="headerlink" title="11. 5 time模块"></a>11. 5 time模块</h2><p><code>time.time()</code>： 返回当前时间的时间戳（自新纪元以来的秒数）。</p><pre><code class="python">import timetimestamp = time.time()print(timestamp)# 输出类似于：1626162382.123456 （当前时间的时间戳）</code></pre><p><code>time.sleep(secs)</code>： 让程序暂停执行指定的秒数。</p><pre><code class="python">import timeprint('开始')time.sleep(3)print('结束')# 输出：# 开始# （3秒后）# 结束</code></pre><p><code>time.strftime(format[, t])</code>与<code>time.strptime(string[, format])</code>： <code>strftime</code>方法将时间元组或struct_time对象格式化为字符串，<code>strptime</code>方法将字符串解析为时间元组对象。</p><pre><code class="python">import timetimestamp = time.time()time_str = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(timestamp))print(time_str)# 输出类似于：2023-07-13 11:46:28 （将时间戳格式化为字符串）time_parsed = time.strptime('2023-07-13 12:30:00', '%Y-%m-%d %H:%M:%S')print(time_parsed)# 输出类似于：time.struct_time(tm_year=2023, tm_mon=7, tm_mday=13, tm_hour=12, tm_min=30, tm_sec=0, tm_wday=3, tm_yday=194, tm_isdst=-1) （将字符串解析为时间元组对象）</code></pre><h1 id="12-类"><a href="#12-类" class="headerlink" title="12 类"></a>12 类</h1><h2 id="12-1-初始化类"><a href="#12-1-初始化类" class="headerlink" title="12.1 初始化类"></a>12.1 初始化类</h2><p>定义类（Class）：类是面向对象编程的基础，通过定义类来创建新的对象。类定义了对象的属性和方法。可以使用 <code>class</code> 关键字来定义一个类。</p><p>构造函数 <code>__init__()</code> 在创建对象时被调用，用于初始化对象的属性。它是一个特殊的方法，以双下划线开头和结尾。可以在构造函数中定义对象的初始状态。</p><p>析构函数 <code>__del__()</code> 在对象被销毁时自动调用。它也是一个特殊的方法，以双下划线开头和结尾。析构函数可以用于释放资源或执行清理操作。</p><p><code>Person</code> 类的析构函数 <code>__del__()</code> 会在对象被销毁时自动调用。使用 <code>del</code> 关键字可以手动销毁对象。</p><pre><code class="python">class Person:    def __init__(self, name, age):        self.name = name        self.age = age        print("Person object created.")    def __del__(self):        print("Person object destroyed.")person = Person("Alice", 25)del person</code></pre><h2 id="12-2-类属性和对象属性"><a href="#12-2-类属性和对象属性" class="headerlink" title="12.2 类属性和对象属性"></a>12.2 类属性和对象属性</h2><p>类属性是定义在类中的变量，被所有该类的实例共享。它们属于类本身，而不属于类的任何特定实例。可以通过类名或实例访问类属性。</p><p>对象属性是定义在类实例中的变量，每个实例都拥有自己的一组对象属性。它们可以在类的构造函数中初始化，并使用 <code>self</code> 关键字绑定到对象。</p><p>需要注意的是，对象属性和类属性可以具有相同的名称，但它们是不同的。<strong>当通过实例访问属性时，如果实例没有该属性，则会查找类属性。</strong></p><pre><code class="python">class Person:    species = "Human"    def __init__(self, name):        self.name = name# 创建实例并访问属性person = Person("Alice")print(person.species)  # 输出: Humanprint(person.name)  # 输出: Alice# 修改类属性不影响已创建的实例Person.species = "Homo sapiens"print(person.species)  # 输出: Homo sapiens</code></pre><h2 id="12-3-继承"><a href="#12-3-继承" class="headerlink" title="12.3 继承"></a>12.3 继承</h2><p>要创建一个继承关系，需要在定义子类时将父类作为参数传递给子类。子类会继承父类的所有属性和方法，并且可以添加自己特有的属性和方法。</p><pre><code class="python">class ParentClass:    def __init__(self, x):        self.x = x    def parent_method(self):        print("This is a parent method.")class ChildClass(ParentClass):    def __init__(self, x, y):        super().__init__(x)  # 调用父类的构造方法        self.y = y    def child_method(self):        print("This is a child method.")# 创建子类实例child = ChildClass(1, 2)# 调用继承的父类方法child.parent_method()  # 输出: This is a parent method.# 调用子类自己的方法child.child_method()  # 输出: This is a child method.# 访问继承的父类属性和子类自己的属性print(child.x)  # 输出: 1print(child.y)  # 输出: 2</code></pre><h2 id="12-4-类方法和静态方法"><a href="#12-4-类方法和静态方法" class="headerlink" title="12.4 类方法和静态方法"></a>12.4 类方法和静态方法</h2><ol><li><p>类方法（class method）：</p><ul><li>类方法使用 <code>@classmethod</code> 装饰器进行标记，通常以 <code>cls</code> 作为第一个参数，表示类本身。</li><li>可以通过类名或实例来调用类方法。</li><li>类方法可以访问和修改类属性，并且可以在没有实例的情况下被调用。</li><li>类方法常用于创建替代构造函数、操作共享数据等场景。</li></ul></li><li><p>静态方法（static method）：</p><ul><li>静态方法使用 <code>@staticmethod</code> 装饰器进行标记，不需要额外的参数来表示类或实例。</li><li>可以通过类名或实例来调用静态方法。</li><li>静态方法与类和实例无关，不能访问类属性或实例属性。</li><li>静态方法通常用于封装逻辑上与类相关，但在执行过程中不需要类或实例的功能。</li></ul></li></ol><pre><code class="python">class Car:    total_cars = 0    def __init__(self, brand, model):        self.brand = brand        self.model = model        Car.total_cars += 1    @classmethod    def from_string(cls, car_string):        brand, model = car_string.split(',')        return cls(brand, model)    @staticmethod    def is_brand_supported(brand):        supported_brands = ['Toyota', 'Honda', 'Ford']        return brand in supported_brands# 使用类方法创建 Car 实例car1 = Car.from_string('Toyota, Camry')  # 通过字符串创建实例print(car1.brand)  # 输出：Toyotaprint(car1.model)  # 输出：Camryprint(Car.total_cars)  # 输出：1# 使用静态方法检查品牌是否受支持print(Car.is_brand_supported('Toyota'))  # 输出：Trueprint(Car.is_brand_supported('BMW'))  # 输出：False</code></pre><h2 id="12-5-私有属性私有方法"><a href="#12-5-私有属性私有方法" class="headerlink" title="12.5 私有属性私有方法"></a>12.5 私有属性私有方法</h2><ol><li>私有属性：</li></ol><ul><li><p>使用两个下划线 <code>_</code> 开头的属性名来表示私有属性。</p></li><li><p>私有属性只能在类的内部和类的方法中访问，无法在类的外部直接访问。</p></li><li><p>可以通过公有方法来间接访问私有属性。</p></li></ul><pre><code class="python">class MyClass:    def __init__(self):        self._private_attr = 0  # 私有属性    def public_method(self):        self._private_attr += 1# 在类的外部无法直接访问私有属性obj = MyClass()# print(obj._private_attr)  # 报错：AttributeError# 通过公有方法间接访问私有属性obj.public_method()</code></pre><p>2.私有方法：</p><ul><li>使用两个下划线 <code>_</code> 开头的方法名来表示私有方法。</li><li>私有方法只能在类的内部调用，无法在类的外部直接调用。</li><li>公有方法可以内部调用私有方法。</li></ul><pre><code class="python">class MyClass:    def __private_method(self):        print("This is a private method.")    def public_method(self):        # 在公有方法内部调用私有方法        self.__private_method()# 在类的外部无法直接调用私有方法obj = MyClass()# obj.__private_method()  # 报错：AttributeError# 通过公有方法调用私有方法obj.public_method()  # 输出："This is a private method."</code></pre><h2 id="12-6-多态"><a href="#12-6-多态" class="headerlink" title="12.6 多态"></a>12.6 多态</h2><p>方法重写（Override）：</p><ul><li>当子类继承父类时，可以重写父类的方法，以便在子类中提供对该方法的自定义实现。</li><li>在运行时，当调用该方法时，会根据对象的实际类型来确定使用哪个版本的方法。</li><li>子类可以完全覆盖父类的方法或在父类的基础上进行扩展。</li></ul><pre><code class="python">class Animal:    def __init__(self, name):        self.name = name    def make_sound(self):        print("The animal makes a sound.")class Dog(Animal):    def __init(self,name):        Animal.__init__(self, name)            def make_sound(self):        print("The dog barks.")class Cat(Animal):    def __init(self,name):        Animal.__init__(self, name)            def make_sound(self):        print("The cat meows.")# 多态使用animals = [Dog("Buddy"), Cat("Whiskers")]for animal in animals:    animal.make_sound()</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pr扭曲转场</title>
      <link href="/2024/01/25/pr%E6%89%AD%E6%9B%B2%E8%BD%AC%E5%9C%BA/"/>
      <url>/2024/01/25/pr%E6%89%AD%E6%9B%B2%E8%BD%AC%E5%9C%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="扭曲转场调整"><a href="#扭曲转场调整" class="headerlink" title="扭曲转场调整"></a>扭曲转场调整</h1><p>在做扭曲的效果时，对于扭曲容易产生黑边的效果。可以用镜头扭曲来缓解。</p><p><img src="/../images/image-20240125214254525.png" alt="image-20240125214254525"></p><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><p>1.添加一个调整图层。加上镜头扭曲的效果。</p><p><img src="/../images/image-20240125214421789.png" alt="image-20240125214421789"></p><p>2.调整一般为-90增大画面，去除黑边，再缓入缓出，设置速率。</p><p><img src="/../images/image-20240125214916443.png" alt="image-20240125214916443"></p><p>3.下部可以再设置其他效果。</p>]]></content>
      
      
      
        <tags>
            
            <tag> pr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring之AOP</title>
      <link href="/2024/01/24/Spring%E4%B9%8BAOP/"/>
      <url>/2024/01/24/Spring%E4%B9%8BAOP/</url>
      
        <content type="html"><![CDATA[<h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><p>AOP（Aspect-Oriented Programming，面向切面编程）是一种编程范式，它通过将横切关注点（cross-cutting concerns）从主要业务逻辑中分离出来，使得我们能够更清晰、更模块化地组织和维护代码。</p><p>在传统的面向对象编程中，我们主要关注业务逻辑的实现，例如类的行为、方法的执行流程等。然而，很多应用都包含一些横切关注点，例如日志记录、事务管理、安全控制、性能优化等，这些关注点不属于核心业务逻辑，但却分布在整个代码基底。AOP 的目标就是将这些横切关注点模块化，使得我们能够更好地维护和管理它们。</p><p>AOP 主要通过两个概念来实现：切面（Aspect）和连接点（Join Point）。</p><ol><li><strong>切面（Aspect）：</strong> 切面是一个模块化单元，它封装了横切关注点的代码。切面定义了在何处（连接点）以及如何应用横切关注点。在 AOP 中，切面可以包括通知（Advice）、切点（Pointcut）和引介（Introduction）等。</li><li><strong>连接点（Join Point）：</strong> 连接点是在应用中程序执行的点，例如方法的执行、异常的处理等。切面通过定义切点来选择连接点，然后在这些连接点上应用通知，从而插入横切关注点的逻辑。</li></ol><p>AOP 的一些关键概念：</p><ul><li><strong>通知（Advice）：</strong> 通知是切面的具体行为，它定义了在连接点上执行的代码。常见的通知类型包括前置通知（在连接点之前执行代码）、后置通知（在连接点之后执行代码）、环绕通知（在连接点前后执行代码，可以控制连接点的执行）、异常通知（在连接点抛出异常时执行代码）等。</li><li><strong>切点（Pointcut）：</strong> 切点定义了一组连接点的集合，通知被应用到这些连接点上。切点通过表达式或者是通过指定方法名来定义。</li><li><strong>引介（Introduction）：</strong> 引介允许我们在不修改类结构的情况下，向类添加新的方法或属性。</li></ul><p>AOP 的主要优势在于它提高了代码的模块化程度，将横切关注点从核心业务逻辑中解耦，使得代码更易于理解和维护。在 Java 中，Spring 框架提供了强大的支持，通过 Spring AOP 可以轻松实现面向切面的编程。</p><h2 id="配置maven"><a href="#配置maven" class="headerlink" title="配置maven"></a>配置maven</h2><pre><code class="xml">&lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;            &lt;version&gt;5.3.10&lt;/version&gt; &lt;!-- 使用适当的版本号 --&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;            &lt;version&gt;5.3.10&lt;/version&gt; &lt;!-- 使用适当的版本号 --&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.aspectj&lt;/groupId&gt;            &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;            &lt;version&gt;1.9.7&lt;/version&gt; &lt;!-- 使用适当的版本号 --&gt;        &lt;/dependency&gt;</code></pre><h2 id="基本使用方法"><a href="#基本使用方法" class="headerlink" title="基本使用方法"></a>基本使用方法</h2><p>一个bean中有不同的方法↓</p><pre><code class="java">package dao;import org.springframework.stereotype.Repository;//使其成为bean@Repositorypublic class BookDao {    //func1在内部实现了输出当前时间的功能    public void func1(){        System.out.println(System.currentTimeMillis());        System.out.println("this is func1");    }    //func2要通过AOP的方式实现    public void func2(){        System.out.println("this is func2");    }}</code></pre><p>创建通知类，实现相应效果。</p><pre><code class="java">package aop;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.aspectj.lang.annotation.Pointcut;import org.springframework.stereotype.Component;//定义为可识别的bean@Component//定义为AOP类型@Aspectpublic class MyAdvice {    @Pointcut("execution(void dao.BookDao.func2())")    //切入点    private void pt(){}    //提供绑定    @Before("pt()")    //这是一个通知类    public void method(){        System.out.println(System.currentTimeMillis());    }}</code></pre><p>对Spring进行配置，创建配置类。</p><pre><code class="java">package config;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.EnableAspectJAutoProxy;//配置文件@Configuration@ComponentScan({"aop","config", "dao"})@EnableAspectJAutoProxypublic class SpringConfig {}</code></pre><p>调用实现</p><pre><code class="java">import config.SpringConfig;import dao.BookDao;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;public class Application {    public static void main(String[] args) {        ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class);        BookDao bookDao = (BookDao) ctx.getBean("bookDao");        bookDao.func1();        bookDao.func2();    }}</code></pre><h1 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h1><ol><li><strong>目标对象方法调用：</strong> 首先，程序执行到某个连接点，通常是目标对象（Target Object）的方法调用。这是 AOP 中切面要织入的具体业务逻辑的执行起点。</li><li><strong>切面的匹配：</strong> 在连接点上，AOP 框架会检查所有定义的切面，看哪些切面的切点匹配当前的连接点。切点定义了切面要应用的位置。</li><li><strong>通知的执行：</strong> 一旦切面的切点匹配了连接点，相应的通知就会被执行。通知是切面中具体的业务逻辑，包括前置通知、后置通知、环绕通知等。不同类型的通知会在不同的时机执行。</li><li><strong>目标对象方法的继续执行（对于环绕通知）：</strong> 如果切面是环绕通知，它在执行自己的逻辑后需要决定是否调用连接点（目标对象方法）。在环绕通知中，连接点的执行由切面来控制。</li></ol><h1 id="切入点表达式"><a href="#切入点表达式" class="headerlink" title="切入点表达式"></a>切入点表达式</h1><p>切入点表达式的一般结构包括以下几个部分：</p><ol><li><strong>execution：</strong> 这是关键字，指定匹配方法执行的切入点。在 Spring AOP 中，通常以 <code>execution</code> 关键字开始。</li><li><strong>返回类型：</strong> 用一个通配符 <code>*</code> 表示匹配任意返回类型的方法。如果你想具体指定返回类型，可以使用类的全限定名。</li><li><strong>包路径：</strong> 表示要匹配的包路径，可以使用通配符 <code>*</code> 匹配任意包名，也可以指定具体的包路径。</li><li><strong>类名：</strong> 使用 <code>*</code> 匹配任意类名，如果要匹配特定的类，可以指定类的名称。</li><li><strong>方法名：</strong> 使用 <code>*</code> 匹配任意方法名，如果要匹配特定的方法，可以指定方法的名称。</li><li><strong>参数列表：</strong> 使用 <code>(..)</code> 表示匹配任意参数列表。如果要匹配特定类型和顺序的参数，可以在括号内指定。</li></ol><p>切入点表达式的一般结构如下：</p><pre><code>execution([返回类型] [包路径].[类名].[方法名]([参数列表]))</code></pre><p>其中，方括号中的部分可以根据需要省略，使用通配符或具体指定。以下是一些例子：</p><ul><li><code>execution(* com.example.service.*.*(..))</code>: 匹配 <code>com.example.service</code> 包下所有类的所有方法。</li><li><code>execution(public * com.example.service.UserService.*(..))</code>: 匹配 <code>com.example.service.UserService</code> 类中所有公共方法。</li><li><code>execution(* com.example.service.*.find*(Long))</code>: 匹配 <code>com.example.service</code> 包下所有类中以 “find” 开头且接受一个 Long 类型参数的方法。</li></ul><h1 id="通知类型"><a href="#通知类型" class="headerlink" title="通知类型"></a>通知类型</h1><p>在 AOP 中，通知是切面中具体行为的定义，它指定了在连接点（方法执行、异常抛出等）上执行的代码。通知类型主要包括以下几种：</p><ol><li><p><strong>前置通知（Before Advice）：</strong> 在连接点方法执行之前执行的通知。可以用于执行一些准备工作或者验证操作。</p><pre><code class="java">@Before("execution(* com.example.service.*.*(..))")public void beforeAdvice() {    // 在连接点方法执行之前执行的逻辑}</code></pre></li><li><p><strong>后置通知（After Returning Advice）：</strong> 在连接点方法成功执行之后执行的通知。可以用于执行一些清理或记录日志等操作。</p><pre><code class="java">@AfterReturning(pointcut = "execution(* com.example.service.*.*(..))", returning = "result")public void afterReturningAdvice(Object result) {    // 在连接点方法成功执行之后执行的逻辑，可以访问连接点方法的返回值}</code></pre></li><li><p>==<strong>环绕通知（Around Advice）：</strong> ===在连接点方法前后执行的通知，可以完全控制连接点方法的执行。需要手动调用连接点方法。</p><pre><code class="java">@Around("execution(* com.example.service.*.*(..))")//最常用，记得抛出异常，创建返回值public Object aroundAdvice(ProceedingJoinPoint joinPoint) throws Throwable {    // 在连接点方法执行之前执行的逻辑    Object result = joinPoint.proceed(); // 手动调用连接点方法    // 在连接点方法执行之后执行的逻辑    return result;}</code></pre></li><li><p><strong>异常通知（After Throwing Advice）：</strong> 在连接点方法抛出异常时执行的通知。可以用于处理异常情况。</p><pre><code class="java">@AfterThrowing(pointcut = "execution(* com.example.service.*.*(..))", throwing = "exception")public void afterThrowingAdvice(Exception exception) {    // 在连接点方法抛出异常时执行的逻辑，可以访问连接点方法抛出的异常}</code></pre></li><li><p><strong>最终通知（After Advice）：</strong> 无论连接点方法是否抛出异常，都会执行的通知。常用于执行一些收尾工作，比如资源释放。</p><pre><code class="java">@After("execution(* com.example.service.*.*(..))")public void afterAdvice() {    // 无论连接点方法是否抛出异常，都会执行的逻辑}</code></pre></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pr炫酷描边</title>
      <link href="/2024/01/20/pr%E7%82%AB%E9%85%B7%E6%8F%8F%E8%BE%B9/"/>
      <url>/2024/01/20/pr%E7%82%AB%E9%85%B7%E6%8F%8F%E8%BE%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><p>1.选择一段要加效果的视频，先剪切出来ALT复制一份放到上方。</p><p><img src="/../images/image-20240120214228712.png" alt="image-20240120214228712"></p><p>2.为这个添加查找边缘，同时加上反转。</p><p><img src="/../images/image-20240120214304971.png" alt="image-20240120214304971"></p><p>3.之后将这个操作了的再复制两份共三份，都添加通道混合器。每一个通道混合器中都仅仅保留一个rgb分量。适当调整缩放。产生不同颜色线条效果。</p><p><img src="/../images/image-20240120214341227.png" alt="image-20240120214341227"></p><p><img src="/../images/image-20240120214438173.png" alt="image-20240120214438173"></p><h1 id="成品"><a href="#成品" class="headerlink" title="成品"></a>成品</h1><p><a href="https://www.bilibili.com/video/BV1xw411E7gs/?spm_id_from=top_right_bar_window_dynamic.content.click">https://www.bilibili.com/video/BV1xw411E7gs/?spm_id_from=top_right_bar_window_dynamic.content.click</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> pr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring之IOC</title>
      <link href="/2024/01/20/Spring%E4%B9%8BIOC/"/>
      <url>/2024/01/20/Spring%E4%B9%8BIOC/</url>
      
        <content type="html"><![CDATA[<h1 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h1><p>“IOC” 是 “Inversion of Control”（控制反转）的缩写。这是一种编程原则，它改变了传统的程序设计流程，主要体现在对象的控制权从应用程序代码中转移到外部容器（通常是框架或容器）。</p><p>在传统的程序设计中，应用程序代码负责创建和管理对象。但在控制反转中，这一控制权被颠倒过来，对象的创建和管理被外部容器负责。这意味着，应用程序不再直接创建对象，而是通过容器提供的机制来获取所需的对象。</p><p>具体来说，在 Java 中，常常使用 Spring 框架实现控制反转。在 Spring 中，对象的创建和依赖关系的管理交给了 Spring 容器。通过配置文件或注解，开发者描述了对象之间的关系，而不需要手动创建这些对象。Spring 容器负责根据配置文件或注解，实例化对象、管理它们的生命周期，并在需要的地方注入依赖。</p><p>这种方式有助于降低组件之间的耦合度，提高代码的可维护性和灵活性。控制反转是面向对象编程的一种思想，旨在提高代码的模块化程度和可测试性。</p><h1 id="Spring配置"><a href="#Spring配置" class="headerlink" title="Spring配置"></a>Spring配置</h1><p>采用Java17版本</p><pre><code class="xml">&lt;dependencies&gt;        &lt;!-- Spring Core --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;            &lt;version&gt;5.3.10&lt;/version&gt; &lt;!-- 使用适当的版本号 --&gt;        &lt;/dependency&gt;        &lt;!-- 其他 Spring 模块，根据需要添加 --&gt;    &lt;/dependencies&gt;</code></pre><p>至此可以使用Spring中的Bean实现IOC</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><pre><code class="java">//简单Book类package pojo;public class Book {    private String name;    private int id;    private int count;    public Book(){        name = "default";        id = 0;        count = 0;    }    public void test(){        System.out.println("this is a test method");    }}</code></pre><pre><code class="xml">&lt;!--  命名为applicationContext  --&gt;&lt;!--  放在src.main.resources下 --&gt;&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans"       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;    &lt;!--  通过id访问对象，class为类限定名 --&gt;    &lt;bean id="book" class="pojo.Book"/&gt;&lt;/beans&gt;</code></pre><h1 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h1><h2 id="构造函数注入"><a href="#构造函数注入" class="headerlink" title="构造函数注入"></a>构造函数注入</h2><p>在 XML 文件中定义需要注入依赖的 Bean，并使用 <code>&lt;constructor-arg&gt;</code> 元素来指定构造函数参数：</p><pre><code class="xml">&lt;!-- 定义需要注入依赖的目标 Bean --&gt;&lt;bean id="employee" class="com.example.Employee"&gt;    &lt;!-- 使用构造函数注入参数 --&gt;    &lt;!-- value是基本类型 --&gt;    &lt;constructor-arg name="name" value="John Doe" /&gt;    &lt;!-- ref是引用类型 --&gt;    &lt;constructor-arg name="department" ref="department" /&gt;&lt;/bean&gt;&lt;bean id="department" class="com.example.Department"&gt;    &lt;property name="name" value="Engineering" /&gt;&lt;/bean&gt;</code></pre><p>在上述示例中，<code>Employee</code> 类有一个接受两个参数的构造函数，通过 <code>&lt;constructor-arg&gt;</code> 元素分别注入 <code>name</code> 和 <code>department</code>。</p><h2 id="Setter注入"><a href="#Setter注入" class="headerlink" title="Setter注入"></a>Setter注入</h2><p>在 XML 文件中定义需要注入依赖的 Bean，并使用 <code>&lt;property&gt;</code> 元素来指定属性值：</p><pre><code class="xml">&lt;!-- 定义需要注入依赖的目标 Bean --&gt;&lt;bean id="employee" class="com.example.Employee"&gt;    &lt;!-- 使用setter方法注入属性 --&gt;    &lt;property name="name" value="John Doe" /&gt;    &lt;property name="department" ref="department" /&gt;&lt;/bean&gt;&lt;bean id="department" class="com.example.Department"&gt;    &lt;property name="name" value="Engineering" /&gt;&lt;/bean&gt;</code></pre><p>在上述示例中，<code>Employee</code> 类有两个属性 <code>name</code> 和 <code>department</code>，通过 <code>&lt;property&gt;</code> 元素分别注入值。</p><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><ol><li><p><strong>List 注入</strong>：</p><pre><code class="xml">&lt;bean id="listHolder" class="com.example.ListHolder"&gt;    &lt;property name="stringList"&gt;        &lt;list&gt;            &lt;value&gt;Item 1&lt;/value&gt;            &lt;value&gt;Item 2&lt;/value&gt;            &lt;value&gt;Item 3&lt;/value&gt;        &lt;/list&gt;    &lt;/property&gt;&lt;/bean&gt;</code></pre><p>在这个例子中，<code>ListHolder</code> 类有一个名为 <code>stringList</code> 的 List 属性。</p></li><li><p><strong>Map 注入</strong>：</p><pre><code class="xml">&lt;bean id="mapHolder" class="com.example.MapHolder"&gt;    &lt;property name="dataMap"&gt;        &lt;map&gt;            &lt;entry key="Key 1" value="Value 1" /&gt;            &lt;entry key="Key 2" value="Value 2" /&gt;            &lt;entry key="Key 3" value="Value 3" /&gt;        &lt;/map&gt;    &lt;/property&gt;&lt;/bean&gt;</code></pre></li></ol><h2 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h2><pre><code class="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans"       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"        xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;        &lt;bean id="book" class="pojo.Book"&gt;        &lt;!--Setter注入--&gt;        &lt;property name="count" value="1"/&gt;        &lt;property name="id" value="1"/&gt;        &lt;property name="name" value="default"/&gt;        &lt;!--引用类型--&gt;        &lt;property name="agent" ref="agent"/&gt;    &lt;/bean&gt;    &lt;bean id="agent" class="pojo.Agent"&gt;        &lt;!--构造注入--&gt;        &lt;constructor-arg name="id" value="1"/&gt;        &lt;constructor-arg name="name" value="人"/&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><h1 id="自动注入"><a href="#自动注入" class="headerlink" title="自动注入"></a>自动注入</h1><p>在 Spring 中，可以使用 XML 配置文件进行自动装配，主要有三种方式：<code>autowire="byName"</code>、<code>autowire="byType"</code> 和 <code>autowire="constructor"</code>。</p><p>以下是每种自动装配方式的示例：</p><ol><li><p><strong>按名称自动装配 (<code>autowire="byName"</code>)：</strong></p><pre><code class="xml">&lt;bean id="person" class="com.example.Person" autowire="byName"&gt;    &lt;!-- 需要自动装配的属性 --&gt;&lt;/bean&gt;</code></pre><p>在这个例子中，Spring 会根据属性的名称，在容器中查找匹配的 Bean，并将其自动装配到对应的属性上。</p></li><li><p><strong>按类型自动装配 (<code>autowire="byType"</code>)：</strong>==最常用==</p><pre><code class="xml">&lt;bean id="person" class="com.example.Person" autowire="byType"&gt;    &lt;!-- 需要自动装配的属性 --&gt;&lt;/bean&gt;</code></pre><p>Spring 会根据属性的类型，在容器中查找匹配的 Bean，并将其自动装配到对应的属性上。</p></li><li><p><strong>构造函数自动装配 (<code>autowire="constructor"</code>)：</strong></p><pre><code class="xml">&lt;bean id="person" class="com.example.Person" autowire="constructor"&gt;    &lt;!-- 需要自动装配的属性 --&gt;&lt;/bean&gt;</code></pre><p>Spring 会根据构造函数的参数类型，在容器中查找匹配的 Bean，并将其自动装配到对应的构造函数参数上。</p></li></ol><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><pre><code class="java">import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import pojo.Agent;import pojo.Book;public class Application {    public static void main(String[] args) {        //加载配置文件初始化容器        ApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml");        Book book = (Book) ctx.getBean("book");        Agent agent = book.getAgent();        System.out.println(agent.getName());    }}</code></pre><h1 id="注解开发"><a href="#注解开发" class="headerlink" title="注解开发"></a>注解开发</h1><h2 id="配置maven依赖"><a href="#配置maven依赖" class="headerlink" title="配置maven依赖"></a>配置maven依赖</h2><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-context&lt;/artifactId&gt;    &lt;version&gt;5.3.10&lt;/version&gt; &lt;!-- 使用适当的版本号 --&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-core&lt;/artifactId&gt;    &lt;version&gt;5.3.10&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;    &lt;version&gt;5.3.10&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;    &lt;version&gt;5.3.10&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;            &lt;groupId&gt;javax.annotation&lt;/groupId&gt;            &lt;artifactId&gt;javax.annotation-api&lt;/artifactId&gt;            &lt;version&gt;1.2&lt;/version&gt;        &lt;/dependency&gt;</code></pre><h2 id="定义bean"><a href="#定义bean" class="headerlink" title="定义bean"></a>定义bean</h2><p>使用<code>@Component</code>定义bean</p><pre><code class="java">package pojo;import org.springframework.stereotype.Component;@Component("newBook")public class NewBook {}</code></pre><h3 id="三个层次"><a href="#三个层次" class="headerlink" title="三个层次"></a>三个层次</h3><p>Spring提供了几个与 <code>@Component</code> 注解相关的衍生注解，用于更精确地定义组件的角色。这些衍生注解分别是：<code>@Repository</code>、<code>@Service</code>、和 <code>@Controller</code>。这些注解的作用是更好地表达组件的用途，以及在使用Spring自动组件扫描时对不同层次的组件进行更细粒度的区分。</p><ol><li><p><strong><code>@Repository</code>：</strong></p><ul><li><code>@Repository</code> 注解用于标识数据访问层（DAO）的组件。它表明被注解的类负责数据库访问、数据存储等持久化层的工作。通常与 Spring 的异常转换机制一起使用，将数据访问层的异常转换为 Spring 的 DataAccessException。</li></ul><pre><code class="java">@Repositorypublic class MyRepository {    // 数据访问相关的方法}</code></pre></li><li><p><strong><code>@Service</code>：</strong></p><ul><li><code>@Service</code> 注解用于标识业务逻辑层的组件。它表明被注解的类包含业务逻辑，负责处理业务规则、流程等。通常在服务层使用。</li></ul><pre><code class="java">@Servicepublic class MyService {    // 业务逻辑相关的方法}</code></pre></li><li><p><strong><code>@Controller</code>：</strong></p><ul><li><code>@Controller</code> 注解用于标识控制层的组件，通常用于处理Web请求。它表明被注解的类是一个控制器，处理用户的HTTP请求，并返回相应的视图。</li></ul><pre><code class="java">@Controllerpublic class MyController {    // 处理HTTP请求的方法}</code></pre></li></ol><h2 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h2><p>Spring3.0采用注解开发，用配置类代替xml配置，加快开发速度。</p><pre><code class="java">package config;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;//声明当前为配置类@Configuration//设置扫描路径，多个路径书写为字符串格式@ComponentScan({"config", "pojo", "service"})public class AppConfig {}</code></pre><pre><code class="java">import config.AppConfig;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import pojo.NewBook;public class Application2 {    public static void main(String[] args) {        //加载配置类，初始化Spring容器        ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);        //获取对象        NewBook newBook = (NewBook) ctx.getBean("newBook");        newBook.func();    }}</code></pre><h2 id="Scope作用域"><a href="#Scope作用域" class="headerlink" title="@Scope作用域"></a>@Scope作用域</h2><ol><li><p><strong>Singleton（默认）：</strong></p><ul><li><code>@Scope("singleton")</code> 或 <code>@Scope(value = ConfigurableBeanFactory.SCOPE_SINGLETON)</code>。</li><li>表示在 Spring 容器中，只存在一个共享的 Bean 实例。这是默认的作用域。</li></ul><pre><code class="java">@Component@Scope("singleton")public class MySingletonBean {    // ...}</code></pre></li><li><p><strong>Prototype：</strong></p><ul><li><code>@Scope("prototype")</code> 或 <code>@Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE)</code>。</li><li>表示每次通过容器的 <code>getBean</code> 方法获取 Bean 时，都会创建一个新的实例。</li></ul><pre><code class="java">@Component@Scope("prototype")public class MyPrototypeBean {    // ...}</code></pre></li><li><p><strong>Request：</strong></p><ul><li><code>@Scope("request")</code>。</li><li>表示在一次 HTTP 请求内，共享同一个 Bean 实例。仅在 Spring Web 应用中有效，需要启用 <code>RequestScope</code>。</li></ul><pre><code class="java">@Component@Scope("request")public class MyRequestScopedBean {    // ...}</code></pre></li><li><p><strong>Session：</strong></p><ul><li><code>@Scope("session")</code>。</li><li>表示在一个用户会话中，共享同一个 Bean 实例。同样需要在 Spring Web 应用中使用，并启用 <code>SessionScope</code>。</li></ul><pre><code class="java">@Component@Scope("session")public class MySessionScopedBean {    // ...}</code></pre></li><li><p><strong>GlobalSession：</strong></p><ul><li><code>@Scope("globalSession")</code>。</li><li>表示在全局 HTTP Session 中，共享同一个 Bean 实例。同样需要在 Spring Web 应用中使用，并启用 <code>GlobalSessionScope</code>。</li></ul><pre><code class="java">@Component@Scope("globalSession")public class MyGlobalSessionScopedBean {    // ...}</code></pre></li></ol><p>选择适当的作用域取决于你的应用程序的需求。默认的 Singleton 适用于大多数情况，但在某些情况下，如需要 Bean 每次调用时都是新实例，可以使用 Prototype。对于 Web 应用程序，Request、Session 和 GlobalSession 作用域通常与 Web 框架一起使用。</p><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>在 Spring 中，可以使用 <code>@PostConstruct</code> 和 <code>@PreDestroy</code> 注解来控制初始化和销毁方法，而不必依赖于 XML 配置。这些注解分别用于标识初始化和销毁方法，并在 Bean 的生命周期中自动调用。</p><ol><li><p><strong>使用 <code>@PostConstruct</code> 注解进行初始化：</strong></p><ul><li><code>@PostConstruct</code> 注解用于标识在 Bean 初始化时需要执行的方法。该方法会在依赖注入之后、任何自定义初始化方法之前被调用。</li></ul><pre><code class="java">import javax.annotation.PostConstruct;import org.springframework.stereotype.Component;@Componentpublic class MyBean {    @PostConstruct    public void init() {        // 这里可以放置初始化逻辑        System.out.println("Bean 初始化方法被调用");    }    // 其他业务方法}</code></pre></li><li><p><strong>使用 <code>@PreDestroy</code> 注解进行销毁：</strong></p><ul><li><code>@PreDestroy</code> 注解用于标识在 Bean 销毁时需要执行的方法。该方法会在容器关闭之前被调用。</li></ul><pre><code class="java">import javax.annotation.PreDestroy;import org.springframework.stereotype.Component;@Componentpublic class MyBean {    // 其他业务方法    @PreDestroy    public void destroy() {        // 这里可以放置销毁逻辑        System.out.println("Bean 销毁方法被调用");    }}</code></pre></li></ol><p>需要注意的是，为了使用 <code>@PostConstruct</code> 和 <code>@PreDestroy</code> 注解，确保以下几点：</p><ul><li>在类上添加 <code>@Component</code> 或其他 Spring 注解，以使这个类被 Spring 容器扫描并作为 Bean 进行管理。</li><li>确保 Spring 容器开启了对注解的扫描。可以通过在配置类上添加 <code>@ComponentScan</code> 注解或在 XML 配置中启用 <code>&lt;context:component-scan&gt;</code>。</li></ul><h2 id="依赖注入-1"><a href="#依赖注入-1" class="headerlink" title="依赖注入"></a>依赖注入</h2><ul><li>通过在成员变量上使用 <code>@Autowired</code>，Spring 容器会尝试将匹配的 bean 注入到成员变量中。</li></ul><pre><code class="java">@Servicepublic class MyService {    @Autowired    private MyRepository myRepository;    // 其他业务方法}</code></pre><blockquote><p><code>@Qualifier</code> 是 Spring 框架中用于解决自动装配（<code>@Autowired</code>）时，多个候选 bean 产生歧义性的注解。当存在多个符合类型的 bean 可以注入时，<code>@Qualifier</code> 允许指定具体要注入的 bean 的名称或标识符。</p><p>通常情况下，<code>@Autowired</code> 注解会根据类型自动装配一个 bean，但当有多个相同类型的 bean 存在时，Spring 就会产生歧义性。<code>@Qualifier</code> 注解就是为了解决这个问题。</p><p>以下是使用 <code>@Qualifier</code> 的例子：</p><pre><code class="java">@Servicepublic class MyService {    private final MyRepository myRepository;    @Autowired    @Qualifier("myRepositoryImpl") // 使用 @Qualifier 指定要注入的 bean 的名称    public MyService(MyRepository myRepository) {        this.myRepository = myRepository;    }    // 其他业务方法}</code></pre><p>在上述例子中，<code>@Qualifier("myRepositoryImpl")</code> 表示要注入名为 “myRepositoryImpl” 的 bean。这样，即使有多个 <code>MyRepository</code> 类型的 bean，Spring 会根据 <code>@Qualifier</code> 提供的信息选择合适的 bean 进行注入。</p><p>如果 bean 的标识符（通常是 bean 的名称）与 <code>@Qualifier</code> 中指定的名称一致，也可以省略 <code>@Qualifier</code> 注解，因为 Spring 默认会根据标识符来进行匹配。</p><pre><code class="java">@Servicepublic class MyService {    private final MyRepository myRepository;    @Autowired    public MyService(@Qualifier("myRepositoryImpl") MyRepository myRepository) {        this.myRepository = myRepository;    }    // 其他业务方法}</code></pre></blockquote><pre><code>//基本类型依赖@Value("100")private int num;</code></pre><h2 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h2><pre><code class="java">package pojo;//import jakarta.annotation.PostConstruct;//import jakarta.annotation.PreDestroy;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;import javax.annotation.PostConstruct;import javax.annotation.PreDestroy;@Component("newBook")public class NewBook {    @Value("100")    private int num;    //依赖注入    @Autowired    private NewBookContro newBookContro;//    @Autowired//    public NewBook(@Value("100") int num, NewBookContro newBookContro){//        this.num = num;//        this.newBookContro = newBookContro;//    }    public void func(){        System.out.println("this is New do!");        System.out.println("num is" + num);        System.out.println("id is" + newBookContro.getId());    }    @PostConstruct    public void init() {        // 这里可以放置初始化逻辑        System.out.println("Bean 初始化方法被调用");        num = 0;    }    @PreDestroy    public void destroy(){        System.out.println("Bean 被销毁了");    }}</code></pre><pre><code class="java">package pojo;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;@Component("newBookContro")public class NewBookContro {    public int getId() {        return id;    }    public void setId(int id) {        this.id = id;    }    @Value("100")    private int id;}</code></pre><pre><code class="java">import config.AppConfig;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import pojo.NewBook;public class Application2 {    public static void main(String[] args) {        //加载配置类，初始化Spring容器        ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);        NewBook newBook = (NewBook) ctx.getBean("newBook");        newBook.func();    }}</code></pre><pre><code>Bean 初始化方法被调用this is New do!num is0id is100</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习记录之MVC</title>
      <link href="/2024/01/19/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E4%B9%8BMVC/"/>
      <url>/2024/01/19/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E4%B9%8BMVC/</url>
      
        <content type="html"><![CDATA[<h1 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h1><p>MVC（Model-View-Controller）是一种软件设计模式，用于组织应用程序的结构，以使其更容易理解、维护和扩展。这个模式将应用程序分为三个主要组成部分：模型（Model）、视图（View）和控制器（Controller）。</p><ol><li><strong>模型（Model）：</strong><ul><li>模型代表应用程序的数据和业务逻辑。它负责处理应用程序的数据存储、检索、更新和验证。模型是应用程序中负责处理数据和业务规则的部分。</li></ul></li><li><strong>视图（View）：</strong><ul><li>视图负责展示数据给用户并接收用户的输入。它是用户界面的部分，负责呈现模型的数据以及将用户的输入传递给控制器。视图通常包括用户界面元素，如图形界面、网页或终端输出。</li></ul></li><li><strong>控制器（Controller）：</strong><ul><li>控制器是模型和视图之间的中介。它负责接收用户输入、更新模型和更新视图。控制器从视图接收用户的操作，根据这些操作更新模型，并确保视图反映模型的最新状态。控制器还处理应用程序的业务逻辑和流程控制。</li></ul></li></ol><p>MVC 的核心思想是将应用程序的不同方面分离开，以降低耦合度，提高代码的可维护性和可扩展性。通过清晰定义模型、视图和控制器之间的职责，开发人员可以更容易地协同工作，修改特定部分而不影响其他部分。</p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pr动画线条转换</title>
      <link href="/2024/01/19/pr%E5%8A%A8%E7%94%BB%E7%BA%BF%E6%9D%A1%E8%BD%AC%E6%8D%A2/"/>
      <url>/2024/01/19/pr%E5%8A%A8%E7%94%BB%E7%BA%BF%E6%9D%A1%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><p>0.先把素材ALT复制一份放到上方，用于遮罩我觉得是。都是对上方的操作。</p><p>1.选择素材，添加色彩效果，去除其本身颜色。<img src="/../images/image-20240119150932059.png" alt="image-20240119150932059"></p><p>2.对视频部分添加查找边缘效果。是动漫风格。<img src="/../images/image-20240119151114350.png" alt="image-20240119151114350"></p><p>3.找到水墨素材，最后是黑色。如果不是就用反转反色一下。</p><p><img src="/../images/image-20240119154355169.png" alt="image-20240119154355169"></p><p>4.在要更改的地方，剪一下。设置上轨道遮罩，选亮度遮罩。我认为遮罩均为黑色之后就显示出下面的有颜色的视频了。</p><p><img src="/../images/image-20240119165236011.png" alt="image-20240119165236011"></p><p><img src="/../images/image-20240119165322921.png" alt="image-20240119165322921"></p>]]></content>
      
      
      
        <tags>
            
            <tag> pr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pr位移拉镜</title>
      <link href="/2024/01/19/pr%E4%BD%8D%E7%A7%BB%E6%8B%89%E9%95%9C/"/>
      <url>/2024/01/19/pr%E4%BD%8D%E7%A7%BB%E6%8B%89%E9%95%9C/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>pr旋转拉镜</title>
      <link href="/2024/01/19/pr%E6%97%8B%E8%BD%AC%E6%8B%89%E9%95%9C/"/>
      <url>/2024/01/19/pr%E6%97%8B%E8%BD%AC%E6%8B%89%E9%95%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><p>要用到之前的动态拼贴</p><p>1.添加调整图层，应用动态拼贴。</p><p><img src="/../images/image-20240119135955835.png" alt="image-20240119135955835"></p><p>2.调节最后一个变换的关键帧，设置旋转以及快门角度。还可以设置速度缓入缓出，自行设置速度等。</p><p><img src="/../images/image-20240119140143324.png" alt="image-20240119140143324"></p><h1 id="成品"><a href="#成品" class="headerlink" title="成品"></a>成品</h1><p><a href="https://www.bilibili.com/video/BV1bQ4y1w7F4/?vd_source=7f18a4fbc55a8bc97f10aeee51e7d2ea">pr练习旋转拉镜_哔哩哔哩_bilibili</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> pr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pr动态拼贴</title>
      <link href="/2024/01/17/pr%E5%8A%A8%E6%80%81%E6%8B%BC%E8%B4%B4/"/>
      <url>/2024/01/17/pr%E5%8A%A8%E6%80%81%E6%8B%BC%E8%B4%B4/</url>
      
        <content type="html"><![CDATA[<h1 id="动态拼贴"><a href="#动态拼贴" class="headerlink" title="动态拼贴"></a>动态拼贴</h1><p>可以延生图层的边缘，输出的宽度和高度表示延长的尺寸</p><p>步骤</p><ol><li>选中一个视频，创建调整图层。</li><li>为图层添加效果。<img src="/../images/image-20240117201052954.png" alt="image-20240117201052954"></li></ol><p>3.效果如下。变换是变换为50%，第二次为100%。中间为四次镜像。<img src="/../images/image-20240117201137721.png" alt="image-20240117201137721"></p><p>4.产生如下的效果。<img src="/../images/image-20240117201317448.png" alt="image-20240117201317448"></p><p>如果设置为了100%，那么在变换的时候会有很好的效果。</p><h1 id="成品"><a href="#成品" class="headerlink" title="成品"></a>成品</h1><p><a href="https://www.bilibili.com/video/BV1dK4y1q7tM/?vd_source=7f18a4fbc55a8bc97f10aeee51e7d2ea">pr练习动态拼接_哔哩哔哩_bilibili</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> pr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搓一个简单的登录页面</title>
      <link href="/2024/01/17/%E6%90%93%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%99%BB%E5%BD%95%E9%A1%B5%E9%9D%A2/"/>
      <url>/2024/01/17/%E6%90%93%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%99%BB%E5%BD%95%E9%A1%B5%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><p>学前端也有一段时间，整一个最常用的登录注册页面。认为后面往里面加form，用action能接下来servlet处理数据。不过这个就是一个页面而已。</p><h1 id="2"><a href="#2" class="headerlink" title="2"></a>2</h1><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;    &lt;title&gt;登录&lt;/title&gt;    &lt;link rel="stylesheet" href="index.css"&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class="container"&gt;        &lt;div class="form-box"&gt;            &lt;div class="regester-box hidden"&gt;                &lt;h1&gt;register&lt;/h1&gt;                &lt;input type="text" placeholder="用户名"&gt;                &lt;input type="email" placeholder="邮箱"&gt;                &lt;input type="password" placeholder="密码"&gt;                &lt;input type="password" placeholder="确认密码"&gt;                &lt;button&gt;注册&lt;/button&gt;            &lt;/div&gt;            &lt;div class="login-box"&gt;                &lt;h1&gt;login&lt;/h1&gt;                &lt;input type="text" placeholder="用户名"&gt;                &lt;input type="password" placeholder="密码"&gt;                &lt;button&gt;登录&lt;/button&gt;            &lt;/div&gt;        &lt;/div&gt;        &lt;div class="con-box left"&gt;            &lt;h2&gt;欢迎来到&lt;span&gt;aaa&lt;/span&gt;&lt;/h2&gt;            &lt;p&gt;快来看看你的&lt;span&gt;abc&lt;/span&gt;&lt;/p&gt;            &lt;img src="./pic/pic1.jpg" alt=""&gt;            &lt;p&gt;                没有账号？            &lt;/p&gt;            &lt;button id="regester"&gt;去注册→&lt;/button&gt;        &lt;/div&gt;        &lt;div class="con-box right"&gt;            &lt;h2&gt;欢迎来到&lt;span&gt;aaa&lt;/span&gt;&lt;/h2&gt;            &lt;p&gt;快来领取你的&lt;span&gt;abc&lt;/span&gt;&lt;/p&gt;            &lt;img src="./pic/pic2.jpg" alt=""&gt;            &lt;p&gt;                已有账号？            &lt;/p&gt;            &lt;button id="login"&gt;去登录→&lt;/button&gt;        &lt;/div&gt;    &lt;/div&gt;    &lt;script&gt;        let login = document.getElementById("login");        let regester = document.getElementById('regester');        let form_box = document.getElementsByClassName("form-box")[0];        let login_box = document.getElementsByClassName("login-box")[0];        let regester_box = document.getElementsByClassName("regester-box")[0];        login.addEventListener('click', function () {            form_box.style.transform = 'translateX(80%)';            login_box.classList.toggle('hidden');            regester_box.classList.toggle('hidden');        });        regester.addEventListener('click', function () {            form_box.style.transform = 'translateX(0)';            login_box.classList.toggle('hidden');            regester_box.classList.toggle('hidden');        });    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h1 id="3"><a href="#3" class="headerlink" title="3"></a>3</h1><pre><code class="css">* {    /* 初始化 */    margin: 0;    padding: 0;}body {    height: 100vh;    display: flex;    justify-content: center;    align-items: center;    background: linear-gradient(200deg, #f3e7e9, #e3eeff);}.container {    background-color: #fff;    width: 650px;    height: 415px;    border-radius: 5px;    box-shadow: 5px 5px 5px rgba(0,0,0,0.1);    position: relative;}.form-box {    position: absolute;    top: -10%;    left: 5%;    background-color: #b3d7d8;    width: 320px;    height: 500px;    border-radius: 5px;    box-shadow: 2px 0 10px rgba(0,0,0,0.1);    /* 弹性布局 */    display: flex;    justify-content: center;    align-items: center;    z-index: 2;    /* 动画平滑效果 */    transition: 0.5s ease-in-out;}.regester-box, .login-box {    display: flex;    flex-direction: column;    align-items: center;    width: 100%;}.hidden {    display: none;    /* transition: 1s; */}h1 {    text-align: center;    margin-bottom: 25px;    text-transform: uppercase;    color: #fff;    letter-spacing: 5px;}input {    background-color: transparent;    width: 70%;    color: #fff;    border: none;    border-bottom: 1px solid rgba(255,255,255,0.4);    padding: 10px 0;    margin: 8px 0;    font-size: 14px;    letter-spacing: 2px;}input::placeholder {    color: #fff;}input:focus {    color: #a262ad;    /* 去除了边框 */    outline: none;    border-bottom: 1px solid rgba(255, 255, 255, 0.9);    transition: 0.5s;}input:focus::placeholder {    opacity: 0;}.form-box button {    width: 70%;    margin-top: 35px;    background-color: #f6f6f6;    border: none;    border-radius: 5px;    padding: 13px;    color: #a262ad;    letter-spacing: 2px;    cursor: pointer;}.form-box button:hover {    background-color: #a262ad;    color:#f6f6f6;    transition: 0.5s;}.con-box {    width: 50%;    height: 100%;    display: flex;    flex-direction: column;    justify-content: center;    align-items: center;    position: absolute;    top: 50%;    transform: translateY(-50%);}.con-box.left{    left: 2%;}.con-box.right{    right: 2%;}.con-box h2{    color: #8e9aaf;    font-size: 25px;    text-align: center;    font-weight: bold;    margin-bottom: 10px;    letter-spacing: 3px;}.con-box h2 span {    color: #d3b7d8;}.con-box p {    font-size: 12px;    letter-spacing: 2px;    color: #8e9aaf;    text-align: center;}.con-box img {    width: 150px;    height: 150px;    opacity: 0.9;    margin: 40px 0;}.con-box button{    margin-top: 10px;    background-color: #fff;    color: #a262ad;    border: 1px solid #d3b7d8;    padding: 6px 10px;    border-radius: 5px;    letter-spacing: 1px;    outline: none;    cursor: pointer;}.con-box button:hover {    background-color:#a262ad ;    color: #fff;}</code></pre><h1 id="4"><a href="#4" class="headerlink" title="4"></a>4</h1><p><img src="/../images/image-20240117174440545.png" alt="image-20240117174440545"></p><p><img src="/../images/image-20240117174448291.png" alt="image-20240117174448291"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pr发光蒙版</title>
      <link href="/2024/01/16/pr%E5%8F%91%E5%85%89%E8%92%99%E7%89%88/"/>
      <url>/2024/01/16/pr%E5%8F%91%E5%85%89%E8%92%99%E7%89%88/</url>
      
        <content type="html"><![CDATA[<h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><p>1.用钢笔绘制一个遮罩。</p><p><img src="/../images/image-20240116132026971.png" alt="image-20240116132026971"></p><p>2.选择一段视频添加轨道遮罩键。选择遮罩的视频是刚才绘制的遮罩。</p><p><img src="/../images/image-20240116131832299.png" alt="image-20240116131832299"></p><p>3.添加周围发光效果，Alpha发光。</p><p><img src="/../images/image-20240116132134245.png" alt="image-20240116132134245"></p><h1 id="成果"><a href="#成果" class="headerlink" title="成果"></a>成果</h1><p>【练习轨道遮罩效果】 <a href="https://www.bilibili.com/video/BV1Ui4y1i7np/?share_source=copy_web&amp;vd_source=ca5869570d22261fea5eebd01783d1ad">https://www.bilibili.com/video/BV1Ui4y1i7np/?share_source=copy_web&amp;vd_source=ca5869570d22261fea5eebd01783d1ad</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> pr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pr震动闪烁rgb</title>
      <link href="/2024/01/16/pr%E9%9C%87%E5%8A%A8%E9%97%AA%E7%83%81rgb/"/>
      <url>/2024/01/16/pr%E9%9C%87%E5%8A%A8%E9%97%AA%E7%83%81rgb/</url>
      
        <content type="html"><![CDATA[<h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><p>1.对视频进行打点</p><p><img src="/../images/image-20240116111904856.png" alt="image-20240116111904856"></p><p>2.新建调整图层</p><p><img src="/../images/image-20240116111940489.png" alt="image-20240116111940489"></p><p>放到要改的位置上</p><p><img src="/../images/image-20240116111958635.png" alt="image-20240116111958635"></p><p>3.其中一个添加变换效果，让视频变大</p><p>另一个添加lumetri颜色，可以调节曝光和对比度。</p><p>4.ALT选中一部分视频，将他们拖上来复制。<img src="/../images/image-20240116113147059.png" alt="image-20240116113147059"></p><p>每一个添加颜色平衡rgb效果。同时不透明度选择混合模式为滤色。<img src="/../images/image-20240116113354330.png" alt="image-20240116113354330"></p><p>选择rgb三个层每层一个，其中一个层设置大小稍微有所调整即可。</p><h1 id="成品"><a href="#成品" class="headerlink" title="成品"></a>成品</h1><p><a href="https://www.bilibili.com/video/BV1Rw411J7jh/">练习震动闪烁rgb_哔哩哔哩_bilibili</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> pr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pr变速卡点</title>
      <link href="/2024/01/16/pr%E5%8F%98%E9%80%9F%E5%8D%A1%E7%82%B9/"/>
      <url>/2024/01/16/pr%E5%8F%98%E9%80%9F%E5%8D%A1%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><p>1、对视频的音频打点</p><p><img src="/../images/image-20240116102608445.png" alt="image-20240116102608445"></p><p>2、调节重映射方式</p><p><img src="/../images/image-20240116102748902.png" alt="image-20240116102748902">右键fx选择速度。</p><p>3、调大左侧的按钮，使得可以看到左侧的关键帧。在相应的位置添加，按住shift拖动，实现速度的改变。</p><p><img src="/../images/image-20240116102854578.png" alt="image-20240116102854578"></p><p>4、效果如下</p><p><img src="/../images/image-20240116102907555.png" alt="image-20240116102907555"></p><h1 id="成品"><a href="#成品" class="headerlink" title="成品"></a>成品</h1>]]></content>
      
      
      
        <tags>
            
            <tag> pr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习记录之Ajax</title>
      <link href="/2024/01/12/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E4%B9%8BAjax/"/>
      <url>/2024/01/12/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E4%B9%8BAjax/</url>
      
        <content type="html"><![CDATA[<h1 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h1><p>AJAX（Asynchronous JavaScript and XML）是一种用于在网页上进行异步数据交换的技术。它通过在后台与服务器进行小规模的数据交换，使网页能够在不重新加载整个页面的情况下更新部分内容。AJAX 的核心是使用 JavaScript 在客户端发起异步请求，与服务器进行通信，并在不刷新整个页面的情况下更新部分内容。</p><p>主要特点和组成部分包括：</p><ol><li><strong>异步性：</strong> AJAX 允许在不阻塞用户界面的情况下发起请求。这使得用户可以继续与页面交互，而不必等待请求的完成。</li><li><strong>数据交换格式：</strong> 初始时，XML（eXtensible Markup Language）被广泛用作 AJAX 数据的交换格式。然而，随着 JSON（JavaScript Object Notation）的普及，现代的 AJAX 应用通常更倾向于使用 JSON 作为数据格式，因为它更轻量且易于处理。</li><li><strong>DOM 操作：</strong> 通过获取服务器返回的数据，JavaScript 可以使用 DOM（Document Object Model）操作来更新页面的特定部分，而无需重新加载整个页面。</li><li><strong>XMLHttpRequest 对象：</strong> AJAX 请求通常使用 XMLHttpRequest 对象来实现。这个对象允许 JavaScript 代码向服务器发送请求，然后处理服务器返回的数据。</li></ol><p>AJAX 的出现使得 web 应用程序能够更加动态地更新内容，提高了用户体验。典型的应用包括在表单提交时进行验证、实时搜索建议、动态加载数据等。虽然最初的名字是 “Asynchronous JavaScript and XML”，但现在 AJAX 已经成为一种更为通用的技术，不仅限于使用 XML，而是可以使用多种数据格式。</p><h1 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title="XMLHttpRequest"></a>XMLHttpRequest</h1><p><code>XMLHttpRequest</code> 是一个在 JavaScript 中用于发起 HTTP 请求的 API。它是 AJAX 技术的核心组成部分，允许在不重新加载整个页面的情况下，通过异步方式与服务器进行通信。<code>XMLHttpRequest</code> 对象允许网页中的 JavaScript 代码向服务器发送请求，获取数据，然后在不刷新整个页面的情况下更新页面的内容。</p><p>主要的方法和属性包括：</p><ol><li><strong><code>open(method, url, async)</code>：</strong> 用于指定请求的类型、URL 和是否异步处理请求。<code>method</code> 表示 HTTP 请求方法（例如 “GET” 或 “POST”），<code>url</code> 表示请求的目标 URL，<code>async</code> 表示是否异步处理请求。</li><li><strong><code>send(data)</code>：</strong> 发送 HTTP 请求。可以通过参数 <code>data</code> 向服务器发送数据，例如在 POST 请求中发送表单数据。</li><li><strong><code>setRequestHeader(header, value)</code>：</strong> 设置 HTTP 请求的头部。可以在发送请求之前使用该方法设置请求头，例如设置 Content-Type。</li><li><strong><code>onreadystatechange</code>：</strong> 一个事件处理程序，在 <code>XMLHttpRequest</code> 对象的 <code>readyState</code> 属性改变时被触发。<code>readyState</code> 表示请求的状态，而 <code>onreadystatechange</code> 允许开发者在请求不同阶段执行相应的操作。</li><li><strong><code>responseText</code> 和 <code>responseXML</code>：</strong> 分别包含服务器响应的文本和 XML 数据。根据服务器响应的内容类型，你可以选择使用其中的一个。</li></ol><p>以下是一个简单的使用 <code>XMLHttpRequest</code> 的例子：</p><pre><code class="JavaScript">var xhr = new XMLHttpRequest();xhr.open("GET", "https://example.com/data", true);xhr.onreadystatechange = function() {  if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) {    console.log(xhr.responseText);  }};xhr.send();</code></pre><p>这个例子创建了一个 <code>XMLHttpRequest</code> 对象，使用 <code>open</code> 方法指定了请求的类型、URL 和异步处理方式，设置了 <code>onreadystatechange</code> 事件处理程序来处理请求的不同阶段，最后使用 <code>send</code> 方法发送了请求。当请求完成后，如果响应的状态码为 200，那么响应的文本内容将被输出到控制台。</p><h1 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h1><h2 id="服务器响应属性"><a href="#服务器响应属性" class="headerlink" title="服务器响应属性"></a>服务器响应属性</h2><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">responseText</td><td align="left">获取字符串形式的响应数据</td></tr><tr><td align="left">responseXML</td><td align="left">获取 XML 数据形式的响应数据</td></tr></tbody></table><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt;  &lt;meta charset="UTF-8"&gt;  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;  &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="d"&gt;这是一段文字&lt;/div&gt;&lt;button onclick="f1()"&gt;按钮&lt;/button&gt;&lt;script&gt;  function f1(){    var xhr = new XMLHttpRequest();    xhr.onreadystatechange = function(){      if(xhr.readyState == 4 &amp;&amp; xhr.status == 200){        console.log(200);        document.getElementById("d").innerText = this.responseText;      }    }    xhr.open("GET", "a.txt", true);    xhr.send();  }&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h1 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h1><p>使用异步判断用户名的好处在于提高用户体验和页面响应速度。当用户在输入框中输入用户名时，异步地发送请求来检查用户名的有效性，而无需等待整个页面重新加载或等待同步的后端响应。这带来了一些优势：</p><ol><li><strong>实时反馈：</strong> 用户可以实时地看到他们输入的用户名是否有效，而无需等待整个表单的提交。这提供了更快的反馈，增加了用户体验。</li><li><strong>减轻服务器负担：</strong> 异步验证使得只有在必要时才向服务器发出请求，而不是每次用户键入字符都发送一次请求。这减轻了服务器的负担，特别是在具有大量用户的系统中。</li><li><strong>避免页面刷新：</strong> 异步验证避免了每次验证都重新加载整个页面的需求。这使得用户可以保持当前页面状态，而无需中断他们的工作。</li><li><strong>减少网络流量：</strong> 只发送用户名而不是整个表单的数据可以减少传输的数据量，减少了网络流量。</li></ol><p>在没有 AJAX 技术的早期，人们通常采用传统的同步方式来处理用户名判断问题。以下是一些可能的方法：</p><ol><li><strong>表单提交后端验证：</strong> 用户填写完整个表单并点击提交按钮后，整个表单数据将被提交到后端。后端服务器验证用户名的唯一性，然后返回验证结果。这种方式要求用户提交整个表单，可能会导致用户等待时间较长，尤其是在网络速度较慢的情况下。</li><li><strong>页面刷新：</strong> 用户填写完用户名后，可能需要点击一个特殊的按钮或者离开输入框（失去焦点），页面会刷新并显示用户名的验证结果。这种方式会导致用户体验较差，因为页面的刷新可能会中断用户当前的操作。</li></ol><h1 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h1><p>后端检查用户名是否合法</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.7.1/jquery.min.js"&gt;&lt;/script&gt;    &lt;style&gt;        #userok{            display: none;        }    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;input type="text" name="username" id="username"&gt;&lt;span id="userok"&gt;初始&lt;/span&gt;&lt;script&gt;    $(function(){        $("#username").keyup(            function(){                //这里要写上主机名，端口，上下文，花费好长时间找。                var rootPath = window.location.origin + window.location.pathname;                var urlToCheckName = rootPath + "checkname.jsp";                console.log("URL to CheckName:", urlToCheckName);                $.post({                    url: urlToCheckName,                    method: "post",                    data: {"username": $(this).val()},                    success: function(resp){                        if("ok" === resp){                            $("#userok").css("display", "inline");                            $("#userok").css("color", "green");                            $("#userok").text(resp);                        }                        else{                            $("userok").css("display", "inline");                            $("#userok").css("color", "red");                            $("#userok").text("no");                        }                    },                    //也就是说这里是返回响应不是200才使用的， 而不是不符合标准使用的。                    error: function() {                        $("#userok").css("display", "inline");                        $("#userok").css("color", "red");                        $("#userok").text = "no";                    }                });            }        );    })&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><pre><code class="java">package com.example.demo11;import jakarta.servlet.ServletException;import jakarta.servlet.http.HttpServlet;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import java.io.IOException;public class CheckNameServlet extends HttpServlet{    @Override    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        resp.setContentType("text/plain");        resp.setCharacterEncoding("UTF-8");        if("aaa".equals(req.getParameter("username"))){            resp.getWriter().print("ok");        }else{            resp.getWriter().print("no");        }    }//    @Override//    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {//        resp.setContentType("text/plain");//        resp.setCharacterEncoding("UTF-8");//        if(req.getParameter("username").equals("aaa")){//            resp.getWriter().print("不彳亍！");////        }else{//            resp.getWriter().print("这个彳亍！");//    }//}}</code></pre><pre><code class="xml">&lt;servlet&gt;    &lt;servlet-name&gt;CheckNameServlet&lt;/servlet-name&gt;    &lt;servlet-class&gt;com.example.demo11.CheckNameServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;CheckNameServlet&lt;/servlet-name&gt;    &lt;url-pattern&gt;/checkname.jsp&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;</code></pre><pre><code class="jsp">&lt;%--  Created by IntelliJ IDEA.  User: 7878  Date: 2024/1/12  Time: 19:27  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;哈哈哈&lt;/h1&gt;&lt;script&gt;    alert("出现了");&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/12/27/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E4%B9%8BjQuery/"/>
      <url>/2023/12/27/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E4%B9%8BjQuery/</url>
      
        <content type="html"><![CDATA[<h1 id="JQuery"><a href="#JQuery" class="headerlink" title="JQuery"></a>JQuery</h1><p>jQuery 是一个快速、小巧且功能丰富的 JavaScript 库。它简化了在网页中进行常见任务的复杂性，提供了跨浏览器的解决方案，使得开发者能够更容易地处理 DOM 操作、事件处理、动画效果、Ajax 请求等。</p><p>以下是一些 jQuery 的主要特点和用途：</p><ol><li><strong>跨浏览器兼容性：</strong> jQuery 解决了在不同浏览器之间处理 DOM 操作和事件的差异，为开发者提供了一致的接口。</li><li><strong>简化 DOM 操作：</strong> 使用 jQuery，你可以使用简洁而强大的选择器语法来轻松选择、操作和遍历 DOM 元素。</li><li><strong>事件处理：</strong> jQuery 提供了简单的事件处理机制，使得添加、移除和触发事件变得容易，同时解决了跨浏览器的事件兼容性问题。</li><li><strong>Ajax 请求：</strong> jQuery 简化了进行 Ajax 请求的过程，通过 <code>$.ajax()</code> 方法，你可以轻松地进行数据交换而无需刷新整个页面。</li><li><strong>动画和效果：</strong> 提供了丰富的动画和效果功能，例如淡入淡出、滑动、展开折叠等，使页面更生动有趣。</li><li><strong>链式操作：</strong> jQuery 允许你在一行代码中执行多个操作，通过链式调用方法，可以使代码更简洁。</li><li><strong>插件生态系统：</strong> 有大量的 jQuery 插件可用，可以轻松扩展 jQuery 的功能，满足不同项目的需求。</li><li><strong>轻量级：</strong> 尽管功能强大，但 jQuery 本身的文件相对较小，加载速度较快。</li></ol><p>由于这些优点，jQuery 在过去的Web开发中非常流行，但随着现代浏览器对原生 JavaScript 和其他库的支持增强，一些新的框架和库也逐渐崭露头角。然而，仍然有很多项目和网站在使用 jQuery，并且它仍然是一个有用的工具，特别是在需要兼容旧版本浏览器的情况下。</p><h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><pre><code class="javascript">$(function(){    /* code */ });</code></pre><p> 是 jQuery 中用于在文档准备就绪时执行代码的一种缩写形式。这是一种常见的用法，用于确保你的代码在文档加载完成后再执行，以避免在DOM元素尚未完全加载时进行操作。</p><p><strong>选择器（Selectors）：</strong></p><ul><li>通过元素名称选择：<code>$("p")</code> 选择所有 <code>&lt;p&gt;</code> 元素。</li><li>通过类名选择：<code>$(".myClass")</code> 选择所有具有类名 “myClass” 的元素。</li><li>通过ID选择：<code>$("#myId")</code> 选择具有ID “myId” 的元素。</li><li>多重选择器：<code>$("p, .myClass, #myId")</code> 可以选择多个元素。</li></ul><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.7.1/jquery.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id="container" style="display: inline;"&gt;        &lt;span&gt;这是文字&lt;/span&gt;    &lt;/div&gt;    &lt;button id="show"&gt;show&lt;/button&gt;    &lt;button id="hide"&gt;hide&lt;/button&gt;    &lt;script&gt;        //通过jQuery来控制其中的信息显示与否        $(function(){            $("#show").click(function(){                $("#container").show();                alert("this is show!");            });            $("#hide").click(function(){                $("#container").hide();            });        });    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="val"><a href="#val" class="headerlink" title=".val()"></a>.val()</h2><p>在 jQuery 中，<code>.val()</code> 方法主要用于获取或设置表单元素的值。它可以应用于一系列不同类型的表单元素，包括：</p><ol><li><p><strong>文本框（Text Input）：</strong></p><pre><code class="javascript">var textValue = $("input[type='text']").val();</code></pre></li><li><p><strong>密码框（Password Input）：</strong></p><pre><code class="javascript">var passwordValue = $("input[type='password']").val();</code></pre></li><li><p><strong>文本区域（Textarea）：</strong></p><pre><code class="javascript">var textareaValue = $("textarea").val();</code></pre></li><li><p><strong>单选按钮（Radio Button）：</strong></p><pre><code class="javascript">var radioValue = $("input[type='radio']:checked").val();</code></pre></li><li><p><strong>复选框（Checkbox）：</strong></p><pre><code class="javascript">var checkboxValue = $("input[type='checkbox']").val(); // 只获取第一个复选框的值</code></pre><p>如果有多个复选框，应该使用 <code>.each()</code> 遍历它们：</p><pre><code class="javascript">var checkboxValues = [];$("input[type='checkbox']:checked").each(function() {    checkboxValues.push($(this).val());});</code></pre></li><li><p><strong>下拉框（Select）：</strong></p><pre><code class="javascript">var selectValue = $("select").val(); // 只获取选中项的值</code></pre><p>如果需要获取所有选项的值，应该使用 <code>.each()</code> 遍历它们：</p><pre><code class="javascript">var selectValues = [];$("select option:selected").each(function() {    selectValues.push($(this).val());});</code></pre></li></ol><h2 id="html-text"><a href="#html-text" class="headerlink" title=".html() .text()"></a>.html() .text()</h2><ol><li><p><strong><code>.html()</code> 方法：</strong></p><ul><li><strong>获取内容：</strong> 用于获取元素的 HTML 内容，包括 HTML 标签。</li></ul><pre><code class="javascript">var htmlContent = $("div").html();</code></pre><ul><li><strong>设置内容：</strong> 用于设置元素的 HTML 内容。</li></ul><pre><code class="javascript">$("div").html("&lt;p&gt;New HTML content&lt;/p&gt;");</code></pre></li><li><p><strong><code>.text()</code> 方法：</strong></p><ul><li><strong>获取内容：</strong> 用于获取元素的纯文本内容，不包含 HTML 标签。</li></ul><pre><code class="javascript">var textContent = $("div").text();</code></pre><ul><li><strong>设置内容：</strong> 用于设置元素的纯文本内容。</li></ul><pre><code class="javascript">$("div").text("New text content");</code></pre></li></ol><p>关键区别：</p><ul><li><strong>HTML vs. 文本：</strong> <code>.html()</code> 获取和设置的是包含 HTML 标签的内容，而 <code>.text()</code> 获取和设置的是去除 HTML 标签后的纯文本内容。</li><li><strong>潜在的安全性问题：</strong> 当你使用用户提供的数据时，要注意潜在的安全性问题。使用用户提供的内容作为 <code>.html()</code> 的参数可能导致 XSS（跨站点脚本攻击）问题，因为它会将提供的 HTML 代码解释为实际的 HTML。相比之下，<code>.text()</code> 不会解释 HTML，因此更安全。</li></ul><pre><code class="html">    &lt;div id="container" style="display: inline;"&gt;        这是div中的文字        &lt;span&gt;这是span中的文字&lt;/span&gt;    &lt;/div&gt;    &lt;script&gt;    $(function(){                $("#disp").text(                    $("#container").text()                );            });    &lt;/script&gt;        </code></pre><p><img src="/../images/image-20231227192524022.png" alt="image-20231227192524022"></p><pre><code class="html">    &lt;div id="container" style="display: inline;"&gt;        这是div中的文字        &lt;span&gt;这是span中的文字&lt;/span&gt;    &lt;/div&gt;    &lt;script&gt;    $(function(){                $("#disp").text(                    $("#container").html()                );            });    &lt;/script&gt;</code></pre><p><img src="/../images/image-20231227192630357.png" alt="image-20231227192630357"></p><h1 id="css调整"><a href="#css调整" class="headerlink" title="css调整"></a>css调整</h1><p>jQuery 提供了多种方法来操作元素的 CSS 样式，以下是一些常见的 jQuery CSS 操作：</p><ol><li><p><strong>获取或设置单个样式属性：</strong></p><ul><li><p>获取样式属性：</p><pre><code class="JavaScript">var fontSize = $("div").css("font-size");</code></pre></li><li><p>设置样式属性：</p><pre><code class="JavaScript">$("div").css("color", "red");</code></pre></li></ul></li><li><p><strong>获取或设置多个样式属性：</strong></p><ul><li><p>获取多个样式属性：</p><pre><code class="JavaScript">var styles = $("div").css(["font-size", "color"]);</code></pre></li><li><p>设置多个样式属性：</p><pre><code class="JavaScript">$("div").css({    "font-size": "16px",    "color": "blue"});</code></pre></li></ul></li><li><p><strong>操作类（Class）：</strong></p><ul><li><p>添加类：</p><pre><code class="JavaScript">$("div").addClass("highlight");</code></pre></li><li><p>移除类：</p><pre><code class="JavaScript">$("div").removeClass("highlight");</code></pre></li><li><p>切换类（存在则移除，不存在则添加）：</p><pre><code class="JavaScript">$("div").toggleClass("highlight");</code></pre></li></ul></li><li><p><strong>检查类是否存在：</strong></p><pre><code class="JavaScript">if ($("div").hasClass("highlight")) {    // 类存在的处理逻辑}</code></pre></li><li><p><strong>操作元素的可见性：</strong></p><ul><li><p>显示元素：</p><pre><code class="JavaScript">$("div").show();</code></pre></li><li><p>隐藏元素：</p><pre><code class="JavaScript">$("div").hide();</code></pre></li><li><p>切换元素的可见性：</p><pre><code class="JavaScript">$("div").toggle();</code></pre></li></ul></li><li><p><strong>设置宽度和高度：</strong></p><pre><code class="JavaScript">$("div").width(200);$("div").height(150);</code></pre></li><li><p><strong>动画效果：</strong></p><ul><li><p>淡入：</p><pre><code class="JavaScript">$("div").fadeIn();</code></pre></li><li><p>淡出：</p><pre><code class="JavaScript">$("div").fadeOut();</code></pre></li><li><p>滑动显示：</p><pre><code class="JavaScript">$("div").slideDown();</code></pre></li><li><p>滑动隐藏：</p><pre><code class="JavaScript">$("div").slideUp();</code></pre></li></ul></li></ol><p>这些是一些基本的 jQuery CSS 操作方法。使用这些方法，你可以方便地操控元素的样式、类、可见性和动画效果。</p><h1 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h1><p>jQuery 中的选择器是一种强大的工具，用于选择 HTML 文档中的元素。以下是一些常用的 jQuery 选择器：</p><ol><li><strong>元素选择器：</strong><ul><li><code>element</code>：选择所有指定类型的元素，例如 <code>p</code> 选择所有段落元素。</li></ul></li><li><strong>ID 选择器：</strong><ul><li><code>#id</code>：选择指定 id 属性的元素，例如 <code>#header</code> 选择 id 为 “header” 的元素。</li></ul></li><li><strong>类选择器：</strong><ul><li><code>.class</code>：选择指定 class 属性的元素，例如 <code>.highlight</code> 选择所有具有 “highlight” 类的元素。</li></ul></li><li><strong>属性选择器：</strong><ul><li><code>[attribute]</code>：选择具有指定属性的元素，例如 <code>[type]</code> 选择所有具有 “type” 属性的元素。</li><li><code>[attribute=value]</code>：选择具有指定属性和值的元素，例如 <code>[name="username"]</code> 选择所有 name 属性值为 “username” 的元素。</li></ul></li><li><strong>通配符选择器：</strong><ul><li><code>*</code>：选择所有元素。</li></ul></li><li><strong>子元素选择器：</strong><ul><li><code>parent &gt; child</code>：选择指定父元素下的子元素，例如 <code>ul &gt; li</code> 选择 ul 下的所有 li 元素。</li></ul></li><li><strong>后代元素选择器：</strong><ul><li><code>ancestor descendant</code>：选择指定祖先元素下的后代元素，例如 <code>div p</code> 选择所有 div 下的 p 元素。</li></ul></li><li><strong>同级元素选择器：</strong><ul><li><code>prev + next</code>：选择紧接在指定元素后面的同级元素，例如 <code>h2 + p</code> 选择紧接在 h2 后面的 p 元素。</li></ul></li><li><strong>相邻元素选择器：</strong><ul><li><code>prev ~ siblings</code>：选择与指定元素在同一级别的所有同级元素，例如 <code>h2 ~ p</code> 选择与 h2 具有相同父元素的所有 p 元素。</li></ul></li><li><strong>过滤选择器：</strong><ul><li><code>:first</code>：选择匹配的第一个元素。</li><li><code>:last</code>：选择匹配的最后一个元素。</li><li><code>:even</code>：选择匹配的偶数索引元素。</li><li><code>:odd</code>：选择匹配的奇数索引元素。</li><li><code>:eq(index)</code>：选择匹配给定索引值的元素。</li></ul></li></ol><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>实现斑马线效果</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.7.1/jquery.min.js"&gt;&lt;/script&gt;    &lt;style&gt;        table{            border-collapse: collapse;            table-layout: fixed;            width: 800px;        }        td{            text-align: center;            margin: 1px solid black;            padding: 8px;        }        tr{            margin-bottom: 1px;            border: 1px solid black;                    }        .odd{            background-color: aqua;        }    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;table&gt;        &lt;tr&gt;            &lt;td&gt;                表头1            &lt;/td&gt;            &lt;td&gt;                表头2            &lt;/td&gt;            &lt;td&gt;                表头3            &lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;                1            &lt;/td&gt;            &lt;td&gt;                2            &lt;/td&gt;            &lt;td&gt;                3            &lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;                1            &lt;/td&gt;            &lt;td&gt;                2            &lt;/td&gt;            &lt;td&gt;                3            &lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;                1            &lt;/td&gt;            &lt;td&gt;                2            &lt;/td&gt;            &lt;td&gt;                3            &lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;                1            &lt;/td&gt;            &lt;td&gt;                2            &lt;/td&gt;            &lt;td&gt;                3            &lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;                1            &lt;/td&gt;            &lt;td&gt;                2            &lt;/td&gt;            &lt;td&gt;                3            &lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;                1            &lt;/td&gt;            &lt;td&gt;                2            &lt;/td&gt;            &lt;td&gt;                3            &lt;/td&gt;        &lt;/tr&gt;    &lt;/table&gt;    &lt;button id="button"&gt;修改&lt;/button&gt;    &lt;script&gt;        $(function(){            $("#button").click(                function(){                    $("table tr:odd").toggleClass("odd");                }            );        });            &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="属性操作"><a href="#属性操作" class="headerlink" title="属性操作"></a>属性操作</h2><p>jQuery 提供了一系列方法，用于操作元素的属性。以下是一些常用的 jQuery 属性操作方法：</p><ol><li><p><strong>获取或设置元素的属性：</strong></p><ul><li><p><code>attr(name)</code>: 获取指定属性的值。</p></li><li><p><code>attr(name, value)</code>: 设置指定属性的值。</p></li><li><p>例子：</p><pre><code class="JavaScript">var value = $("img").attr("src"); // 获取 img 元素的 src 属性值$("img").attr("alt", "New Alt Text"); // 设置 img 元素的 alt 属性值</code></pre></li></ul></li><li><p><strong>删除元素的属性：</strong></p><ul><li><p><code>removeAttr(name)</code>: 删除指定的属性。</p></li><li><p>例子：</p><pre><code class="JavaScript">$("img").removeAttr("alt"); // 删除 img 元素的 alt 属性</code></pre></li></ul></li></ol><h2 id="prop"><a href="#prop" class="headerlink" title="prop"></a>prop</h2><ol><li><p><strong><code>prop</code> 方法：</strong></p><ul><li><p><code>prop</code> 方法用于获取或设置元素的属性值，特别是那些在 HTML 中被定义为属性（而非属性和属性值的形式）的属性，例如 <code>checked</code>、<code>disabled</code> 等。</p></li><li><p><code>prop</code> 方法更适用于处理布尔属性，它返回属性的当前状态，而不仅仅是属性的初始值。</p></li><li><p>例子：</p><pre><code class="JavaScript">var isChecked = $("input").prop("checked"); // 获取第一个 &lt;input&gt; 元素的 checked 属性值$("input").prop("disabled", true); // 设置所有 &lt;input&gt; 元素的 disabled 属性为 true</code></pre></li></ul></li><li><p><strong><code>attr</code> 方法：</strong></p><ul><li><p><code>attr</code> 方法用于获取或设置元素的属性值，包括那些在 HTML 中被定义为属性和属性值的形式的属性，例如 <code>src</code>、<code>alt</code>、<code>class</code> 等。</p></li><li><p><code>attr</code> 方法更适用于处理非布尔属性，它返回属性的字符串值。</p></li><li><p>例子：</p><pre><code class="JavaScript">var srcValue = $("img").attr("src"); // 获取第一个 &lt;img&gt; 元素的 src 属性值$("img").attr("alt", "New Alt Text"); // 设置所有 &lt;img&gt; 元素的 alt 属性值</code></pre></li></ul></li></ol><p><strong>总结：</strong></p><ul><li>使用 <code>prop</code> 主要用于处理布尔属性，例如复选框的 <code>checked</code>、输入框的 <code>disabled</code>。</li><li>使用 <code>attr</code> 主要用于处理其他属性，例如图片的 <code>src</code>、链接的 <code>href</code>、元素的 <code>class</code>。</li></ul><h1 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h1><p>jQuery 提供了一系列用于创建动画和效果的方法。以下是一些常用的 jQuery 效果：</p><ol><li><p><strong>显示和隐藏效果：</strong></p><ul><li><code>show(speed)</code>: 以指定速度显示元素。</li><li><code>hide(speed)</code>: 以指定速度隐藏元素。</li><li><code>toggle(speed)</code>: 切换元素的显示和隐藏状态。</li></ul><pre><code class="JavaScript">$("div").show(1000); // 以1秒的速度显示 div 元素$("div").hide("slow"); // 以慢速度隐藏 div 元素$("div").toggle(500); // 以0.5秒的速度切换 div 元素的显示和隐藏状态</code></pre></li><li><p><strong>淡入和淡出效果：</strong></p><ul><li><code>fadeIn(speed)</code>: 以指定速度淡入元素。</li><li><code>fadeOut(speed)</code>: 以指定速度淡出元素。</li><li><code>fadeToggle(speed)</code>: 切换元素的淡入和淡出状态。</li></ul><pre><code class="JavaScript">$("div").fadeIn("fast"); // 以快速速度淡入 div 元素$("div").fadeOut(1500); // 以1.5秒的速度淡出 div 元素$("div").fadeToggle("slow"); // 以慢速度切换 div 元素的淡入和淡出状态</code></pre></li><li><p><strong>滑动效果：</strong></p><ul><li><code>slideDown(speed)</code>: 以指定速度滑下显示元素。</li><li><code>slideUp(speed)</code>: 以指定速度滑上隐藏元素。</li><li><code>slideToggle(speed)</code>: 切换元素的滑动显示和隐藏状态。</li></ul><pre><code class="JavaScript">$("div").slideDown(1000); // 以1秒的速度滑下显示 div 元素$("div").slideUp("slow"); // 以慢速度滑上隐藏 div 元素$("div").slideToggle(500); // 以0.5秒的速度切换 div 元素的滑动显示和隐藏状态</code></pre></li><li><p><strong>自定义动画效果：</strong></p><ul><li><code>animate(properties, speed, easing, complete)</code>: 通过指定的 CSS 属性进行自定义动画。</li></ul><pre><code class="JavaScript">$("div").animate({ left: '250px', opacity: '0.5' }, "slow");</code></pre></li></ol><h2 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h2><p>使得表格变长变短</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.7.1/jquery.min.js"&gt;&lt;/script&gt;    &lt;style&gt;        table{            border-collapse: collapse;            table-layout: fixed;            width: 800px;        }        td{            text-align: center;            margin: 1px solid black;            padding: 8px;                    }        tr{            height: 50px;            margin-bottom: 1px;            border: 1px solid black;                    }        .odd{            background-color: aqua;        }    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;table&gt;        &lt;tr&gt;            &lt;td&gt;                表头1            &lt;/td&gt;            &lt;td&gt;                表头2            &lt;/td&gt;            &lt;td&gt;                表头3            &lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;                1            &lt;/td&gt;            &lt;td&gt;                2            &lt;/td&gt;            &lt;td&gt;                3            &lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;                1            &lt;/td&gt;            &lt;td&gt;                2            &lt;/td&gt;            &lt;td&gt;                3            &lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;                1            &lt;/td&gt;            &lt;td&gt;                2            &lt;/td&gt;            &lt;td&gt;                3            &lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;                1            &lt;/td&gt;            &lt;td&gt;                2            &lt;/td&gt;            &lt;td&gt;                3            &lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;                1            &lt;/td&gt;            &lt;td&gt;                2            &lt;/td&gt;            &lt;td&gt;                3            &lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;                1            &lt;/td&gt;            &lt;td&gt;                2            &lt;/td&gt;            &lt;td&gt;                3            &lt;/td&gt;        &lt;/tr&gt;    &lt;/table&gt;    &lt;button id="button"&gt;修改&lt;/button&gt;    &lt;button id="long"&gt;缓慢变长&lt;/button&gt;    &lt;button id="short"&gt;缓慢变短&lt;/button&gt;    &lt;script&gt;        $(function(){            $("#button").click(                function(){                    $("table tr:odd").toggleClass("odd");                }            );        });        $(            function(){                $("#long").click(                    function(){                        $("tr:even").animate({height : "100px"}, 1000);                    }                );                $("#short").click(                    function(){                        $("tr:even").animate({height : "50px"}, 1000);                    }                );            }        );    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><p>在 jQuery 中，事件是与用户交互或浏览器操作相关的行为，例如点击、鼠标悬停、键盘输入等。jQuery 提供了一系列方法来处理和绑定这些事件。以下是一些常用的 jQuery 事件：</p><ol><li><p><strong>鼠标事件：</strong></p><ul><li><code>click()</code>: 当元素被点击时触发。</li><li><code>dblclick()</code>: 当元素被双击时触发。</li><li><code>mousedown()</code>: 当鼠标按下时触发。</li><li><code>mouseup()</code>: 当鼠标释放时触发。</li><li><code>mousemove()</code>: 当鼠标在元素上移动时触发。</li><li><code>mouseover()</code>: 当鼠标移入元素时触发。</li><li><code>mouseout()</code>: 当鼠标移出元素时触发。</li></ul><pre><code class="JavaScript">$("button").click(function() {    alert("Button Clicked!");});$("div").mouseover(function() {    $(this).css("background-color", "yellow");});</code></pre></li><li><p><strong>键盘事件：</strong></p><ul><li><code>keydown()</code>: 当键盘按下任意键时触发。</li><li><code>keypress()</code>: 当键盘按下字符键时触发。</li><li><code>keyup()</code>: 当键盘释放任意键时触发。</li></ul><pre><code class="JavaScript">$(document).keydown(function(event) {    console.log("Key pressed: " + event.key);});</code></pre></li><li><p><strong>表单事件：</strong></p><ul><li><code>submit()</code>: 当表单提交时触发。</li><li><code>change()</code>: 当表单元素的值发生改变时触发。</li><li><code>focus()</code>: 当元素获得焦点时触发。</li><li><code>blur()</code>: 当元素失去焦点时触发。</li></ul><pre><code class="JavaScript">$("form").submit(function(event) {    event.preventDefault(); // 阻止表单提交    alert("Form Submitted!");});$("input").change(function() {    console.log("Input value changed: " + $(this).val());});</code></pre></li><li><p><strong>窗口事件：</strong></p><ul><li><code>resize()</code>: 当浏览器窗口大小发生改变时触发。</li><li><code>scroll()</code>: 当页面滚动时触发。</li></ul><pre><code class="JavaScript">$(window).resize(function() {    console.log("Window resized!");});$(window).scroll(function() {    console.log("Page scrolled!");});</code></pre></li></ol><h1 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h1><p>在 jQuery 中，你可以使用 <code>$.ajax()</code> 方法来执行 AJAX 请求。这个方法提供了一种简单且灵活的方式来发送异步 HTTP 请求。以下是一个基本的使用示例：</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;  &lt;meta charset="UTF-8"&gt;  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;  &lt;title&gt;AJAX with jQuery&lt;/title&gt;  &lt;script src="https://code.jquery.com/jquery-3.6.4.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt;  // 发送一个简单的 GET 请求  $.ajax({    url: 'https://jsonplaceholder.typicode.com/todos/1', // 请求的 URL    method: 'GET', // 请求方法    dataType: 'json', // 期望的数据类型    success: function(data) {      // 请求成功时的回调函数      console.log('Response:', data);    },    error: function(jqXHR, textStatus, errorThrown) {      // 请求失败时的回调函数      console.error('Error:', errorThrown);    }  });&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>在这个例子中，<code>$.ajax()</code> 方法用于向 JSONPlaceholder 发送一个简单的 GET 请求。你可以根据实际需求调整 URL、请求方法、数据类型等参数。</p><p>常见的 <code>$.ajax()</code> 方法参数包括：</p><ul><li><code>url</code>: 请求的 URL。</li><li><code>method</code>: 请求方法，例如 ‘GET’、’POST’ 等。</li><li><code>data</code>: 发送到服务器的数据，可以是字符串或对象。</li><li><code>dataType</code>: 期望的数据类型，例如 ‘json’、’html’ 等。</li><li><code>success</code>: 请求成功时的回调函数。</li><li><code>error</code>: 请求失败时的回调函数。</li><li>其他可选参数，如 <code>headers</code>、<code>contentType</code> 等。</li></ul><p>如果你想使用简化的方法，例如 <code>$.get()</code> 或 <code>$.post()</code>，也可以根据请求类型选择适当的方法。例如：</p><pre><code class="JavaScript">// 使用 $.get() 发送 GET 请求$.get('https://jsonplaceholder.typicode.com/todos/1', function(data) {  console.log('Response:', data);});// 使用 $.post() 发送 POST 请求$.post('https://jsonplaceholder.typicode.com/posts', { title: 'foo', body: 'bar', userId: 1 }, function(data) {  console.log('Response:', data);});</code></pre><p>这些方法提供了更简洁的语法，适用于特定类型的请求。</p><h1 id="trim"><a href="#trim" class="headerlink" title="trim"></a>trim</h1><pre><code class="html">&lt;script&gt;    $.trim("  Hello  ss!   ");&lt;/script&gt;</code></pre><p>去除首尾的空白。</p><h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><p>在 jQuery 中，可以使用 <code>$.parseJSON()</code> 方法将 JSON 字符串转换为 JavaScript 对象，而使用 <code>$.stringify()</code> 方法将 JavaScript 对象转换为 JSON 字符串。下面是简单的示例：</p><ol><li><p><strong>JSON字符串转为JavaScript对象：</strong></p><pre><code class="JavaScript">var jsonString = '{"name": "John", "age": 30, "city": "New York"}';var jsonObject = $.parseJSON(jsonString);// 现在，jsonObject 就是一个 JavaScript 对象console.log(jsonObject.name); // 输出: Johnconsole.log(jsonObject.age);  // 输出: 30console.log(jsonObject.city); // 输出: New York</code></pre></li><li><p><strong>JavaScript对象转为JSON字符串：</strong></p><pre><code class="JavaScript">var jsonObject = {name: "John", age: 30, city: "New York"};var jsonString = $.stringify(jsonObject);// 现在，jsonString 就是一个 JSON 字符串console.log(jsonString); // 输出: {"name":"John","age":30,"city":"New York"}</code></pre></li></ol><p>请注意，在较新的 JavaScript 中，通常使用原生的 <code>JSON.parse()</code> 和 <code>JSON.stringify()</code> 来完成相同的任务。如果你不依赖于 jQuery 的其他功能，使用原生的 JSON 方法可能更为推荐。例如：</p><pre><code class="JavaScript">// JSON字符串转为JavaScript对象var jsonString = '{"name": "John", "age": 30, "city": "New York"};var jsonObject = JSON.parse(jsonString);// JavaScript对象转为JSON字符串var jsonObject = {name: "John", age: 30, city: "New York"};var jsonString = JSON.stringify(jsonObject);</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>学习记录之JSP</title>
      <link href="/2023/12/26/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E4%B9%8BJSP/"/>
      <url>/2023/12/26/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E4%B9%8BJSP/</url>
      
        <content type="html"><![CDATA[<h1 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h1><p>JSP（JavaServer Pages）是一种用于创建动态Web页面的Java技术。它允许开发人员将Java代码嵌入HTML页面中，以生成动态内容。JSP是在服务器端执行的，它与Servlet一起用于构建Web应用程序。</p><p>以下是关于JSP的一些关键点：</p><ol><li><strong>动态内容生成：</strong> JSP允许将Java代码嵌入到HTML页面中，使开发人员能够轻松地生成动态内容。这些Java代码被包装在特殊的标签 <code>&lt;% %&gt;</code> 中。</li><li><strong>易于学习和使用：</strong> 对于熟悉HTML和Java的开发人员而言，学习和使用JSP相对容易。JSP页面的外观类似于常规的HTML页面，但具有嵌入的Java代码。</li><li><strong>与Servlet结合使用：</strong> JSP本质上是Servlet的一种简化形式。当JSP页面首次被访问时，容器会将其转换为一个Servlet，并在后续请求中直接执行已编译的Servlet，以提高性能。</li><li><strong>标签库（Tag Libraries）：</strong> JSP支持使用标签库来简化页面中的Java代码。标签库提供了一组自定义标签，可用于执行特定的任务，例如访问数据库、控制流程等。</li><li><strong>分离业务逻辑和显示逻辑：</strong> JSP有助于将业务逻辑和显示逻辑分开，使得在Web应用程序中更容易维护和管理。</li><li><strong>易于集成：</strong> JSP可以轻松地与Java EE（Enterprise Edition）平台的其他技术集成，例如Servlet、EJB（Enterprise JavaBeans）、JavaBeans等。</li><li><strong>支持Java标准库：</strong> JSP支持使用Java标准库中的类和方法，这意味着开发人员可以充分利用Java的强大功能。</li></ol><h1 id="第一个JSP界面"><a href="#第一个JSP界面" class="headerlink" title="第一个JSP界面"></a>第一个JSP界面</h1><pre><code class="jsp">&lt;%--  Created by IntelliJ IDEA.  User: 7878  Date: 2023/12/26  Time: 14:52  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><ol><li><code>&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;</code>: 这是一个页面指令，用于设置页面的一些属性。<ul><li><code>contentType</code>: 指定响应内容的类型为”text/html”，表示输出的内容是HTML格式的。</li><li><code>charset="UTF-8"</code>: 指定字符集为UTF-8，确保正确处理包含非英文字符的文本。</li><li><code>language="java"</code>: 指定在页面中使用的主要编程语言为Java。</li></ul></li><li><code>&lt;html&gt;</code>、<code>&lt;head&gt;</code>、<code>&lt;title&gt;</code>、<code>&lt;body&gt;</code>: 这些标签构成了HTML文档的基本结构。</li></ol><pre><code class="jsp">&lt;h1&gt;Hello, &lt;%= new Date().toLocaleString()%&gt;!&lt;/h1&gt;</code></pre><p>在首部写入,以导入所需要的包。</p><pre><code>&lt;%@ page import="java.util.*" %&gt;</code></pre><h1 id="页面元素"><a href="#页面元素" class="headerlink" title="页面元素"></a>页面元素</h1><p>JSP 页面通常包含以下主要元素：</p><ol><li><p><strong>HTML 标记：</strong> JSP 页面可以包含标准的 HTML 标记，用于定义页面的结构、样式和布局。</p><pre><code class="jsp">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;My JSP Page&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;Hello, World!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</code></pre></li><li><p><strong>JSP 指令：</strong> JSP 页面中的指令以 <code>&lt;%@</code> 开始，用于提供有关页面的全局信息。</p><pre><code class="jsp">&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;</code></pre></li><li><p><strong>JSP 声明：</strong> JSP 声明用于定义在生成的 Servlet 类中的成员变量和方法。</p><pre><code class="jsp">&lt;%!int counter = 0;%&gt;</code></pre></li><li><p><strong>JSP 表达式：</strong> JSP 表达式用于在页面中嵌入 Java 表达式的结果。</p><pre><code class="jsp">&lt;p&gt;The current counter value is &lt;%= counter %&gt;&lt;/p&gt;</code></pre></li><li><p><strong>JSP 脚本：</strong> JSP 脚本用于插入 Java 代码块，可以包含任意有效的 Java 代码。</p><pre><code class="jsp">&lt;% String message = "Hello, JSP!";out.println(message);%&gt;</code></pre></li><li><p><strong>动作元素：</strong> JSP 提供了一些称为动作元素的特殊标签，用于执行特定的操作，如转发请求、包含其他页面等。</p><pre><code class="jsp">&lt;jsp:include page="header.jsp" /&gt;</code></pre></li></ol><p>这些元素的组合使得开发者能够在 HTML 页面中嵌入动态内容，利用 Java 代码生成页面的部分或全部内容。</p><p><img src="/../images/image-20231226151351362.png" alt="image-20231226151351362"></p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>jsp循环打印效果</p><p><img src="/../images/image-20231226152405548.png" alt="image-20231226152405548"></p><pre><code class="jsp">&lt;%--  Created by IntelliJ IDEA.  User: 7878  Date: 2023/12/26  Time: 15:15  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType="text/html;charset=UTF-8" language="java" import="java.util.*" %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;%        List&lt;String&gt; list = new ArrayList&lt;&gt;();        list.add("Today");        list.add("is");        list.add("a");        list.add("good");        list.add("day");    %&gt;&lt;table style="align-content: center; width:200px; border-collapse: collapse"&gt;    &lt;% for(String word: list){ %&gt;        &lt;tr&gt;            &lt;td&gt; &lt;%=word%&gt; &lt;/td&gt;        &lt;/tr&gt;    &lt;%}%&gt;&lt;/table&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h1 id="include"><a href="#include" class="headerlink" title="include"></a>include</h1><p>在JSP中，<code>&lt;%@ include %&gt;</code> 指令用于包含其他文件的内容。通过使用 include 指令，可以将一个文件的内容嵌入到另一个 JSP 文件中。这样可以方便地重用和组织代码。</p><p>以下是使用 <code>&lt;%@ include %&gt;</code> 指令的基本语法：</p><pre><code class="jsp">&lt;%@ include file="relative_path_to_included_file.jsp" %&gt;</code></pre><p>其中，<code>file</code> 属性指定了要包含的文件的相对路径。这个路径是相对于包含文件的 JSP 文件的路径的。</p><p>如果需要在包含的文件之间传递参数，可以考虑使用动态包含，即 <code>&lt;jsp:include&gt;</code> 标签。</p><p>以下是使用 <code>&lt;jsp:include&gt;</code> 标签传递参数的示例：</p><p>假设有一个包含参数的 JSP 文件 <code>included.jsp</code>：</p><pre><code class="jsp">&lt;%-- included.jsp --%&gt;&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;Included Page&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h2&gt;Value from included page: &lt;%= request.getParameter("param1") %&gt;&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>然后，在主 JSP 文件中使用 <code>&lt;jsp:include&gt;</code> 标签并传递参数：</p><pre><code class="jsp">&lt;%-- main.jsp --%&gt;&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;Main Page&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;Main Page&lt;/h1&gt;    &lt;%-- Pass parameter to the included page --%&gt;    &lt;jsp:include page="included.jsp"&gt;        &lt;jsp:param name="param1" value="Hello from main.jsp" /&gt;    &lt;/jsp:include&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h1 id="页面跳转"><a href="#页面跳转" class="headerlink" title="页面跳转"></a>页面跳转</h1><p>在JSP中，可以使用不同的方式来实现页面的跳转。以下是一些常见的方法：</p><ol><li><p><strong>使用 <code>&lt;jsp:forward&gt;</code> 标签：</strong></p><pre><code class="jsp">&lt;jsp:forward page="targetPage.jsp" /&gt;</code></pre><p>这个标签用于在当前JSP页面内执行服务器端跳转。<code>page</code> 属性指定要跳转的目标页面。</p></li><li><p><strong>使用 <code>&lt;% response.sendRedirect("targetPage.jsp"); %&gt;</code>：</strong> 在脚本元素中使用<code>response.sendRedirect</code>方法进行客户端跳转。这会向浏览器发送一个重定向响应，让浏览器重新请求指定的目标页面。</p><pre><code class="jsp">&lt;% response.sendRedirect("targetPage.jsp"); %&gt;</code></pre></li><li><p><strong>使用相对路径或绝对路径：</strong> 直接使用超链接或表单的 <code>action</code> 属性指定目标页面的路径，可以是相对路径或绝对路径。</p><pre><code class="jsp">&lt;!-- 使用超链接 --&gt;&lt;a href="targetPage.jsp"&gt;跳转到目标页面&lt;/a&gt;&lt;!-- 使用表单 --&gt;&lt;form action="targetPage.jsp" method="post"&gt;    &lt;!-- 表单内容 --&gt;    &lt;input type="submit" value="提交" /&gt;&lt;/form&gt;</code></pre></li></ol><h1 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h1><p>在JSP中，你可以使用<code>Cookie</code>对象来处理HTTP cookie。Cookie是在客户端（浏览器）和服务器之间传递的小型文本数据，用于在请求之间保持状态信息。以下是在JSP中使用Cookie的基本步骤：</p><ol><li><p><strong>创建Cookie：</strong> 在JSP页面中，你可以使用Java代码创建一个Cookie对象。通常，你会在服务器端脚本中执行这些操作。</p><pre><code class="jsp">&lt;%     Cookie myCookie = new Cookie("cookieName", "cookieValue");    // 设置Cookie的存在时间为一天（60秒 * 60分钟 * 24小时）       myCookie.setMaxAge(60 * 60 * 24);    response.addCookie(myCookie);%&gt;</code></pre><p>上述代码创建了一个名为 “cookieName”，值为 “cookieValue” 的Cookie对象，并通过<code>response.addCookie</code>方法将其添加到HTTP响应中。</p></li><li><p><strong>读取Cookie：</strong> 你可以在后续的请求中读取Cookie，以获取先前存储的信息。</p><pre><code class="jsp">&lt;%     Cookie[] cookies = request.getCookies();    if (cookies != null) {        for (Cookie cookie : cookies) {            if ("cookieName".equals(cookie.getName())) {                String cookieValue = cookie.getValue();                // 处理Cookie值            }        }    }%&gt;</code></pre><p>上述代码使用<code>request.getCookies()</code>获取请求中的所有Cookie，然后通过遍历找到名为 “cookieName” 的Cookie并获取其值。</p></li></ol><blockquote><p>Cookie的路径属性规定了哪些路径下的页面可以访问该Cookie。当服务器创建一个Cookie并发送到客户端时，可以通过设置Cookie的路径来限定哪些路径下的页面可以访问这个Cookie。这有助于控制Cookie的作用范围，增加了一定的安全性和灵活性。</p><p>具体来说，当浏览器向服务器发送请求时，只有在与Cookie的路径匹配的页面才会将相应的Cookie包含在请求中。这有助于确保Cookie仅在需要的上下文中被发送，而不是在整个域中。</p><p>例如，如果设置了以下Cookie：</p><pre><code class="jsp">&lt;%   Cookie myCookie = new Cookie("cookieName", "cookieValue");   myCookie.setPath("/myapp");   response.addCookie(myCookie);%&gt;</code></pre><p>这个Cookie的路径被设置为”/myapp”，那么它只会被发送到路径为”/myapp”及其子路径下的页面。如果在”/myapp/page1.jsp”中发送请求，浏览器将携带该Cookie。但如果在”/otherapp/page2.jsp”中发送请求，该Cookie将不会被包含在请求中。</p><p>这个路径属性提供了一种方式来限制Cookie的范围，以确保Cookie只在需要的上下文中被传递，从而提高安全性。</p></blockquote><h2 id="实践观察"><a href="#实践观察" class="headerlink" title="实践观察"></a>实践观察</h2><pre><code class="jsp">&lt;%--  Created by IntelliJ IDEA.  User: 7878  Date: 2023/12/27  Time: 13:04  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;%        Cookie mycookie = new Cookie("id", "1");        mycookie.setMaxAge(60 * 60 * 24);        mycookie.setPath("/");        response.addCookie(mycookie);        Cookie mycookie2 = new Cookie("password", "666");        mycookie2.setMaxAge(60 * 60 * 24);        mycookie2.setPath("/");        response.addCookie(mycookie2);    %&gt;    &lt;a href=""&lt;/body&gt;&lt;/html&gt;</code></pre><pre><code class="jsp">&lt;%--  Created by IntelliJ IDEA.  User: 7878  Date: 2023/12/27  Time: 13:07  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;%    Cookie[] cookies = request.getCookies();    if (cookies != null) {        for (Cookie cookie : cookies) {%&gt;    &lt;div&gt;&lt;%= cookie.getName() %&gt;&lt;/div&gt;    &lt;div&gt;&lt;%= cookie.getValue() %&gt;&lt;/div&gt;&lt;%        }    }%&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>观察方式</p><p><img src="/../images/image-20231227131608927.png" alt="image-20231227131608927"></p><p><img src="/../images/image-20231227131622311.png" alt="image-20231227131622311"></p><h1 id="session"><a href="#session" class="headerlink" title="session"></a>session</h1><p>在JSP中，可以使用<code>session</code>对象来管理用户的会话信息。<code>session</code>对象在整个用户会话期间保存数据，这意味着用户在不同的页面之间可以共享和保持状态。以下是一些常见的<code>session</code>的使用方法：</p><ol><li><p><strong>存储数据到<code>session</code>中：</strong></p><pre><code class="jsp">&lt;%     // 获取或创建一个session对象    HttpSession session = request.getSession();        // 存储数据到session中    session.setAttribute("username", "john_doe");%&gt;</code></pre><p>在上述代码中，<code>getSession</code>方法获取或创建与当前请求相关联的<code>session</code>对象，然后通过<code>setAttribute</code>方法将名为 “username” 的属性设置为 “john_doe”。</p></li><li><p><strong>从<code>session</code>中获取数据：</strong></p><pre><code class="jsp">&lt;%     // 获取session对象    HttpSession session = request.getSession();        // 从session中获取数据    String username = (String) session.getAttribute("username");%&gt;</code></pre><p>上述代码从<code>session</code>中获取名为 “username” 的属性值，并将其存储在字符串变量 <code>username</code> 中。请注意，由于<code>session</code>中存储的是<code>Object</code>类型，因此需要进行类型转换。</p></li><li><p><strong>销毁<code>session</code>：</strong></p><pre><code class="jsp">&lt;%     // 获取session对象    HttpSession session = request.getSession();        // 销毁session    session.invalidate();%&gt;</code></pre><p>上述代码调用<code>invalidate</code>方法销毁当前<code>session</code>，这将清除所有与<code>session</code>相关的数据。</p></li><li><p><strong>设置<code>session</code>的超时时间：</strong></p><pre><code class="jsp">&lt;%     // 获取session对象    HttpSession session = request.getSession();        // 设置session的超时时间（以秒为单位，例如设置为30分钟）    session.setMaxInactiveInterval(30 * 60);%&gt;</code></pre><p>上述代码使用<code>setMaxInactiveInterval</code>方法设置<code>session</code>的超时时间，单位是秒。</p></li></ol><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><pre><code class="jsp">&lt;%--  Created by IntelliJ IDEA.  User: 7878  Date: 2023/12/27  Time: 13:51  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;%    HttpSession httpSession = request.getSession();    httpSession.setAttribute("name", "iphan");    httpSession.setMaxInactiveInterval(60 * 30);%&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><pre><code class="jsp">&lt;%--  Created by IntelliJ IDEA.  User: 7878  Date: 2023/12/27  Time: 13:52  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;%    HttpSession httpSession = request.getSession();%&gt;&lt;h1 style="color: green; background-color: red"&gt;&lt;%= httpSession.getAttribute("name")%&gt;&lt;/h1&gt;&lt;%%&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="/../images/image-20231227135937464.png" alt="image-20231227135937464"></p><h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><p>在JSP中，作用域（Scope）指的是变量的可见性和生存期，即变量在程序中的访问范围和存活时间。JSP定义了四个主要的作用域，它们是：</p><ol><li><p><strong>Page（页面作用域）：</strong></p><ul><li>页面作用域是最短的作用域，变量在当前页面有效，不同页面之间的变量不互相影响。</li><li>页面作用域的变量在页面的任何地方都可以访问。</li></ul><pre><code class="jsp">&lt;%@ page import="java.util.ArrayList" %&gt;&lt;% ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); %&gt;&lt;% pageContext.setAttribute("pageList", list); %&gt;</code></pre></li><li><p><strong>Request（请求作用域）：</strong></p><ul><li>请求作用域在一次HTTP请求中有效，当请求被处理后，这个作用域中的变量将被销毁。</li><li>不同的请求之间的变量不互相影响。</li></ul><pre><code class="jsp">&lt;%@ page import="java.util.HashMap" %&gt;&lt;% HashMap&lt;String, Object&gt; data = new HashMap&lt;&gt;(); %&gt;&lt;% request.setAttribute("requestData", data); %&gt;</code></pre></li><li><p><strong>Session（会话作用域）：</strong></p><ul><li>会话作用域在用户的整个会话期间有效，直到用户关闭浏览器或会话超时。</li><li>不同用户之间的变量不互相影响。</li></ul><pre><code class="jsp">&lt;%@ page import="java.util.Date" %&gt;&lt;% Date loginTime = new Date(); %&gt;&lt;% session.setAttribute("loginTime", loginTime); %&gt;</code></pre></li><li><p><strong>Application（应用作用域）：</strong></p><ul><li>应用作用域在整个Web应用程序的生命周期中有效，直到服务器关闭或应用被卸载。</li><li>在同一个应用程序中的不同页面之间共享变量。</li></ul><pre><code class="jsp">&lt;%@ page import="java.util.HashMap" %&gt;&lt;% HashMap&lt;String, String&gt; config = new HashMap&lt;&gt;(); %&gt;&lt;% application.setAttribute("appConfig", config); %&gt;</code></pre></li></ol><p>这些作用域允许在不同的层次上存储和检索数据，使得在页面、请求、会话和应用程序级别上共享和保持状态成为可能。选择正确的作用域取决于变量的生命周期和需要在哪个级别上共享数据。</p><h1 id="JSTL"><a href="#JSTL" class="headerlink" title="JSTL"></a>JSTL</h1><p>JSTL（JavaServer Pages Standard Tag Library）是一个用于简化JSP页面开发的标准标签库。它是在JSP规范中定义的一组标签和函数，旨在提供更简洁和可维护的JSP页面编写方式。JSTL的标签和函数可用于执行各种常见的任务，如条件判断、循环、格式化文本、访问集合等。</p><p>以下是JSTL提供的主要标签库：</p><ol><li><strong>Core Tags (<code>&lt;c:&gt;</code>):</strong> 提供用于控制流程、变量赋值、迭代和其他基本操作的标签。<ul><li>例如，<code>&lt;c:if&gt;</code>, <code>&lt;c:forEach&gt;</code>, <code>&lt;c:set&gt;</code>等。</li></ul></li><li><strong>Formatting Tags (<code>&lt;fmt:&gt;</code>):</strong> 提供格式化和本地化支持的标签，用于格式化日期、数字和消息。<ul><li>例如，<code>&lt;fmt:formatDate&gt;</code>, <code>&lt;fmt:formatNumber&gt;</code>, <code>&lt;fmt:message&gt;</code>等。</li></ul></li><li><strong>SQL Tags (<code>&lt;sql:&gt;</code>):</strong> 用于执行SQL查询的标签。这部分标签在现代的Java Web应用中并不常用，因为通常将数据库操作放在Java代码中。<ul><li>例如，<code>&lt;sql:query&gt;</code>, <code>&lt;sql:update&gt;</code>等。</li></ul></li><li><strong>XML Tags (<code>&lt;x:&gt;</code>):</strong> 提供在JSP中处理XML的标签。<ul><li>例如，<code>&lt;x:parse&gt;</code>, <code>&lt;x:out&gt;</code>, <code>&lt;x:forEach&gt;</code>等。</li></ul></li></ol><p>使用JSTL的优点包括：</p><ul><li><strong>简化代码：</strong> JSTL标签库提供了一组高级抽象，可以用更简洁的标签替代一些繁琐的Java代码。</li><li><strong>可读性：</strong> JSTL标签可以使JSP页面更易读和维护，减少了在JSP中嵌入Java代码的需求。</li><li><strong>模块化：</strong> 可以将JSTL标签视为一种模块，通过在多个JSP页面中重用，提高了代码的可维护性。</li></ul><p>为了使用JSTL，你需要在JSP页面的开头引入JSTL标签库的声明，例如：</p><pre><code class="jsp">&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %&gt;&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/fmt" prefix="fmt" %&gt;</code></pre><h2 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h2><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;jakarta.servlet.jsp.jstl&lt;/groupId&gt;    &lt;artifactId&gt;jakarta.servlet.jsp.jstl-api&lt;/artifactId&gt;    &lt;version&gt;2.0.0&lt;/version&gt;    &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.glassfish.web&lt;/groupId&gt;    &lt;artifactId&gt;jakarta.servlet.jsp.jstl&lt;/artifactId&gt;    &lt;version&gt;2.0.0&lt;/version&gt;&lt;/dependency&gt;</code></pre><h2 id="常用标签"><a href="#常用标签" class="headerlink" title="常用标签"></a>常用标签</h2><p>JSTL Core标签库提供了一组用于控制流程、变量赋值、迭代和其他基本操作的标签。以下是JSTL Core标签库中一些常用的标签：</p><ol><li><p><strong><code>&lt;c:out&gt;</code>：</strong> 用于在页面上输出数据，可以防范XSS攻击。</p><pre><code class="jsp">&lt;c:out value="${variable}" /&gt;</code></pre></li><li><p><strong><code>&lt;c:set&gt;</code>：</strong> 用于设置变量。</p><pre><code class="jsp">&lt;c:set var="name" value="John" /&gt;&lt;c:set var="name" value="${'aaa'}" /&gt;</code></pre></li><li><p><strong><code>&lt;c:remove&gt;</code>：</strong> 用于删除指定的变量。</p><pre><code class="jsp">&lt;c:remove var="name" /&gt;</code></pre></li><li><p><strong><code>&lt;c:if&gt;</code>：</strong> 用于条件判断。没有else，条件取反就是else。</p><pre><code class="jsp">&lt;c:if test="${condition}"&gt;    &lt;!-- 内容 --&gt;&lt;/c:if&gt;</code></pre></li><li><p><strong><code>&lt;c:choose&gt;</code>, <code>&lt;c:when&gt;</code>, <code>&lt;c:otherwise&gt;</code>：</strong> 用于多分支条件判断。</p><pre><code class="jsp">&lt;c:choose&gt;    &lt;c:when test="${condition1}"&gt;        &lt;!-- 内容1 --&gt;    &lt;/c:when&gt;    &lt;c:when test="${condition2}"&gt;        &lt;!-- 内容2 --&gt;    &lt;/c:when&gt;    &lt;c:otherwise&gt;        &lt;!-- 默认内容 --&gt;    &lt;/c:otherwise&gt;&lt;/c:choose&gt;</code></pre></li><li><p><strong><code>&lt;c:forEach&gt;</code>：</strong> 用于循环遍历集合。</p><pre><code class="jsp">&lt;c:forEach var="item" items="${collection}"&gt;    &lt;!-- 内容 --&gt;&lt;/c:forEach&gt;</code></pre></li><li><p><strong><code>&lt;c:import&gt;</code>：</strong> 用于包含其他页面或资源。</p><pre><code class="jsp">&lt;c:import url="path/to/resource.jsp" /&gt;</code></pre></li><li><p><strong><code>&lt;c:url&gt;</code>：</strong> 用于构建URL。</p><pre><code class="jsp">&lt;c:url value="/path/to/page.jsp" var="urlVar" /&gt;</code></pre></li><li><p><strong><code>&lt;c:param&gt;</code>：</strong> 用于在URL中设置参数。</p><pre><code class="jsp">&lt;c:param name="paramName" value="paramValue" /&gt;</code></pre></li><li><p><strong><code>&lt;c:redirect&gt;</code>：</strong> 用于重定向到另一个URL。</p><pre><code class="jsp">&lt;c:redirect url="newPage.jsp" /&gt;</code></pre></li></ol><h1 id="EL-表达式"><a href="#EL-表达式" class="headerlink" title="EL 表达式"></a>EL 表达式</h1><p>EL（Expression Language，表达式语言）是一种用于在JavaEE平台上简化表达式的语言。在JSP页面中，EL 提供了一种简便的方式来访问 JavaBean 中的属性、调用方法、访问集合等。</p><p>以下是 EL 的一些基本特性和用法：</p><ol><li><strong>变量引用：</strong> 使用 <code>${}</code> 语法，可以引用变量的值。例如，<code>${name}</code> 可以引用名为 “name” 的变量的值。</li><li><strong>属性访问：</strong> EL 允许通过点号 <code>.</code> 访问对象的属性。例如，<code>${user.name}</code> 可以访问名为 “user” 的对象的 “name” 属性。</li><li><strong>集合访问：</strong> EL 支持对集合和数组的访问。例如，<code>${list[0]}</code> 可以获取列表的第一个元素。</li><li><strong>算术和逻辑运算：</strong> EL 支持常见的算术和逻辑运算。例如，<code>${x + y}</code> 表示 x 和 y 的和。</li><li><strong>方法调用：</strong> EL 支持调用对象的方法。例如，<code>${user.getName()}</code> 表示调用 “user” 对象的 “getName” 方法。</li><li><strong>条件运算符：</strong> EL 提供了条件运算符（三元运算符）<code>?:</code>，用于简化条件判断。例如，<code>${score &gt;= 60 ? 'Pass' : 'Fail'}</code> 表示如果分数大于等于60，则返回 “Pass”，否则返回 “Fail”。</li></ol><p>为了保证EL表达式能够正常使用，需要在&lt;%@page 标签里加上<strong>isELIgnored=”false”</strong></p><pre><code class="jsp">&lt;%--  Created by IntelliJ IDEA.  User: 7878  Date: 2023/12/27  Time: 14:21  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType="text/html;charset=UTF-8" language="java"  %&gt;&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %&gt;&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/fmt" prefix="fmt" %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;%    String name11 = "iphan";//    我的java代码中也可以设置    session.setAttribute("myname", name11);%&gt;&lt;%--jstl同样可以设置--%&gt;    &lt;c:set  var="name" value="23" scope="session"/&gt;&lt;%--采用jstl取出数据--%&gt;    &lt;c:out value="${name}"/&gt;&lt;%--采用EL表达式取出数据--%&gt;    &lt;h1&gt;${name}&lt;/h1&gt;    &lt;h2&gt;${myname}&lt;/h2&gt;&lt;%    System.out.println(name11);%&gt;&lt;/body&gt;&lt;/html&gt;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习记录之Servlet</title>
      <link href="/2023/12/20/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E4%B9%8BServlet/"/>
      <url>/2023/12/20/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E4%B9%8BServlet/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Servlet"><a href="#1-Servlet" class="headerlink" title="1 Servlet"></a>1 Servlet</h1><h2 id="1-2-调用流程"><a href="#1-2-调用流程" class="headerlink" title="1.2 调用流程"></a>1.2 调用流程</h2><ol><li><strong>客户端发起请求：</strong> 客户端通过浏览器或其他客户端发送 HTTP 请求到服务器。</li><li><strong>Web服务器接收请求：</strong> Web 服务器（如Tomcat）接收到客户端的请求。</li><li><strong>Servlet容器处理请求：</strong> Servlet 容器（如Tomcat的Catalina）负责解析 HTTP 请求，确定请求的 Servlet，并调用相应的 Servlet。</li><li><strong>加载和实例化 Servlet：</strong> 如果请求的 Servlet 尚未加载或实例化，Servlet 容器将加载并实例化相应的 Servlet 类。</li><li><strong>调用Servlet的service方法：</strong> Servlet 容器调用 Servlet 的 <code>service</code> 方法，并将请求和响应对象传递给该方法。</li><li><strong>Servlet处理请求：</strong> 在 <code>service</code> 方法中，开发人员编写的 Servlet 处理客户端的请求，生成响应内容。</li><li><strong>生成响应：</strong> Servlet 通过操作响应对象生成 HTML 页面或其他类型的响应内容。</li><li><strong>发送响应给客户端：</strong> Servlet 将生成的响应通过响应对象发送回客户端。</li><li><strong>Servlet容器处理响应：</strong> Servlet 容器接收到 Servlet 生成的响应后，将其发送给客户端，完成整个请求-响应周期。</li></ol><h2 id="1-3-service（）"><a href="#1-3-service（）" class="headerlink" title="1.3 service（）"></a>1.3 service（）</h2><ul><li><code>service</code> 方法是Servlet中处理请求的主要入口，负责分发请求到具体的处理方法。</li><li><code>doGet</code> 方法用于处理GET请求，适合从服务器获取数据。</li><li><code>doPost</code> 方法用于处理POST请求，适合向服务器提交数据。</li><li>一般情况下，如果你只关心一种请求类型，你可以选择只覆盖 <code>doGet</code> 或 <code>doPost</code> 中的一个。如果你需要处理两者，你可以覆盖 <code>service</code> 方法。</li></ul><pre><code class="java">import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class MyServlet extends HttpServlet {    protected void service(HttpServletRequest request, HttpServletResponse response)            throws ServletException, IOException {        if (request.getMethod().equals("GET")) {            // 处理GET请求的逻辑            doGet(request, response);        } else if (request.getMethod().equals("POST")) {            // 处理POST请求的逻辑            doPost(request, response);        }        // 可以添加其他请求类型的处理逻辑    }    protected void doGet(HttpServletRequest request, HttpServletResponse response)            throws ServletException, IOException {        // 处理GET请求的具体逻辑    }    protected void doPost(HttpServletRequest request, HttpServletResponse response)            throws ServletException, IOException {        // 处理POST请求的具体逻辑    }}</code></pre><h1 id="2-第一个尝试"><a href="#2-第一个尝试" class="headerlink" title="2 第一个尝试"></a>2 第一个尝试</h1><p>在webapp的包里创建一个html，设置好post请求以便于触发servlet。</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;form action="myweb" method="post"&gt;        &lt;div&gt;            &lt;span&gt;姓名:&lt;/span&gt;            &lt;input name="name"&gt;        &lt;/div&gt;        &lt;div&gt;            &lt;span&gt;密码:&lt;/span&gt;            &lt;input name="password"&gt;        &lt;/div&gt;        &lt;button type="submit"&gt;提交&lt;/button&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>在src/main/java/com/example/demo1这个目录下创建myweb.java实现doPost请求</p><pre><code class="java">package com.example.demo1;import com.sun.nio.sctp.AbstractNotificationHandler;import jakarta.servlet.ServletException;import jakarta.servlet.http.HttpServlet;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import java.io.IOException;public class myweb extends HttpServlet {    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        //super.doPost(req, resp);        String name = req.getParameter("name");        String password = req.getParameter("password");        System.out.println(name);        System.out.println(password);    }}</code></pre><p>在webapp下的WEB-INF中的web.xml配置好关联信息</p><pre><code class="xml">        &lt;servlet&gt;            &lt;servlet-name&gt;myweb&lt;/servlet-name&gt;            &lt;servlet-class&gt;com.example.demo1.myweb&lt;/servlet-class&gt;        &lt;/servlet&gt;        &lt;servlet-mapping&gt;            &lt;servlet-name&gt;myweb&lt;/servlet-name&gt;            &lt;url-pattern&gt;/myweb&lt;/url-pattern&gt;        &lt;/servlet-mapping&gt;        &lt;welcome-file-list&gt;            &lt;welcome-file&gt;myweb.html&lt;/welcome-file&gt;        &lt;/welcome-file-list&gt;</code></pre><p>==servlet-class在这里是全限定名==</p><p>启动tomcat之后可以观察到运行效果。</p><p><img src="/../images/image-20231220200342786.png" alt="image-20231220200342786"></p><p>证明我的post请求已经获取到了，开始进一步的学习。</p><h2 id="2-2-页面跳转"><a href="#2-2-页面跳转" class="headerlink" title="2.2 页面跳转"></a>2.2 页面跳转</h2><p>服务端跳转</p><pre><code class="java">package com.example.demo1;import jakarta.servlet.ServletException;import jakarta.servlet.http.HttpServlet;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import java.io.IOException;public class tiaozhuan extends HttpServlet {    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        String name = req.getParameter("name");        String password = req.getParameter("password");        if(name.equals("姓名") &amp;&amp; password.equals("123")){            req.getRequestDispatcher("success.html").forward(req,resp);        }else{            req.getRequestDispatcher("fail.html").forward(req, resp);        }    }}</code></pre><p>客户端跳转</p><pre><code class="java">package com.example.demo1;import jakarta.servlet.ServletException;import jakarta.servlet.http.HttpServlet;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import java.io.IOException;public class tiaozhuan extends HttpServlet {    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        String name = req.getParameter("name");        String password = req.getParameter("password");        if(name.equals("姓名") &amp;&amp; password.equals("123")){                        resp.sendRedirect("success.html");        }else{                        resp.sendRedirect("fail.html");        }    }}</code></pre><h2 id="2-3-自启动配置"><a href="#2-3-自启动配置" class="headerlink" title="2.3 自启动配置"></a>2.3 自启动配置</h2><p>在Servlet的<code>web.xml</code>配置文件中，<code>&lt;load-on-startup&gt;</code> 元素用于指定Servlet在应用启动时被加载的顺序。</p><pre><code class="xml">&lt;servlet&gt;    &lt;servlet-name&gt;MyServlet&lt;/servlet-name&gt;    &lt;servlet-class&gt;com.example.MyServlet&lt;/servlet-class&gt;    &lt;load-on-startup&gt;10&lt;/load-on-startup&gt;&lt;/servlet&gt;</code></pre><p>这里的 <code>&lt;load-on-startup&gt;</code> 元素中的值是一个整数，表示Servlet的加载顺序。当应用启动时，容器会按照 <code>&lt;load-on-startup&gt;</code> 的值的升序来加载Servlet。值越小，加载的越早。如果多个Servlet有相同的 <code>&lt;load-on-startup&gt;</code> 值，容器可以自由选择加载的顺序。</p><p>使用 <code>&lt;load-on-startup&gt;</code> 的情况通常包括：</p><ol><li><strong>初始化操作：</strong> 如果Servlet在启动时需要执行一些初始化工作，可以通过在 <code>&lt;load-on-startup&gt;</code> 中指定一个值，确保在应用启动时就加载该Servlet。(比如要加载数据库等等操作)</li><li><strong>确保顺序：</strong> 在一些特定的场景，可能需要确保一些Servlet在应用启动时按照指定的顺序加载，以确保它们正确初始化。</li></ol><h2 id="2-4-request常用方法"><a href="#2-4-request常用方法" class="headerlink" title="2.4 request常用方法"></a>2.4 request常用方法</h2><p><code>HttpServletRequest</code> 接口提供了一系列用于获取客户端请求信息的方法。以下是一些 <code>HttpServletRequest</code> 中常用的方法：</p><ol><li><strong>获取请求行信息：</strong><ul><li><code>getMethod()</code>: 获取HTTP请求的方法，如GET、POST等。</li><li><code>getRequestURI()</code>: 获取请求的URI，不包含查询字符串。</li><li><code>getQueryString()</code>: 获取请求的查询字符串部分。</li></ul></li><li><strong>获取请求头信息：</strong><ul><li><code>getHeader(String name)</code>: 获取指定名称的请求头的值。</li><li><code>getHeaders(String name)</code>: 获取指定名称的请求头的所有值。</li><li><code>getHeaderNames()</code>: 获取所有的请求头名称。</li></ul></li><li><strong>获取请求参数：</strong><ul><li><code>getParameter(String name)</code>: 获取指定名称的请求参数的值。</li><li><code>getParameterValues(String name)</code>: 获取指定名称的请求参数的所有值。</li><li><code>getParameterMap()</code>: 获取所有请求参数的映射。</li><li><code>getParameterNames()</code>: 获取所有请求参数的名称。</li></ul></li><li><strong>获取客户端信息：</strong><ul><li><code>getRemoteAddr()</code>: 获取客户端的IP地址。</li><li><code>getRemotePort()</code>: 获取客户端的端口号。</li><li><code>getRemoteHost()</code>: 获取客户端的主机名。</li></ul></li><li><strong>获取会话信息：</strong><ul><li><code>getSession()</code>: 获取与请求关联的会话对象。</li><li><code>getSession(boolean create)</code>: 获取与请求关联的会话对象，如果不存在并且 <code>create</code> 为 <code>true</code>，则创建一个新的会话。</li></ul></li><li><strong>获取其他信息：</strong><ul><li><code>getLocale()</code>: 获取客户端请求的语言环境。</li><li><code>getInputStream()</code>: 获取请求的输入流，用于读取请求体的数据。</li><li><code>getReader()</code>: 获取请求的Reader，用于读取请求体的数据。</li><li><code>getServletContext()</code>: 获取Servlet上下文对象。</li></ul></li></ol><h2 id="2-5-response常用方法"><a href="#2-5-response常用方法" class="headerlink" title="2.5 response常用方法"></a>2.5 response常用方法</h2><p><code>HttpServletResponse</code> 接口提供了一系列用于设置响应的方法。以下是一些 <code>HttpServletResponse</code> 中常用的方法：</p><ol><li><strong>设置响应内容类型和字符编码：</strong><ul><li><code>setContentType(String type)</code>: 设置响应的内容类型（MIME类型）。</li><li><code>setCharacterEncoding(String charset)</code>: 设置响应的字符编码。</li></ul></li><li><strong>设置响应状态和头信息：</strong><ul><li><code>setStatus(int sc)</code>: 设置响应的状态码，例如200表示成功。</li><li><code>sendError(int sc, String msg)</code>: 发送一个错误响应。</li><li><code>sendRedirect(String location)</code>: 发送一个重定向响应。</li><li><code>addHeader(String name, String value)</code>: 添加一个响应头。</li><li><code>setHeader(String name, String value)</code>: 设置一个响应头。</li></ul></li><li><strong>设置响应内容：</strong><ul><li><code>getWriter()</code>: 获取一个 PrintWriter 对象，用于向客户端写入字符数据。</li><li><code>getOutputStream()</code>: 获取一个 ServletOutputStream 对象，用于向客户端写入二进制数据。</li><li><code>setCharacterEncoding(String charset)</code>: 设置字符编码。</li><li><code>setContentLength(int len)</code>: 设置响应内容长度。</li><li><code>setContentLengthLong(long len)</code>: 设置响应内容长度（长整型）。</li><li><code>setBufferSize(int size)</code>: 设置响应缓冲区的大小。</li></ul></li><li><strong>缓存控制：</strong><ul><li><code>setDateHeader(String name, long date)</code>: 设置响应头中日期字段的值。</li><li><code>addDateHeader(String name, long date)</code>: 添加响应头中日期字段的值。</li><li><code>setExpires(long expires)</code>: 设置响应过期的日期。</li><li><code>addHeader(String name, String value)</code>: 添加响应头。</li></ul></li><li><strong>Cookie：</strong><ul><li><code>addCookie(Cookie cookie)</code>: 添加一个Cookie到响应。</li></ul></li><li><strong>重定向和错误处理：</strong><ul><li><code>sendRedirect(String location)</code>: 发送一个重定向响应。</li><li><code>sendError(int sc)</code>: 发送一个错误响应。</li></ul></li><li><strong>其他方法：</strong><ul><li><code>flushBuffer()</code>: 强制将响应的缓冲区内容发送到客户端。</li><li><code>reset()</code>: 重置响应，清除所有设置。</li></ul></li></ol><h1 id="servlet配合JDBC的使用案例"><a href="#servlet配合JDBC的使用案例" class="headerlink" title="servlet配合JDBC的使用案例"></a>servlet配合JDBC的使用案例</h1><h2 id="制作查询"><a href="#制作查询" class="headerlink" title="制作查询"></a>制作查询</h2><p>英雄类的创建</p><pre><code class="java">package com.example.newgzwithjdbc;public class Hero {    private  int id;    private String name;    private float hp;    public int getId() {        return id;    }    public void setId(int id) {        this.id = id;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public float getHp() {        return hp;    }    public void setHp(float hp) {        this.hp = hp;    }    public int getDamage() {        return damage;    }    public void setDamage(int damage) {        this.damage = damage;    }    private int damage;}</code></pre><p>数据库链接</p><pre><code class="java">package com.example.newgzwithjdbc;import java.sql.*;import java.util.ArrayList;import java.util.List;public class HeroDao {    public HeroDao() {        try{            Class.forName("com.mysql.jdbc.Driver");        }catch (ClassNotFoundException e){            e.printStackTrace();        }    }    public Connection getConnection() throws SQLException{        return DriverManager.getConnection(                "jdbc:mysql://127.0.0.1:3306/db_hero?characterEncoding=UTF-8",                "root", "");//密码就不放了    }    /**     * 获取数量     *     * */    public int getTotal(){        int total = 0;        try(Connection c = getConnection(); Statement s = c.createStatement()){            String sql = "select count(*) from hero";            ResultSet rs = s.executeQuery(sql);            while(rs.next()){                total = rs.getInt(1);            }            System.out.println("total:" + total);        }catch (SQLException e){            e.printStackTrace();        }        return total;    }    /**     * 插入新英雄     *     * */    public void addHero(Hero hero){        String sql = "insert into hero values(null,?,?,?)";        try(Connection c =getConnection(); PreparedStatement s = c.prepareStatement(sql);){            s.setString(1, hero.getName());            s.setFloat(2, hero.getHp());            s.setInt(3, hero.getDamage());            s.execute();            ResultSet rs = s.getGeneratedKeys();            if(rs.next()){                int id = rs.getInt(1);                hero.setId(id);            }        }catch (SQLException e){            e.printStackTrace();        }    }    /**     * 更新操作     *     * */    public void updateHero(Hero hero){        String sql = "update hero set name= ?, hp = ?, damage = ? where id = ?";        try(Connection c = getConnection(); PreparedStatement s = c.prepareStatement(sql)){            s.setString(1, hero.getName());            s.setFloat(2, hero.getHp());            s.setInt(3, hero.getDamage());            s.setInt(4, hero.getId());            s.execute();        }catch (SQLException e){            e.printStackTrace();        }    }    /**     * 删除英雄     *     * */    public void deleteHero(int id){        try(Connection c = getConnection(); Statement s = c.createStatement();){            String  sql = "delete from hero where id = " + id;            s.execute(sql);        }catch (SQLException e){            e.printStackTrace();        }    }    /*    * 获取英雄    *    *    * */    public Hero get(int id) {        Hero hero = null;        try (Connection c = getConnection(); Statement s = c.createStatement();) {            String sql = "select * from hero where id = " + id;            ResultSet rs = s.executeQuery(sql);            if (rs.next()) {                hero = new Hero();                String name = rs.getString(2);                float hp = rs.getFloat("hp");                int damage = rs.getInt(4);                hero.setName(name);                hero.setHp(hp);                hero.setDamage(damage);                hero.setId(id);            }        } catch (SQLException e) {            e.printStackTrace();        }        return hero;    }    public List&lt;Hero&gt; list() {        return list(0, Short.MAX_VALUE);    }    public List&lt;Hero&gt; list(int start, int count) {        List&lt;Hero&gt; heros = new ArrayList&lt;Hero&gt;();        String sql = "select * from hero order by id desc limit ?,? ";        try (Connection c = getConnection(); PreparedStatement ps = c.prepareStatement(sql);) {            ps.setInt(1, start);            ps.setInt(2, count);            ResultSet rs = ps.executeQuery();            while (rs.next()) {                Hero hero = new Hero();                int id = rs.getInt(1);                String name = rs.getString(2);                float hp = rs.getFloat("hp");                int damage = rs.getInt(4);                hero.setName(name);                hero.setHp(hp);                hero.setDamage(damage);                hero.setId(id);                heros.add(hero);            }        } catch (SQLException e) {            e.printStackTrace();        }        return heros;    }}</code></pre><p>页面</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;111&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;div style="color: green"&gt;这是数据&lt;/div&gt;    &lt;form action="firstpage" method="post"&gt;        &lt;button&gt;这是按钮&lt;/button&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>相应页面的servlet</p><pre><code class="java">package com.example.newgzwithjdbc;import jakarta.servlet.ServletException;import jakarta.servlet.http.HttpServlet;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.List;public class HelloListServlet extends HttpServlet {    HeroDao heroDao = new HeroDao();    @Override    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {       List&lt;Hero&gt; heros = heroDao.list();       StringBuffer sb = new StringBuffer();       sb.append("&lt;table align='center' border='1' cellspacing='0'&gt;\r\n");       sb.append("&lt;tr&gt;&lt;td&gt;id&lt;/td&gt;&lt;td&gt;name&lt;/td&gt;&lt;td&gt;hp&lt;/td&gt;&lt;td&gt;damage&lt;/td&gt;&lt;/tr&gt;\r\n");       String trFormat = "&lt;tr&gt;&lt;td&gt;%d&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%f&lt;/td&gt;&lt;td&gt;%d&lt;/td&gt;&lt;/tr&gt;\r\n";       for(Hero hero: heros){           String tr = String.format(trFormat, hero.getId(), hero.getName(), hero.getHp(), hero.getDamage());            sb.append(tr);       }       sb.append("&lt;/table&gt;");       resp.getWriter().print(sb.toString());    }}</code></pre><p>进行xml映射</p><pre><code class="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="https://jakarta.ee/xml/ns/jakartaee"         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"         xsi:schemaLocation="https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/web-app_5_0.xsd"         version="5.0"&gt;    &lt;servlet&gt;        &lt;servlet-name&gt;HelloListServlet&lt;/servlet-name&gt;        &lt;servlet-class&gt;com.example.newgzwithjdbc.HelloListServlet&lt;/servlet-class&gt;    &lt;/servlet&gt;        &lt;servlet-mapping&gt;        &lt;servlet-name&gt;HelloListServlet&lt;/servlet-name&gt;        &lt;url-pattern&gt;/firstpage&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;    &lt;welcome-file-list&gt;        &lt;welcome-file&gt;firstpage.html&lt;/welcome-file&gt;    &lt;/welcome-file-list&gt;&lt;/web-app&gt;</code></pre><p>最终可以看到效果</p><p><img src="/../images/image-20231222094945598.png" alt="image-20231222094945598"></p><p><img src="/../images/image-20231222094953549.png" alt="image-20231222094953549"></p><h2 id="英雄增加"><a href="#英雄增加" class="headerlink" title="英雄增加"></a>英雄增加</h2><p>准备要使用的英雄添加页面</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;addhero&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;form method="post" action="addhero"&gt;    &lt;span&gt;姓名：&lt;/span&gt;    &lt;input type="text" name="name"&gt;    &lt;span&gt;HP：&lt;/span&gt;    &lt;input type="text" name="hp"&gt;    &lt;span&gt;DAMAGE：&lt;/span&gt;    &lt;input type="number" name="damage"&gt;    &lt;button type="submit" name="btn"&gt;      提交    &lt;/button&gt;  &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>编写调addhero的action的servlet</p><pre><code class="java">package com.example.newgzwithjdbc;import jakarta.servlet.ServletException;import jakarta.servlet.http.HttpServlet;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import java.io.IOException;public class HeroAddServlet extends HttpServlet {    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        Hero hero = new Hero();        hero.setName(req.getParameter("name"));        hero.setHp(Float.parseFloat(req.getParameter("hp")));        hero.setDamage(Integer.parseInt(req.getParameter("damage")));        HeroDao heroDao = new HeroDao();        heroDao.addHero(hero);        System.out.println(hero.getName());        System.out.println(hero.getHp());        System.out.println(hero.getDamage());        resp.setContentType("text/html;charSet=UTF-8");        StringBuffer sb = new StringBuffer();        sb.append("&lt;span&gt;");        sb.append(hero.getName());        sb.append("&lt;/span&gt;");        resp.getWriter().print(sb.toString());        try {            Thread.sleep(2);        }catch (InterruptedException e){            e.printStackTrace();        }        /*最后重定向的是当前的上下文的根目录*/        resp.sendRedirect(req.getContextPath()+ "/");    }}</code></pre><p>添加xml配置</p><pre><code class="xml">    &lt;servlet&gt;        &lt;servlet-name&gt;AddHeroServlet&lt;/servlet-name&gt;        &lt;servlet-class&gt;com.example.newgzwithjdbc.HeroAddServlet&lt;/servlet-class&gt;    &lt;/servlet&gt;    &lt;servlet-mapping&gt;        &lt;servlet-name&gt;AddHeroServlet&lt;/servlet-name&gt;        &lt;url-pattern&gt;/addhero&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;</code></pre><h2 id="英雄删除"><a href="#英雄删除" class="headerlink" title="英雄删除"></a>英雄删除</h2><p>修改展示的servlet，提供删除的超连接</p><pre><code class="java">    String trFormat = "&lt;tr&gt;&lt;td&gt;%d&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%f&lt;/td&gt;&lt;td&gt;%d&lt;/td&gt;" +               "&lt;td&gt;&lt;a href='deleteHeroid?id=%d'&gt;delete&lt;/a&gt;&lt;/td&gt;" +               "&lt;/tr&gt;\r\n";       for(Hero hero: heros){           String tr = String.format(trFormat, hero.getId(), hero.getName(), hero.getHp(), hero.getDamage(), hero.getId());            sb.append(tr);       }</code></pre><p>编写点击超连接删除的servlet</p><pre><code class="java">package com.example.newgzwithjdbc;import jakarta.servlet.ServletException;import jakarta.servlet.http.HttpServlet;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import java.io.IOException;public class HeroDeleteServlet extends HttpServlet {    @Override    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        int id = Integer.parseInt(req.getParameter("id"));        new HeroDao().deleteHero(id);        resp.sendRedirect(req.getContextPath() + "/firstpage");    }}</code></pre><p>在xml文件中实现配置</p><pre><code class="xml">    &lt;servlet&gt;        &lt;servlet-name&gt;HeroDeleteServlet&lt;/servlet-name&gt;        &lt;servlet-class&gt;com.example.newgzwithjdbc.HeroDeleteServlet&lt;/servlet-class&gt;    &lt;/servlet&gt;    &lt;servlet-mapping&gt;        &lt;servlet-name&gt;HeroDeleteServlet&lt;/servlet-name&gt;        &lt;url-pattern&gt;/deleteHeroid&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;</code></pre><h2 id="英雄修改"><a href="#英雄修改" class="headerlink" title="英雄修改"></a>英雄修改</h2><p>对于每一个英雄表格，增加一个edit来修改，再将修改后的信息，存储，展示</p><p>修改展示的servlet</p><pre><code class="java">    String trFormat = "&lt;tr&gt;&lt;td&gt;%d&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%f&lt;/td&gt;&lt;td&gt;%d&lt;/td&gt;" +               "&lt;td&gt;&lt;a href='deleteHeroid?id=%d'&gt;delete&lt;/a&gt;&lt;/td&gt;" +               "&lt;td&gt;&lt;a href='editHeroid?id=%d'&gt;edit&lt;/a&gt;" +               "&lt;/tr&gt;\r\n";       for(Hero hero: heros){           String tr = String.format(trFormat, hero.getId(), hero.getName(), hero.getHp(), hero.getDamage(), hero.getId(), hero.getId());            sb.append(tr);       }</code></pre><pre><code class="java">package com.example.newgzwithjdbc;import jakarta.servlet.ServletException;import jakarta.servlet.http.HttpServlet;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.List;public class HelloListServlet extends HttpServlet {    HeroDao heroDao = new HeroDao();    @Override    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {       List&lt;Hero&gt; heros = heroDao.list();       StringBuffer sb = new StringBuffer();       sb.append("&lt;table align='center' border='1' cellspacing='0'&gt;\r\n");       sb.append("&lt;tr&gt;&lt;td&gt;id&lt;/td&gt;&lt;td&gt;name&lt;/td&gt;&lt;td&gt;hp&lt;/td&gt;&lt;td&gt;damage&lt;/td&gt;&lt;/tr&gt;\r\n");       String trFormat = "&lt;tr&gt;&lt;td&gt;%d&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%f&lt;/td&gt;&lt;td&gt;%d&lt;/td&gt;" +               "&lt;td&gt;&lt;a href='deleteHeroid?id=%d'&gt;delete&lt;/a&gt;&lt;/td&gt;" +               "&lt;td&gt;&lt;a href='editHeroid?id=%d'&gt;edit&lt;/a&gt;" +               "&lt;/tr&gt;\r\n";       for(Hero hero: heros){           String tr = String.format(trFormat, hero.getId(), hero.getName(), hero.getHp(), hero.getDamage(), hero.getId(), hero.getId());            sb.append(tr);       }       sb.append("&lt;/table&gt;");       resp.getWriter().print(sb.toString());    }}</code></pre><p>每一次点击会调用不同的editHeroid？id=%d那么，首先是修改的servlet，能够获取修改后的信息</p><pre><code class="java">package com.example.newgzwithjdbc;import jakarta.servlet.ServletException;import jakarta.servlet.http.HttpServlet;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import java.io.IOException;public class HeroUpdateServlet extends HttpServlet {    @Override    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        int id = Integer.parseInt(req.getParameter("id"));        HeroDao heroDao = new HeroDao();        Hero hero = heroDao.get(id);        StringBuffer sb = new StringBuffer();        resp.setContentType("text/html; charSet=UTF-8");        sb.append("&lt;!DOCTYPE html&gt;");        sb.append("&lt;form action='updateHero' method='post'&gt;");        sb.append("名字 ： &lt;input type='text' name='name' value='%s' &gt; &lt;br&gt;");        sb.append("血量 ： &lt;input type='text' name='hp'  value='%f' &gt; &lt;br&gt;");        sb.append("伤害： &lt;input type='text' name='damage'  value='%d' &gt; &lt;br&gt;");        sb.append("&lt;input type='hidden' name='id' value='%d'&gt;");        sb.append("&lt;input type='submit' value='更新'&gt;");        sb.append("&lt;/form&gt;");        String html = String.format(sb.toString(), hero.getName(), hero.getHp(), hero.getDamage(), hero.getId());        resp.getWriter().write(html);    }}</code></pre><p>在上面的表格中完成修改后，点击更新之后就会调用updateHero的action，那么要再编写能处理updateHero的servlet。</p><pre><code class="java">package com.example.newgzwithjdbc;import jakarta.servlet.ServletException;import jakarta.servlet.http.HttpServlet;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import java.io.IOException;public class HeroUpdateToServlet extends HttpServlet {    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        HeroDao heroDao = new HeroDao();        Hero hero = new Hero();        hero.setId(Integer.parseInt(req.getParameter("id")));        hero.setName(req.getParameter("name"));        hero.setHp(Integer.parseInt(req.getParameter("hp")));        hero.setDamage(Integer.parseInt(req.getParameter("damage")));        heroDao.updateHero(hero);        resp.sendRedirect(req.getContextPath() + "/");    }}</code></pre><p>在xml中进行配置</p><pre><code class="xml">&lt;servlet&gt;    &lt;servlet-name&gt;HeroUpdateServlet&lt;/servlet-name&gt;    &lt;servlet-class&gt;com.example.newgzwithjdbc.HeroUpdateServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;HeroUpdateServlet&lt;/servlet-name&gt;    &lt;url-pattern&gt;/editHeroid&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;servlet&gt;    &lt;servlet-name&gt;HeroUpdateToServlet&lt;/servlet-name&gt;    &lt;servlet-class&gt;com.example.newgzwithjdbc.HeroUpdateToServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;HeroUpdateToServlet&lt;/servlet-name&gt;    &lt;url-pattern&gt;/updateHero&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;</code></pre><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>初始页面（要的是逻辑，效果丑就丑点）</p><p><img src="/../images/image-20231226144359248.png" alt="image-20231226144359248"></p><p>添加数据</p><p><img src="/../images/image-20231226144426177.png" alt="image-20231226144426177"></p><p>查看数据</p><p><img src="/../images/image-20231226144507734.png" alt="image-20231226144507734"></p><p>删除id=11</p><p><img src="/../images/image-20231226144522865.png" alt="image-20231226144522865"></p><p>修改id=10</p><p><img src="/../images/image-20231226144542424.png" alt="image-20231226144542424"></p><p><img src="/../images/image-20231226144603734.png" alt="image-20231226144603734"></p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git中出现访问403的问题</title>
      <link href="/2023/12/20/git%E4%B8%AD%E5%87%BA%E7%8E%B0%E8%AE%BF%E9%97%AE403%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2023/12/20/git%E4%B8%AD%E5%87%BA%E7%8E%B0%E8%AE%BF%E9%97%AE403%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>今天想fetch一下远程仓库突然就出现了连接403的错误，Failed to connect to github.com port 443: Operation timed out。搜索后得到解决方法。</p><pre><code class="bash">git config --global http.sslVerify "false"git config --global https.proxy http://127.0.0.1:1080git config --global http.proxy http://127.0.0.1:1080</code></pre><p>但是发现问题并没有解决？</p><h1 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h1><pre><code class="bash">git config --global http.proxy http://127.0.0.1:7890 git config --global https.proxy http://127.0.0.1:7890</code></pre><p>采用的是clash工具的端口，默认端口是7890<img src="/../images/image-20231220185744363.png" alt="image-20231220185744363"></p><p>更改后问题的到解决。</p>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习记录之JSON</title>
      <link href="/2023/12/18/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E4%B9%8BJSON/"/>
      <url>/2023/12/18/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E4%B9%8BJSON/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是JSON"><a href="#什么是JSON" class="headerlink" title="什么是JSON"></a>什么是JSON</h1><p>JSON（JavaScript Object Notation）是一种轻量级的数据交换格式，它基于JavaScript的对象字面量语法。JSON格式易于阅读和编写，并且也易于机器解析和生成。它常用于客户端和服务器之间的数据传输。</p><p>JSON的基本数据结构包括对象（键值对集合）、数组（值的有序列表）、字符串、数字、布尔值和空值。它与JavaScript对象字面量的语法非常相似，但是它是一种独立于编程语言的数据格式，因此可以被多种语言解析和生成。</p><p>JSON常用于Web开发中，例如在将数据从服务器传输到客户端或在不同系统之间交换数据时。 JSON格式的数据易于处理和解析，因此在各种应用程序中广泛使用。</p><pre><code class="xml">//1.Maven中导入alibaba的fastjson&lt;dependency&gt;            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;            &lt;artifactId&gt;fastjson&lt;/artifactId&gt;            &lt;version&gt;1.2.62&lt;/version&gt;&lt;/dependency&gt;//2.在类中导入import com.alibaba.fastjson.JSON;//3.将list转化为json格式String json = JSON.toJSONString(result);</code></pre><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><ol><li>使用 <code>JSON.parse()</code> 方法将 JSON 字符串转换为 JavaScript 对象：</li></ol><pre><code class="JavaScript">var jsonString = '{"name":"John", "age":30, "city":"New York"}';var obj = JSON.parse(jsonString);console.log(obj.name); // 输出 "John"</code></pre><ol start="2"><li>使用 <code>JSON.stringify()</code> 方法将 JavaScript 对象转换为 JSON 字符串：</li></ol><pre><code class="JavaScript">var obj = { name: "John", age: 30, city: "New York" };var jsonString = JSON.stringify(obj);console.log(jsonString); // 输出 '{"name":"John","age":30,"city":"New York"}'</code></pre><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;script&gt;        var json = {"name":"彳亍", "id":"1"};        console.log(json.name);        console.log(json.id);        console.log(json);            &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="/../images/image-20231218102607816.png" alt="image-20231218102607816"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MATLAB关于图像傅里叶变换以及滤波的初探</title>
      <link href="/2023/12/13/MATLAB%E5%85%B3%E4%BA%8E%E5%9B%BE%E5%83%8F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E4%BB%A5%E5%8F%8A%E6%BB%A4%E6%B3%A2%E7%9A%84%E5%88%9D%E6%8E%A2/"/>
      <url>/2023/12/13/MATLAB%E5%85%B3%E4%BA%8E%E5%9B%BE%E5%83%8F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E4%BB%A5%E5%8F%8A%E6%BB%A4%E6%B3%A2%E7%9A%84%E5%88%9D%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="任务要求"><a href="#任务要求" class="headerlink" title="任务要求"></a>任务要求</h1><p>今天雪下的巨大，学的傅里叶变换（单独的还是明白了，但是怎么让他们跟图像放在一起）形成了低频和高频（我理解低频和高频是像素值变化的剧烈程度），对图像做了傅里叶变换，把低频的拿到了中间，应该叫移动，再用掩膜给他盖起来。比如我盖住了高频的，那么只有低频的进行复原，也就是说是个低通滤波器，反之就是个高通滤波器。</p><p>如此说来，高通滤波器下，变化剧烈的像素被保留，就能够获得轮廓。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code class="matlab">img = imread('C:\Users\7878\Desktop\my_image.png');img1 = imresize(img, 0.3);img1 = rgb2gray(img1);img1 = im2double(img1);subplot(2, 3, 1);imshow(img1);fftimg1 = fft2(img1);sfftimg1 = fftshift(fftimg1);RR = real(sfftimg1);II = imag(sfftimg1);A=sqrt(RR.^2+II.^2);%计算频谱幅值A=(A-min(min(A)))/(max(max(A))-min(min(A)))*225; %归一化subplot(2,3,2);imshow(A);% 计算填充图像大小[M,N] = size(img1);M2 = 2*M;N2 = 2*N;% 傅里叶变换F = fftshift(fft2(img1,M2,N2));subplot(2,3,3);imshow(mat2gray(log(1+abs(F))));title('傅里叶频谱');% 设计滤波器D0=40;      h=zeros(M2,N2); for i=1:M2     for j=1:N2        if((abs(M2/2-i)&lt;D0)&amp;&amp;(abs(N2/2-j)&lt;D0))            h(i,j)=0;        else           h(i,j)=1;        end     end end    H = mat2gray(h);% 理想滤波器subplot(2,3,4);imshow(H);title('理想高通滤波器');G = F.*H;subplot(2,3,5);imshow(mat2gray(log(1+abs(G))));title('频域滤波');g0 = ifft2(fftshift(G));g = g0(1:M,1:N);g = real(g);subplot(2,3,6);imshow(g);title('滤波后的图像');% % % 创建高通滤波器% high_pass_filter = ones(size(A));% radius = 30; % 调整这个半径以控制高频通道的大小% % % 在频谱中心创建一个圆形掩模，将半径外的部分设为0% [rows, cols] = size(A);% center = [rows/2, cols/2];% [x, y] = meshgrid(1:cols, 1:rows);% mask = (x - center(1)).^2 + (y - center(2)).^2 &gt; radius * radius;% % mask = (abs(x - center(1)) &gt; radius) | (abs(y - center(2)) &gt; radius);% % mask1(200:250, 200:300) = 0;% mask = ~mask;% high_pass_filter(mask) = 0;% % % 应用高通滤波器% filtered_A = A .* high_pass_filter;% % subplot(2,3,3);% imshow(filtered_A, []);% % % 反傅里叶变换% filtered_img = ifft2(ifftshift(filtered_A));% % % 取实部% filtered_img = real(filtered_img);% % subplot(2,3,4);% imshow(uint8(filtered_img),[]);</code></pre><h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><p><img src="/../images/image-20231213201827054.png" alt="image-20231213201827054"></p>]]></content>
      
      
      
        <tags>
            
            <tag> MATLAB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习记录之DOM</title>
      <link href="/2023/12/10/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E4%B9%8BDOM/"/>
      <url>/2023/12/10/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E4%B9%8BDOM/</url>
      
        <content type="html"><![CDATA[<h1 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h1><p>在 DOM（文档对象模型）中，节点（Node）是文档结构的基本构建块。DOM 是一种树状结构，它表示网页的层次结构，其中每个元素、属性、文本等都被表示为一个节点。节点之间的关系形成了整个文档的结构。</p><p>DOM 中的节点主要分为三类：元素节点、文本节点和属性节点。以下是它们的简要解释：</p><ol><li><strong>元素节点（Element Node）：</strong> 表示 HTML 元素，如 <code>&lt;div&gt;</code>、<code>&lt;p&gt;</code>、<code>&lt;a&gt;</code> 等。元素节点可以包含其他节点，形成嵌套关系。一个 HTML 文档就是由元素节点组成的树状结构。</li><li><strong>文本节点（Text Node）：</strong> 表示 HTML 元素中的文本内容。文本节点是元素节点的子节点，它们不包含其他节点。例如，<code>&lt;p&gt;这是一个文本节点&lt;/p&gt;</code> 中的 “这是一个文本节点” 就是一个文本节点。==<code>childNodes[0]</code> 返回一个元素的第一个子节点。这个子节点可以是元素节点、文本节点、注释节点等等。==</li><li><strong>属性节点（Attribute Node）：</strong> 表示 HTML 元素的属性。每个元素可以有零个或多个属性，每个属性都是属性节点。例如，<code>&lt;a href="https://www.example.com"&gt;</code> 中的 <code>href</code> 就是一个属性节点。==<code>attributes</code> 返回的是一个包含元素节点的所有属性的 <code>NamedNodeMap</code> 对象==</li></ol><p>节点在 DOM 中的位置关系形成了父子关系、兄弟关系等。DOM 提供了许多用于访问、操作和修改节点的方法和属性，例如 <code>getElementById</code>、<code>appendChild</code>、<code>removeChild</code> 等。</p><p>示例：</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;    &lt;title&gt;DOM Node Example&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id="parent"&gt;        &lt;p&gt;This is a text node.&lt;/p&gt;        &lt;a href="https://www.example.com"&gt;Link&lt;/a&gt;    &lt;/div&gt;    &lt;script&gt;        // 获取父节点        var parent = document.getElementById("parent");        // 获取子节点列表        var childNodes = parent.childNodes;        console.log(childNodes);        // 获取第一个子节点（文本节点）        var firstChild = parent.firstChild;        console.log(firstChild);                // 获取属性节点        var attributesList = parent.attributes;        console.log('Attributes List:', attributesList);                // 获取第一个元素子节点        var firstElementChild = parent.firstElementChild;        console.log(firstElementChild);    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>在这个例子中，<code>&lt;div&gt;</code> 元素是一个父节点，它包含了一个文本节点（<code>&lt;p&gt;</code> 元素内的文本）和一个元素节点（<code>&lt;a&gt;</code> 元素）。节点之间的关系在 JavaScript 中可以通过 DOM API 进行访问和操作。</p><p>想象一本大大的故事书，这本书里有很多有趣的故事。在这本书中，每个小故事都是一个节点。这些节点可以是主要的故事（就像一张大图片），也可以是小细节（就像书中的文字或一些插图）。</p><ol><li><strong>元素节点（Element Node）：</strong> 想象一张大图片，这就是一个元素节点。比如，有一张大大的彩虹图片，这就是一个元素节点。而且，这张图片下面还可以有小图片或者文字，它们都是这个元素节点的一部分。</li><li><strong>文本节点（Text Node）：</strong> 想象你看到的一些文字，比如书中的文字描述。这些文字就是文本节点。例如，书中可能有一句话说：“一天，小猫在阳光下玩耍。”，这句话就是一个文本节点。</li><li><strong>属性节点（Attribute Node）：</strong> 想象你看到的一些标签上的特殊说明，就像书中的小注释。这些小注释是属性节点。比如，有一个链接，链接上写着 <code>href="https://www.example.com"</code>，这里的 <code>href</code> 就是一个属性节点。</li></ol><p>节点之间就像书中的章节、段落、文字一样，它们组合在一起构成了整个故事。而在 JavaScript 中，我们可以使用一些代码来找到这些节点，就像你可以用手指指向书中的一些部分一样。这样，我们就可以对这些节点进行操作，就像你可以选择读哪一页的故事一样。</p><h1 id="获取节点"><a href="#获取节点" class="headerlink" title="获取节点"></a>获取节点</h1><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;    &lt;title&gt;DOM Node Examples&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id="myDiv" class="container"&gt;        &lt;p class="paragraph"&gt;This is a paragraph.&lt;/p&gt;        &lt;ul&gt;            &lt;li&gt;Item 1&lt;/li&gt;            &lt;li&gt;Item 2&lt;/li&gt;            &lt;li&gt;Item 3&lt;/li&gt;        &lt;/ul&gt;    &lt;/div&gt;    &lt;script&gt;        // 通过ID获取单个节点        var divElement = document.getElementById('myDiv');        console.log(divElement);        // 通过类名获取节点列表        var paragraphElements = document.getElementsByClassName('paragraph');        console.log(paragraphElements);        // 通过标签名获取节点列表        var listItems = document.getElementsByTagName('li');        console.log(listItems);        // 通过选择器获取单个节点        var firstParagraph = document.querySelector('p');        console.log(firstParagraph);        // 通过选择器获取节点列表        var allParagraphs = document.querySelectorAll('p');        console.log(allParagraphs);    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h1 id="节点属性"><a href="#节点属性" class="headerlink" title="节点属性"></a>节点属性</h1><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;    &lt;title&gt;DOM Node Properties&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id="myElement" class="example-class"&gt;        &lt;p id="myChild"&gt;This is a paragraph.&lt;/p&gt;    &lt;/div&gt;    &lt;p id="myText"&gt;Hello, World!&lt;/p&gt;    &lt;script&gt;        // 节点类型属性        var elementType = document.getElementById('myElement').nodeType;        console.log('Node Type:', elementType);        // 节点内容属性        var textContent = document.getElementById('myText').nodeValue;        console.log('Node Value (Text):', textContent);        var elementText = document.getElementById('myElement').textContent;        console.log('Text Content:', elementText);        var elementHTML = document.getElementById('myElement').innerHTML;        console.log('Inner HTML:', elementHTML);        // 节点关系属性        var parentElement = document.getElementById('myChild').parentNode;        console.log('Parent Node:', parentElement);        var childNodes = document.getElementById('myElement').childNodes;        console.log('Child Nodes:', childNodes);        var firstChild = document.getElementById('myElement').firstChild;        var lastChild = document.getElementById('myElement').lastChild;        console.log('First Child:', firstChild);        console.log('Last Child:', lastChild);        // 节点属性        var elementId = document.getElementById('myElement').id;        var elementClassName = document.getElementById('myElement').className;        console.log('Element ID:', elementId);        console.log('Element Class Name:', elementClassName);        var attributesList = document.getElementById('myElement').attributes;        console.log('Attributes:', attributesList);    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="/../images/image-20231210105858848.png" alt="image-20231210105858848"></p><pre><code class="javascript">function changeDiv1(){  document.getElementById("d1").childNodes[0].nodeValue= "通过childNode[0].value改变内容";}function changeDiv2(){  document.getElementById("d1").innerHTML= "通过innerHTML改变内容";}</code></pre><h2 id="练习1"><a href="#练习1" class="headerlink" title="练习1"></a>练习1</h2><p><img src="/../images/image-20231210111908530.png" alt="image-20231210111908530"></p><pre><code class="html">    &lt;input type="text" id="id" value="324"&gt;    &lt;button id="button" onclick="f1()"&gt;提交&lt;/button&gt;    &lt;script&gt;        function f1(){            var node = document.getElementById("id");            console.log(node.value);            var str = new String(node.value);            if(str[0] == 'A' || str[0] == 'Z' || str[str.length - 1] == 'A' || str[str.length - 1] == 'Z'){                alert("账号已经存在了！");            }else{                alert("注册成功");            }        }    &lt;/script&gt;</code></pre><h2 id="练习二"><a href="#练习二" class="headerlink" title="练习二"></a>练习二</h2><p><img src="/../images/image-20231212103816156.png" alt="image-20231212103816156"></p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;button id="pic1" onclick="f1()"&gt;这个是图片1&lt;/button&gt;    &lt;button id="pic2" onclick="f2()"&gt;这个是图片2&lt;/button&gt;    &lt;img src="./pic1.png" alt="图片一" width="300px" height="300px" id="pic"&gt;    &lt;script&gt;        function f1(){            img1 = document.getElementById("pic");            img1.src = "./pic1.png";        }        function f2(){            img2 = document.getElementById("pic");            img2.src = "./pic2.png";        }    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h1 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h1><ol><li><p><strong>直接修改样式属性：</strong></p><pre><code class="JavaScript">// 获取元素var myElement = document.getElementById("myElement");// 直接修改样式属性myElement.style.color = "red";myElement.style.fontSize = "16px";</code></pre></li><li><p><strong>使用<code>setProperty</code>方法：</strong></p><pre><code class="JavaScript">// 获取元素var myElement = document.getElementById("myElement");// 使用 setProperty 方法设置样式属性myElement.style.setProperty("color", "blue");</code></pre></li><li><p><strong>通过<code>cssText</code>属性设置多个样式：</strong></p><pre><code class="JavaScript">// 获取元素var myElement = document.getElementById("myElement");// 使用 cssText 属性设置多个样式myElement.style.cssText = "color: green; font-size: 18px;";</code></pre></li><li><p><strong>动态添加和移除CSS类：</strong></p><pre><code class="JavaScript">// 获取元素var myElement = document.getElementById("myElement");// 添加CSS类myElement.classList.add("newClass");// 移除CSS类myElement.classList.remove("oldClass");</code></pre></li></ol><h2 id="练习三"><a href="#练习三" class="headerlink" title="练习三"></a>练习三</h2><p><img src="/../images/image-20231212110251773.png" alt="image-20231212110251773"></p><p><img src="/../images/image-20231212110241198.png" alt="image-20231212110241198"></p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;table id="table"&gt;        &lt;tr style="background-color: blue;" class="tr1"&gt;                        &lt;td&gt;id&lt;/td&gt;            &lt;td&gt;姓名&lt;/td&gt;            &lt;td&gt;血量&lt;/td&gt;            &lt;td&gt;伤害&lt;/td&gt;        &lt;/tr&gt;        &lt;tr class="tr2"&gt;            &lt;td&gt;1&lt;/td&gt;            &lt;td&gt;gareen&lt;/td&gt;            &lt;td&gt;300&lt;/td&gt;            &lt;td&gt;5&lt;/td&gt;        &lt;/tr&gt;        &lt;tr class="tr1"&gt;            &lt;td&gt;2&lt;/td&gt;            &lt;td&gt;teemo&lt;/td&gt;            &lt;td&gt;200&lt;/td&gt;            &lt;td&gt;10&lt;/td&gt;        &lt;/tr&gt;        &lt;tr class="tr2"&gt;            &lt;td&gt;3&lt;/td&gt;            &lt;td&gt;teemo&lt;/td&gt;            &lt;td&gt;100&lt;/td&gt;            &lt;td&gt;15&lt;/td&gt;        &lt;/tr&gt;    &lt;/table&gt;    &lt;script&gt;        var table = document.getElementById("table");        console.log(document.childNodes);                var tr1 = document.getElementsByClassName("tr1");        tr1 = Array.from(tr1);        tr1.forEach(function(element) {            element.style.cssText = "background-color: blue;";        });                var tr2 = document.getElementsByClassName("tr2");        tr2 = Array.from(tr2);        tr2.forEach(function(element) {            element.style.cssText = "background-color: green;";        });    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="/../images/image-20231212110919351.png" alt="image-20231212110919351"></p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;table id="table" style="border-collapse: collapse;    align-content: center;"&gt;        &lt;tr style="background-color: blue;" class="tr1"&gt;                        &lt;td&gt;id&lt;/td&gt;            &lt;td&gt;姓名&lt;/td&gt;            &lt;td&gt;血量&lt;/td&gt;            &lt;td&gt;伤害&lt;/td&gt;        &lt;/tr&gt;        &lt;tr class="tr2"&gt;            &lt;td&gt;1&lt;/td&gt;            &lt;td&gt;gareen&lt;/td&gt;            &lt;td&gt;300&lt;/td&gt;            &lt;td&gt;5&lt;/td&gt;        &lt;/tr&gt;        &lt;tr class="tr1"&gt;            &lt;td&gt;2&lt;/td&gt;            &lt;td&gt;teemo&lt;/td&gt;            &lt;td&gt;200&lt;/td&gt;            &lt;td&gt;10&lt;/td&gt;        &lt;/tr&gt;        &lt;tr class="tr2"&gt;            &lt;td&gt;3&lt;/td&gt;            &lt;td&gt;teemo&lt;/td&gt;            &lt;td&gt;100&lt;/td&gt;            &lt;td&gt;15&lt;/td&gt;        &lt;/tr&gt;    &lt;/table&gt;    &lt;script&gt;        var tag = document.getElementsByTagName("tr");        for(var i = 0; i &lt; tag.length; i+=2){            tag[i].style.backgroundColor = "gray";        }    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><p>DOM（文档对象模型）中有许多事件，它们是与 HTML 元素相关联的行为或状态的表示。以下是一些常用的 DOM 事件：</p><ol><li><strong>点击事件（click）：</strong> 当用户点击某个元素时触发。</li><li><strong>鼠标移入事件（mouseover）：</strong> 当鼠标指针移动到某个元素上方时触发。</li><li><strong>鼠标移出事件（mouseout）：</strong> 当鼠标指针从某个元素移开时触发。</li><li><strong>双击事件（dblclick）：</strong> 当用户双击某个元素时触发。</li><li><strong>键盘按下事件（keydown）：</strong> 当用户按下键盘上的任意键时触发。</li><li><strong>键盘释放事件（keyup）：</strong> 当用户释放键盘上的按键时触发。</li><li><strong>表单提交事件（submit）：</strong> 当用户提交表单时触发。</li><li><strong>输入框失去焦点事件（blur）：</strong> 当元素失去焦点时触发。</li><li><strong>输入框获得焦点事件（focus）：</strong> 当元素获得焦点时触发。</li><li><strong>输入框内容改变</strong>：记得表单中元素，使用value属性获取。</li><li><strong>窗口加载事件（load）：</strong> 当页面加载完成时触发。</li><li><strong>窗口改变大小事件（resize）：</strong> 当窗口大小改变时触发。</li><li><strong>滚动事件（scroll）：</strong> 当用户滚动页面时触发。</li><li><strong>鼠标按下事件（mousedown）：</strong> 当鼠标按钮被按下时触发。</li><li><strong>鼠标释放事件（mouseup）：</strong> 当鼠标按钮被释放时触发。</li><li><strong>鼠标移动事件（mousemove）：</strong> 当鼠标指针在元素上移动时触发。</li></ol><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p><img src="/../images/image-20231212111852358.png" alt="image-20231212111852358"></p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;style&gt;    div{    display: none;} a{    display: none;    /* display: block; */    font-size: 14px;    font-family: 宋体;    color: gray;    text-decoration: none;       padding: 10px 0px 10px 0px;}&lt;/style&gt;&lt;body&gt;    &lt;span id="sp1" onmouseover="dips('menu1')" onmouseleave="disappare('menu1')"&gt;武器&lt;/span&gt;    &lt;span id="sp2" onmouseover="dips('menu2')" onmouseleave="disappare('menu2')"&gt;护甲&lt;/span&gt;    &lt;span id="sp3" onmouseover="dips('menu3')" onmouseleave="disappare('menu3')"&gt;英雄&lt;/span&gt;    &lt;div id="menu1"&gt;        &lt;a href=""&gt;大剑&lt;/a&gt;        &lt;a href=""&gt;斧子&lt;/a&gt;        &lt;a href=""&gt;牛魔&lt;/a&gt;    &lt;/div&gt;    &lt;div id="menu2"&gt;        &lt;a href=""&gt;胸甲&lt;/a&gt;        &lt;a href=""&gt;护腕&lt;/a&gt;        &lt;a href=""&gt;头盔&lt;/a&gt;    &lt;/div&gt;    &lt;div id="menu3"&gt;        &lt;a href=""&gt;盖伦&lt;/a&gt;        &lt;a href=""&gt;提莫&lt;/a&gt;        &lt;a href=""&gt;果汁&lt;/a&gt;    &lt;/div&gt;    &lt;script&gt;        function dips(name = "menu1"){            var menu = document.getElementById(name);            menu.style.display = "block";                console.log(menu.childElementCount);            Array.from(menu.children).forEach(function(element){                element.style.display = "block";            });        }        function disappare(name = 'menu1'){            var menu = document.getElementById(name);            menu.style.display = "none";                console.log(menu.childElementCount);            Array.from(menu.children).forEach(function(element){                element.style.display = "none";            });        }            &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="/../images/image-20231214162822952.png" alt="image-20231214162822952"></p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;        .ok {            color: green;            display: none;            font-size: 20px;        }        .nook {            color: red;            display: none;            font-size: 20px;        }        #username {            display: inline-block;        }    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div&gt;        &lt;input type="text" name="username" id="username" width="200px" oninput="f1()" onblur="f2()"&gt;    &lt;/div&gt;            &lt;span class="ok"&gt;用户名可以使用&lt;/span&gt;        &lt;span class="nook"&gt;用户名不可以使用&lt;/span&gt;        &lt;script&gt;        function f1() {            var username = document.getElementById("username");            var s = username.value;            var ok = document.getElementsByClassName("ok");            var nook = document.getElementsByClassName("nook");            console.log(s);            if (s != null &amp;&amp; s[0] != 'a') {                Array.from(nook).forEach(function (element) {                    element.style.display = 'none';                });                Array.from(ok).forEach(function (element) {                    element.style.display = 'inline';                });                            } else {                Array.from(ok).forEach(function (element) {                    element.style.display = 'none';                });                Array.from(nook).forEach(function (element) {                    element.style.display = 'inline';                });                            }        }        function f2() {            var username = document.getElementById("username");            var s = username.value;            var ok = document.getElementsByClassName("ok");            var nook = document.getElementsByClassName("nook");            if (s == null || s[0] != 'a') {                Array.from(ok).forEach(function (element) {                    element.style.display = 'none';                });                Array.from(nook).forEach(function (element) {                    element.style.display = 'none';                });            } else {                Array.from(ok).forEach(function (element) {                    element.style.display = 'none';                });                Array.from(nook).forEach(function (element) {                    element.style.display = 'inline';                });            }        }    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h1 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h1><p><code>createELement</code></p><p>在JavaScript中，可以使用以下步骤创建DOM对象并使用：</p><ol><li><p><strong>创建元素节点：</strong> 使用 <code>document.createElement</code> 方法创建一个新的元素节点。</p><pre><code class="JavaScript">var newElement = document.createElement('div');</code></pre></li><li><p><strong>设置元素属性：</strong> 使用 <code>element.setAttribute</code> 方法设置元素的属性。</p><pre><code class="JavaScript">newElement.setAttribute('id', 'myElement');newElement.setAttribute('class', 'myClass');</code></pre></li><li><p><strong>设置元素内容：</strong> 使用 <code>element.innerHTML</code> 或 <code>element.textContent</code> 设置元素的内容。</p><pre><code class="JavaScript">newElement.innerHTML = 'This is a new element!';</code></pre></li><li><p><strong>将元素添加到文档中：</strong> 使用 <code>document.appendChild</code> 或其他 DOM 操作方法将新元素添加到文档中。</p><pre><code class="JavaScript">document.body.appendChild(newElement);</code></pre></li></ol><h2 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h2><p><img src="/../images/image-20231218093518803.png" alt="image-20231218093518803"></p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;        .mytable {            border-collapse: collapse;        }        td {            width: 200px;        }    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id="div"&gt;    &lt;/div&gt;    &lt;script&gt;        var div = document.getElementById("div");        var newTable = document.createElement("table");        newTable.setAttribute("id", "mytable");        newTable.setAttribute("class", "mytable");        div.appendChild(newTable);        var newtr = document.createElement("tr");        newtr.setAttribute("class", "tr");        newtr.style.cssText = "border-bottom-style: solid;border-bottom-width: 1px;border-bottom-color: lightgray;height: 35px;";        var newtd1 = document.createElement("td");        newtd1.textContent = "id";        newtd1.style.textAlign = "center";        newtr.appendChild(newtd1);        var newtd2 = document.createElement("td");        newtd2.textContent = "名称";        newtd2.style.textAlign = "center";        newtr.appendChild(newtd2);        var newtd3 = document.createElement("td");        newtd3.textContent = "血量";        newtd3.style.textAlign = "center";        newtr.appendChild(newtd3);        var newtd4 = document.createElement("td");        newtd4.textContent = "伤害";        newtd4.style.textAlign = "center";        newtr.appendChild(newtd4);        newTable.appendChild(newtr);        newTable.appendChild(document.createElement('br'));        var newtr = document.createElement("tr");        newtr.setAttribute("class", "tr");        newtr.style.cssText = "border-bottom-style: solid;border-bottom-width: 1px;border-bottom-color: lightgray;height: 35px;";        var newtd1 = document.createElement("td");        newtd1.textContent = "1";        newtd1.style.textAlign = "center";        newtr.appendChild(newtd1);        var newtd2 = document.createElement("td");        newtd2.textContent = "gareen";        newtd2.style.textAlign = "center";        newtr.appendChild(newtd2);        var newtd3 = document.createElement("td");        newtd3.textContent = "340";        newtd3.style.textAlign = "center";        newtr.appendChild(newtd3);        var newtd4 = document.createElement("td");        newtd4.textContent = "58";        newtd4.style.textAlign = "center";        newtr.appendChild(newtd4);        newTable.appendChild(newtr);    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;        .mytable {            border-collapse: collapse;        }        td {            width: 200px;            text-align: center;            border-bottom: 1px solid lightgray;            height: 35px;        }    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id="div"&gt;    &lt;/div&gt;    &lt;script&gt;        var div = document.getElementById("div");        var newTable = document.createElement("table");        newTable.setAttribute("id", "mytable");        newTable.setAttribute("class", "mytable");        div.appendChild(newTable);        var headers = ["id", "名称", "血量", "伤害"];        var data = [            ["1", "gareen", "340", "58"]        ];        var headerRow = newTable.insertRow();        headers.forEach(function(header) {            var th = document.createElement("th");            th.textContent = header;            headerRow.appendChild(th);        });        data.forEach(function(rowData) {            var row = newTable.insertRow();            rowData.forEach(function(cellData) {                var cell = row.insertCell();                cell.textContent = cellData;            });        });    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h1 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h1><ol><li><code>parentNode.removeChild(childNode)</code>: 这个方法让您能够通过其父节点删除一个子节点。</li></ol><pre><code class="javascript">var childNode = document.getElementById("myElement");childNode.parentNode.removeChild(childNode);</code></pre><ol><li><code>remove()</code>: 这是一种更简洁的方法，直接从DOM中删除元素。</li></ol><pre><code class="javascript">var element = document.getElementById("myElement");element.remove();</code></pre><h2 id="练习-2"><a href="#练习-2" class="headerlink" title="练习"></a>练习</h2><p><img src="/../images/image-20231218095734262.png" alt="image-20231218095734262"></p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;button onclick="f1()"&gt;点击加载js&lt;/button&gt;    &lt;script&gt;        function f1(){            var newScript = document.createElement("script");            newScript.setAttribute("src", "1.js");            document.body.append(newScript);        }    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><pre><code class="javascript">var button = document.getElementById("button");button.onclick = function(){    f1();};</code></pre><h1 id="练习-3"><a href="#练习-3" class="headerlink" title="练习"></a>练习</h1><p><img src="/../images/image-20231219113230774.png" alt="image-20231219113230774"></p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;div&gt;        &lt;span&gt;账号：&lt;/span&gt;        &lt;input type="text" name="account" id="account"&gt;    &lt;/div&gt;    &lt;div&gt;        &lt;span&gt;密码：&lt;/span&gt;        &lt;input type="password" name="password" id="password"&gt;    &lt;/div&gt;    &lt;button onclick="f1()"&gt;提交&lt;/button&gt;    &lt;script&gt;        function f1(){            var account = document.getElementById("account").value;            var password = document.getElementById("password").value;            if(account == "" || password == ""){                alert("有空的，不彳");            }else{                alert("可以了");                location.reload();            }        }    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习记录之JavaScript</title>
      <link href="/2023/12/09/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E4%B9%8BJavaScript/"/>
      <url>/2023/12/09/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E4%B9%8BJavaScript/</url>
      
        <content type="html"><![CDATA[<p>学习记录：~</p><h1 id="语言基础"><a href="#语言基础" class="headerlink" title="语言基础"></a>语言基础</h1><h2 id="1-1-输出"><a href="#1-1-输出" class="headerlink" title="1.1 输出"></a>1.1 输出</h2><pre><code class="html">&lt;script&gt;  document.write("Hello Javascript");&lt;/script&gt;</code></pre><h2 id="1-2-位置"><a href="#1-2-位置" class="headerlink" title="1.2 位置"></a>1.2 位置</h2><p>javascript代码必须放在script标签中</p><p>script标签可以放在html的任何地方，一般建议放在head标签里</p><pre><code class="html">&lt;html&gt;  &lt;script src="https://how2j.cn/study/hello.js"&gt;&lt;/script&gt;&lt;/html&gt;</code></pre><h2 id="1-3-注释"><a href="#1-3-注释" class="headerlink" title="1.3 注释"></a>1.3 注释</h2><p>类似c/c++，</p><pre><code class="html">&lt;script&gt;    //单行注释    /*        多行注释    */  document.write("Hello Javascript");&lt;/script&gt;</code></pre><h2 id="1-4-变量"><a href="#1-4-变量" class="headerlink" title="1.4 变量"></a>1.4 变量</h2><p>使用或不适用var声明</p><pre><code class="html">&lt;script&gt;  var x = 10;  document.write("变量x的值:"+x);&lt;/script&gt;</code></pre><h2 id="1-5-基本数据类型"><a href="#1-5-基本数据类型" class="headerlink" title="1.5 基本数据类型"></a>1.5 基本数据类型</h2><p>undefined,Boolean,Number,String,null</p><p>var是动态类型</p><p>类型判断<code>typeof x</code></p><h2 id="1-6-类型转换"><a href="#1-6-类型转换" class="headerlink" title="1.6 类型转换"></a>1.6 类型转换</h2><p>Number，Boolean，String都有toString方法，转化为字符串。</p><p>转化为数字parseInt，parseFloat</p><p>转化为布尔，Boolean();</p><h2 id="1-7-函数"><a href="#1-7-函数" class="headerlink" title="1.7 函数"></a>1.7 函数</h2><pre><code class="javascript">function print(){    document.write("这是函数的输出");}print();</code></pre><pre><code class="javascript">function printmessage(message){    document.write(message + "&lt;br&gt;");}printmessage(1);printmessage(2);</code></pre><h2 id="1-8-练习1"><a href="#1-8-练习1" class="headerlink" title="1.8 练习1"></a>1.8 练习1</h2><p><img src="E:/hexo/1PHAN-7878.github.io/source/images/image-20231209161803653.png" alt="image-20231209161803653"></p><pre><code class="html">    &lt;input id="num1" type="text"&gt;     +     &lt;input id="num2" type="text"&gt;     =      &lt;input id="result" type="text"&gt;    &lt;button id="button" onclick="f1()"&gt;计算&lt;/button&gt;    &lt;script&gt;        function f1(){            var value1 = parseInt(document.getElementById("num1").value);            var value2 = parseInt(document.getElementById("num2").value);            var result = value1 + value2;            document.getElementById("result").value = result;        }    &lt;/script&gt;</code></pre><h2 id="1-9-事件"><a href="#1-9-事件" class="headerlink" title="1.9 事件"></a>1.9 事件</h2><p>鼠标点击事件</p><pre><code class="html">&lt;script&gt;    function show(){       alert("Hello");}&lt;/script&gt; &lt;button onclick="show()"&gt;点击一下&lt;/button&gt;</code></pre><h2 id="1-10-运算符"><a href="#1-10-运算符" class="headerlink" title="1.10 运算符"></a>1.10 运算符</h2><p>仅有== 与 === 不相同</p><p>==仅仅判断值是否相同</p><p>===还要判断类型</p><h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><h2 id="2-1-数字对象"><a href="#2-1-数字对象" class="headerlink" title="2.1 数字对象"></a>2.1 数字对象</h2><pre><code class="html">    &lt;script&gt;        var x = new Number(111);        document.write(x + "&lt;br&gt;");     //111        document.write(typeof x);       //Object        var y = 10;        document.write(typeof y);       //number    &lt;/script&gt;</code></pre><p>最大最小值 <code>Number.MIN_VALUE Number.MAX_VALUE</code></p><p>判断是不是数字对象<code>isNaN()</code></p><p>返回x位小数<code>.toFixed(3)</code></p><p>返回科学计数法<code>.toExponential()</code></p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p><img src="E:/hexo/1PHAN-7878.github.io/source/images/image-20231209200016752.png" alt="image-20231209200016752"></p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;input type="number" id="x"&gt;&lt;/input&gt;     *     &lt;input type="number" id="y"&gt;&lt;/input&gt;     =     &lt;input type="text" name="" id="ans"&gt;&lt;/input&gt;    &lt;button onclick="f1()"&gt;计算&lt;/button&gt;    &lt;script&gt;        function f1(){            var x = document.getElementById("x").value;            var y = document.getElementById("y").value;            document.getElementById("ans").value = Number(x * y).toExponential().toString();        }    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="2-2-字符串对象"><a href="#2-2-字符串对象" class="headerlink" title="2.2 字符串对象"></a>2.2 字符串对象</h2><pre><code class="html">    &lt;script&gt;        var str = new String("333");        document.write(str +         "&lt;br&gt;");    &lt;/script&gt;</code></pre><p>长度.length</p><p>获取指定位置的字符<code>.charAt()</code></p><p>拼接<code>.concat()</code></p><p>第一次出现的位置<code>.indexOf()</code></p><p>是否相同<code>.localeCompare()</code></p><p>截取一段子字符串<code>.substring(a, b);</code>左闭右开</p><p>通过分隔符分离``.split(“ “, 2); `第二个参数可选表示保留几个</p><p>替换<code>.replace(search, replacement);</code></p><h2 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h2><p><img src="E:/hexo/1PHAN-7878.github.io/source/images/image-20231209204127173.png" alt="image-20231209204127173"></p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;字符串替换工具&lt;/h1&gt;    &lt;div&gt;        &lt;p&gt;源字符串：&lt;/p&gt;        &lt;input type="text" id="init"&gt;    &lt;/div&gt;    &lt;div&gt;        &lt;p&gt;查询：&lt;/p&gt;        &lt;input type="text" id="search"&gt;    &lt;/div&gt;    &lt;div&gt;        &lt;p&gt;替换为：&lt;/p&gt;        &lt;input type="text" id="replacement"&gt;    &lt;/div&gt;    &lt;div&gt;        &lt;p&gt;替换结果&lt;/p&gt;        &lt;input type="text" id="result"&gt;    &lt;/div&gt;    &lt;button id="button" onclick="f1()"&gt;替换&lt;/button&gt;    &lt;script&gt;        function f1(){            var str = new String(document.getElementById("init").value);            var search = new String(document.getElementById("search").value);            var replacement = new String(document.getElementById("replacement").value);            while(str.indexOf(search) != -1){                //JavaScript 的 replace 方法不会修改原始字符串，而是返回一个新的字符串。                //str.replace(search, replacement);                str = str.replace(search, replacement);            }            document.getElementById("result").value = str;        }    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="2-3-数组"><a href="#2-3-数组" class="headerlink" title="2.3 数组"></a>2.3 数组</h2><pre><code class="JavaScript">创建数组：// 使用数组字面量创建数组var fruits = ["Apple", "Banana", "Orange"];// 使用构造函数创建数组var numbers = new Array(1, 2, 3, 4, 5);</code></pre><p>类似数组访问<code>numbers[0]</code></p><p>数组长度<code>.length</code></p><p>末尾操作<code>.push(), .pop()</code></p><p>开头操作<code>.shift(), .unshift()</code></p><p>删除<code>.splice(a,b)</code>从a,删除b个元素</p><p>返回子数组<code>slice(a, b)</code> 返回子数组[a, b)</p><p>排序<code>.sort()</code> </p><p>采用自定义的排序，需要使用自定义函数</p><pre><code class="javascript">var a = new Array(1, 2, 8, 4, 5, 7);//a[0];document.write(a[2]);function cmp(v1, v2){    return v2 - v1;}a.sort(cmp);</code></pre><p>翻转 <code>.reverse()</code></p><h2 id="练习-2"><a href="#练习-2" class="headerlink" title="练习"></a>练习</h2><p><img src="E:/hexo/1PHAN-7878.github.io/source/images/image-20231209205901219.png" alt="image-20231209205901219"></p><pre><code class="html">    &lt;script&gt;        var a = new Array(1,3,4,5,7,4,5,6,7,7);        a.sort();        var b =  new Array();        for(var i = 0; i &lt; a.length; i++){            if(i == 0){                b.push(a[i]);            }else{                if(a[i] != a[i-1]) b.push(a[i]);            }        }        document.write(b);    &lt;/script&gt;</code></pre><p><img src="E:/hexo/1PHAN-7878.github.io/source/images/image-20231209210523827.png" alt="image-20231209210523827"></p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;!-- &lt;script&gt;        var a = new Array(1,3,4,5,7,4,5,6,7,7);        a.sort();        var b =  new Array();        for(var i = 0; i &lt; a.length; i++){            if(i == 0){                b.push(a[i]);            }else{                if(a[i] != a[i-1]) b.push(a[i]);            }        }        document.write(b);    &lt;/script&gt; --&gt;    &lt;p&gt;输入一段英文字符串&lt;/p&gt;    &lt;input type="text" id="init"&gt;    &lt;p&gt;正向排列&lt;/p&gt;    &lt;input type="text" id="zheng"&gt;    &lt;p&gt;反向排列&lt;/p&gt;    &lt;input type="text" id="fanxiang"&gt;    &lt;button id="zimu" onclick="f1()"&gt;按字母&lt;/button&gt;    &lt;button id="zifu" onclick="f2()"&gt;按字符&lt;/button&gt;    &lt;script&gt;        //手搓        function f1(){            var str = document.getElementById("init").value;            var strArr = new Array();            for(var i = 0; i &lt;str.length; i++){                strArr.push(str[i]);            }            strArr.sort();            var strZheng = new String();            for(var i = 0; i &lt; strArr.length; i++){                strZheng += strArr[i];            }            document.getElementById("zheng").value = strZheng;            strArr.reverse();            var strFanxiang = new String();            strArr.forEach(function (char) {                strFanxiang += char;            })            document.getElementById("fanxiang").value = strFanxiang;        }        //改进        function f2(){            var str = new String(document.getElementById("init").value);            var strArr = str.split(' ');            strArr.sort();            var strZheng = strArr.join(' ');            document.getElementById("zheng").value = strZheng;            strArr.reverse();            var strFanxiang = strArr.join(' ');            document.getElementById("fanxiang").value = strFanxiang;        }    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="2-4-时间"><a href="#2-4-时间" class="headerlink" title="2.4 时间"></a>2.4 时间</h2><h3 id="创建一个-Date-对象"><a href="#创建一个-Date-对象" class="headerlink" title="创建一个 Date 对象"></a>创建一个 Date 对象</h3><pre><code class="JavaScript">// 创建一个表示当前日期和时间的 Date 对象var currentDate = new Date();// 创建一个表示特定日期和时间的 Date 对象（年、月、日、时、分、秒）var specificDate = new Date(2023, 0, 1, 12, 0, 0); // 月份从0开始，0 表示一月</code></pre><h3 id="获取日期和时间的各个部分"><a href="#获取日期和时间的各个部分" class="headerlink" title="获取日期和时间的各个部分"></a>获取日期和时间的各个部分</h3><pre><code class="javascript">var year = currentDate.getFullYear(); // 年份var month = currentDate.getMonth(); // 月份（0 到 11）var day = currentDate.getDate(); // 日期var hours = currentDate.getHours(); // 小时var minutes = currentDate.getMinutes(); // 分钟var seconds = currentDate.getSeconds(); // 秒钟var milliseconds = currentDate.getMilliseconds(); // 毫秒</code></pre><h3 id="设置日期和时间的各个部分"><a href="#设置日期和时间的各个部分" class="headerlink" title="设置日期和时间的各个部分"></a>设置日期和时间的各个部分</h3><pre><code class="JavaScript">currentDate.setFullYear(2023);currentDate.setMonth(5); // 月份从0开始，5 表示六月currentDate.setDate(15);currentDate.setHours(18);currentDate.setMinutes(30);currentDate.setSeconds(45);currentDate.setMilliseconds(500);</code></pre><h3 id="格式化日期和时间字符串"><a href="#格式化日期和时间字符串" class="headerlink" title="格式化日期和时间字符串"></a>格式化日期和时间字符串</h3><pre><code class="JavaScript">var formattedDate = currentDate.toDateString(); // 格式化为日期字符串var formattedTime = currentDate.toTimeString(); // 格式化为时间字符串var formattedDateTime = currentDate.toLocaleString(); // 格式化为日期和时间字符串</code></pre><h3 id="获取时间戳"><a href="#获取时间戳" class="headerlink" title="获取时间戳"></a>获取时间戳</h3><pre><code class="JavaScript">var timestamp = currentDate.getTime(); // 获取表示当前时间的时间戳（毫秒数）</code></pre><h2 id="练习-3"><a href="#练习-3" class="headerlink" title="练习"></a>练习</h2><p><img src="E:/hexo/1PHAN-7878.github.io/source/images/image-20231209220145733.png" alt="image-20231209220145733"></p><p>本来要照着做，结果发现这个日期判断跟算法题似的。</p><p>就做了个框架，但是这个里面也有可以学习到的知识。</p><pre><code class="html">&lt;div&gt;        &lt;span&gt;选择出生年份：&lt;/span&gt;        &lt;select name="year" id="year"&gt;            &lt;script type="text/javascript"&gt;                var a, s = "";                for(a = 1960; a &lt; 2023; a++){                    if(a == 2000){                        s = s + "&lt;option selected="+ "selected" + "&gt;" + a + "&lt;/option&gt;&lt;br&gt;"                    }else{                        s = s + "&lt;option&gt;" + a + "&lt;/option&gt;&lt;br&gt;";                    }                }                document.write(s);            &lt;/script&gt;        &lt;/select&gt;        &lt;br&gt;        &lt;span&gt;选择出生月份：&lt;/span&gt;        &lt;select name="month" id="month"&gt;            &lt;script&gt;                for(var i = 1; i &lt;= 12; i++){                    document.write(`&lt;option&gt;${i}&lt;/option&gt;`);                }            &lt;/script&gt;        &lt;/select&gt;        &lt;br&gt;        &lt;span&gt;请选择出生日：&lt;/span&gt;        &lt;select name="day" id="day"&gt;            &lt;script&gt;                for(var i = 1; i &lt;= 31; i++){                    document.write(`&lt;option${i === 15 ? " selected" : ""}&gt;${i}&lt;/option&gt;`);                }            &lt;/script&gt;        &lt;/select&gt;    &lt;/div&gt;</code></pre><h1 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h1><h2 id="3-1-Window"><a href="#3-1-Window" class="headerlink" title="3.1 Window"></a>3.1 Window</h2><ol><li><p><strong>全局作用域：</strong> 在浏览器环境中，所有全局声明的变量和函数都成为 <code>window</code> 对象的属性和方法。这意味着您可以通过 <code>window</code> 对象访问全局作用域中的任何变量或函数。</p><pre><code class="javascript">var globalVariable = 42;console.log(window.globalVariable); // 输出: 42</code></pre></li><li><p><strong>浏览器窗口控制：</strong> <code>window</code> 对象提供了许多方法来控制和操作浏览器窗口，比如打开新窗口、关闭窗口、调整窗口大小等。</p><pre><code class="javascript">window.open("https://www.example.com", "_blank"); // 打开新窗口window.close(); // 关闭当前窗口window.resizeTo(800, 600); // 调整窗口大小</code></pre></li><li><p><strong>定时器和间歇调用：</strong> <code>window</code> 对象提供了 <code>setTimeout</code> 和 <code>setInterval</code> 方法，用于执行函数或代码片段的定时调用。</p><pre><code class="javascript">setTimeout(function() {    console.log("Delayed message");}, 2000);setInterval(function() {    console.log("Repeated message every 1 second");}, 1000);</code></pre></li><li><p><strong>提示框和对话框：</strong> <code>window</code> 对象提供了 <code>alert</code>、<code>confirm</code> 和 <code>prompt</code> 等方法，用于显示提示框和对话框，与用户进行交互。</p><pre><code class="javascript">alert("This is an alert message");var userConfirmed = confirm("Do you want to proceed?");var userInput = prompt("Please enter your name:", "John Doe");</code></pre></li><li><p><strong>导航和位置信息：</strong> <code>window</code> 对象包含有关当前文档和浏览器位置的信息，例如当前的 URL、浏览器的历史记录等。</p><pre><code class="javascript">console.log(window.location.href); // 当前页面的 URLconsole.log(window.history.length); // 浏览器历史记录的长度</code></pre></li></ol><h2 id="3-2-Navigator"><a href="#3-2-Navigator" class="headerlink" title="3.2 Navigator"></a>3.2 Navigator</h2><ol><li><p><strong><code>navigator.userAgent</code>：</strong> 包含有关浏览器用户代理的字符串，其中包含有关浏览器名称、版本和操作系统的信息。</p><pre><code class="javascript">var userAgentString = navigator.userAgent;console.log(userAgentString);</code></pre></li><li><p><strong><code>navigator.appName</code>：</strong> 返回浏览器的名称，通常是 “Netscape”。</p><pre><code class="javascript">var browserName = navigator.appName;console.log(browserName);</code></pre></li><li><p><strong><code>navigator.appVersion</code>：</strong> 返回包含有关浏览器版本的字符串。</p><pre><code class="javascript">var browserVersion = navigator.appVersion;console.log(browserVersion);</code></pre></li><li><p><strong><code>navigator.platform</code>：</strong> 返回浏览器运行的操作系统平台。</p><pre><code class="javascript">var platform = navigator.platform;console.log(platform);</code></pre></li><li><p><strong><code>navigator.language</code>：</strong> 返回用户浏览器的首选语言。</p><pre><code class="javascript">var language = navigator.language;console.log(language);</code></pre></li></ol><h2 id="3-3-Screen"><a href="#3-3-Screen" class="headerlink" title="3.3 Screen"></a>3.3 Screen</h2><p><code>screen</code> 对象是 JavaScript 中的全局对象之一，表示用户的屏幕。<code>screen</code> 对象提供了有关用户屏幕的信息，如屏幕的宽度、高度、可见区域的宽度和高度等。以下是一些 <code>screen</code> 对象的常用属性：</p><ol><li><p><strong><code>screen.width</code>：</strong> 返回屏幕的宽度（以像素为单位）。</p><pre><code class="JavaScript">var screenWidth = screen.width;console.log(screenWidth);</code></pre></li><li><p><strong><code>screen.height</code>：</strong> 返回屏幕的高度（以像素为单位）。</p><pre><code class="JavaScript">var screenHeight = screen.height;console.log(screenHeight);</code></pre></li><li><p><strong><code>screen.availWidth</code>：</strong> 返回屏幕可用的宽度，即减去任务栏等系统元素后的宽度。</p><pre><code class="JavaScript">var availableScreenWidth = screen.availWidth;console.log(availableScreenWidth);</code></pre></li><li><p><strong><code>screen.availHeight</code>：</strong> 返回屏幕可用的高度，即减去任务栏等系统元素后的高度。</p><pre><code class="JavaScript">var availableScreenHeight = screen.availHeight;console.log(availableScreenHeight);</code></pre></li></ol><h2 id="3-4-History"><a href="#3-4-History" class="headerlink" title="3.4 History"></a>3.4 History</h2><p><code>history</code> 对象是 JavaScript 中的一个内置对象，提供了对浏览器窗口历史记录的访问和操作。通过 <code>history</code> 对象，您可以在用户的浏览历史中向前或向后导航，以及操作历史记录的状态。以下是一些 <code>history</code> 对象的常用方法和属性：</p><p>常用方法：</p><ol><li><p><strong><code>history.back()</code>：</strong> 向后导航，等效于用户点击浏览器的后退按钮。</p><pre><code class="javascript">history.back();</code></pre></li><li><p><strong><code>history.forward()</code>：</strong> 向前导航，等效于用户点击浏览器的前进按钮。</p><pre><code class="JavaScript">history.forward();</code></pre></li><li><p><strong><code>history.go(number)</code>：</strong> 导航到指定的历史记录条目，<code>number</code> 参数可以是正数（向前导航）或负数（向后导航）。</p><pre><code class="JavaScript">// 向前导航两步history.go(2);// 向后导航一步history.go(-1);</code></pre></li></ol><h2 id="3-5-location"><a href="#3-5-location" class="headerlink" title="3.5 location"></a>3.5 location</h2><ol><li><p><strong><code>location.assign(url)</code>：</strong> 加载新的 URL，与设置 <code>window.location.href = url</code> 效果相同。</p><pre><code class="JavaScript">location.assign("https://www.example.com");</code></pre></li><li><p><strong><code>location.reload()</code>：</strong> 重新加载当前页面。</p><pre><code class="JavaScript">location.reload();</code></pre></li><li><p><strong><code>location.replace(url)</code>：</strong> 用新的 URL 替换当前页面，不会在浏览历史中留下记录。</p><pre><code class="JavaScript">location.replace("https://www.example.com");</code></pre></li></ol><h2 id="3-6-弹出框"><a href="#3-6-弹出框" class="headerlink" title="3.6 弹出框"></a>3.6 弹出框</h2><ol><li><p><strong><code>alert()</code>：</strong> 弹出警告框，用于向用户显示一条消息，并等待用户点击“确定”按钮。这种对话框只有一个按钮。</p><pre><code class="JavaScript">alert("This is an alert message!");</code></pre></li><li><p><strong><code>confirm()</code>：</strong> 弹出确认框，用于向用户显示一条消息，并等待用户点击“确定”或“取消”按钮。这种对话框有两个按钮。</p><pre><code class="JavaScript">var userConfirmed = confirm("Do you want to proceed?");if (userConfirmed) {    // 用户点击了确定按钮} else {    // 用户点击了取消按钮}</code></pre></li></ol><h2 id="3-7-计时器"><a href="#3-7-计时器" class="headerlink" title="3.7 计时器"></a>3.7 计时器</h2><p>JavaScript 提供了两种类型的计时器：<code>setTimeout</code> 和 <code>setInterval</code>，它们都用于在一定的时间间隔后执行指定的代码。以下是这两种计时器的基本用法：</p><h3 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout"></a><code>setTimeout</code></h3><p><code>setTimeout</code> 用于在指定的延迟时间后执行一次性的代码。</p><pre><code class="JavaScript">// 示例：在2秒后执行一次性的代码setTimeout(function() {    console.log("This code will be executed after 2000 milliseconds (2 seconds).");}, 2000);</code></pre><h3 id="setInterval"><a href="#setInterval" class="headerlink" title="setInterval"></a><code>setInterval</code></h3><p><code>setInterval</code> 用于在指定的时间间隔内重复执行指定的代码。</p><pre><code class="JavaScript">// 示例：每隔1秒执行一次代码var intervalId = setInterval(function() {    console.log("This code will be executed every 1000 milliseconds (1 second).");}, 1000);</code></pre><h3 id="清除计时器"><a href="#清除计时器" class="headerlink" title="清除计时器"></a>清除计时器</h3><p>可以使用 <code>clearTimeout</code> 和 <code>clearInterval</code> 来取消相应的计时器。</p><pre><code class="JavaScript">// 使用 setTimeout 创建一个计时器，并立即取消它var timeoutId = setTimeout(function() {    console.log("This code will not be executed.");}, 1000);clearTimeout(timeoutId);// 使用 setInterval 创建一个计时器，并在5秒后取消它var counter = 0;var intervalId = setInterval(function() {    console.log("This code will be executed every second.");    counter++;    if (counter &gt;= 5) {        clearInterval(intervalId);        console.log("Interval canceled after 5 seconds.");    }}, 1000);</code></pre><p>请注意，<code>setTimeout</code> 和 <code>setInterval</code> 返回的是计时器的标识符，可以用于后续取消计时器。<code>clearTimeout</code> 用于取消 <code>setTimeout</code> 创建的计时器，而 <code>clearInterval</code> 用于取消 <code>setInterval</code> 创建的计时器。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MATLAB关于图像修复的学习实践</title>
      <link href="/2023/12/06/MATLAB%E5%85%B3%E4%BA%8E%E5%9B%BE%E5%83%8F%E4%BF%AE%E5%A4%8D%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5/"/>
      <url>/2023/12/06/MATLAB%E5%85%B3%E4%BA%8E%E5%9B%BE%E5%83%8F%E4%BF%AE%E5%A4%8D%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="任务需求"><a href="#任务需求" class="headerlink" title="任务需求"></a>任务需求</h1><p>天气怎么又有点暖和了，今天学了图像修复，以及图像的恢复。这两个貌似很相似，不过一个是对于噪声的，一个是直接把图片的一部分给扣走。晚上的任务是，能否自己实现一个图像补全，图像修复？</p><h1 id="查询资料"><a href="#查询资料" class="headerlink" title="查询资料"></a>查询资料</h1><p>图像补全，即是将图片中缺失的像素补充上, 目的是使得没有看过这原图像的观察者无法察觉出这其实是补全的图像。 有时为了移除图像中的一些物体, 会手动地将这些物体遮挡起来进行补全。 一般来说, 按照补全的难易程度可以将该问题分成两类: (1) 补全较小的区域 —— 细缝, 文字等; (2)补全较大的区域 —— 整块的缺失图片。</p><p><img src="/../images/image-20231206200659347.png" alt="image-20231206200659347"></p><p><img src="/../images/image-20231206200706653.png" alt="image-20231206200706653">不过的话，这样看起来简单，其实是不太好做，这上面两张图是中科院研究所做的。我的话，想的是看看MATLAB中是否有类似的函数等可以使用。</p><p>方法大致如下：</p><p><img src="/../images/image-20231206201027274.png" alt="image-20231206201027274"></p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><pre><code class="matlab">img = imread('C:\Users\7878\Desktop\my_image.png');img1 = imresize(img, 0.3);img1 = rgb2gray(img1);% 定义缺失块的位置和大小missingBlockPosition = [400, 250];missingBlockSize = [50, 50];% 制作掩码，将缺失块区域置零mask = ones(size(img1));mask(missingBlockPosition(1):missingBlockPosition(1)+missingBlockSize(1)-1, ...     missingBlockPosition(2):missingBlockPosition(2)+missingBlockSize(2)-1) = 0; img1 = img1 .* uint8(mask);inversemask = ~mask;% reconstructedImage = inpaint_nans(img1, mask);% reconstructedImage = fillmissing(img1, 'linear');reconstructedImage = regionfill(img1, inversemask);% 显示结果figure;subplot(1, 2, 1), imshow(img1), title('Original Image');subplot(1, 2, 2), imshow(reconstructedImage), title('Reconstructed Image'); </code></pre><p>效果：</p><p><img src="/../images/image-20231206200844084.png" alt="image-20231206200844084"></p><p>对于这种与周围区别不大的图像，确实能够有一定的效果，也是补全了黑色的区域。</p>]]></content>
      
      
      
        <tags>
            
            <tag> MATLAB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络数据封装</title>
      <link href="/2023/12/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E5%B0%81%E8%A3%85/"/>
      <url>/2023/12/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E5%B0%81%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>实验十、数据封装实验</p><h1 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a>一、实验目的</h1><p>1.回顾静态路由的配置方法，根据网络拓扑实现两台PC互通。</p><p>2.了解CISCO模拟器的simulation mode（模拟模式），观察网络数据包的来龙去脉。</p><p>3.掌握以太网帧的构成，了解各个字段的含义；</p><p>4．能够识别不同的MAC地址并理解MAC地址的作用；</p><p>5.掌握IP数据包的组成和网络层的基本功能；</p><p>6．理解ICMP协议与IP协议的封装关系。</p><h1 id="二、实验内容"><a href="#二、实验内容" class="headerlink" title="二、实验内容"></a>二、实验内容</h1><p>1．安装CISCO模拟器；</p><p>2．画出网络拓扑图；</p><p>3．进行静态路由的配置；</p><p>4．测试网络的通信效果；</p><p>5.通过PING命令捕捉ICMP报文，观察ICMP协议与IP协议的封装关系。</p><h1 id="三、实验原理"><a href="#三、实验原理" class="headerlink" title="三、实验原理"></a>三、实验原理</h1><p>1．以太网帧结构。以太网中传输的数据包通常被称为“帧”，以太网的“帧”结构如下：</p><p><img src="/../images/image-20231205194155695.png" alt="image-20231205194155695"></p><p>各字段的含义：</p><p>目的地址：6个字节的目的物理地址标识帧的接收结点；</p><p>源地址：6个字节的源物理地址标识帧的发送结点；</p><p>帧类型/长度（TYPE/LEN）：该字段的值大于或等于0x0600时，表示上层数据使用的协议类型。例如0x0806表示ARP请求或应答，0x0800表示IP协议。该字段的值小于0x0600时表示以太网用户数据的长度字段，上层携带LLC-PDU；</p><p>数据字段：这是一个可变长度字段，用于携带上层传下来的数据；</p><p>帧校验FCS：以太网采用32位CRC冗余校验。校验范围是目的地址、源地址、长度/类型、数据字段。</p><p>2．IP数据报格式</p><p><img src="/../images/image-20231205194224831.png" alt="image-20231205194224831"></p><p>3.ICMP回显请求和应答报文格式</p><p>网络测试程序 Ping就是利用ICMP的回显请求报文完成的，回显请求报文的类型是8，代码是0。ICMP回显请求报文格式如下：</p><p> <img src="/../images/image-20231205194233314.png" alt="image-20231205194233314"></p><h1 id="四、实验步骤"><a href="#四、实验步骤" class="headerlink" title="四、实验步骤"></a>四、实验步骤</h1><p>1、画出拓扑图并配置各IP如下：</p><p> <img src="/../images/image-20231205194241903.png" alt="image-20231205194241903"></p><p>2、仿照实验八，自行配置路由表，使得两台PC可以互相ping通。</p><p>3、观察数据包进出每个设备时的变化，截屏记录，并回答思考题。</p><p>注意：</p><ol><li><p>别忘打开路由器端口，特别是在图形界面上操作时</p></li><li><p>在路由器上可以ping通，PC还是ping不同，why？没有设置网关。</p></li></ol><p>3.将模拟器调到模拟模式，在PC0的桌面上运行ping命令，ping PC1，点击Auto capture，观察ICMP协议过程。要了解协议的详细信息，可单击显示不同颜色的协议类型信息Info。从而看到OSI模型信息和各层PDU信息。</p><h1 id="五、-思考问题"><a href="#五、-思考问题" class="headerlink" title="五、 思考问题"></a>五、 思考问题</h1><p>结合实验过程中的实验结果，回答下列问题：</p><p>1．IP数据包在从源主机出发到达目的主机的过程中，IP首部中的IP源地址和目的地址字段是否发生变化？</p><p>IP首部的IP地址并没有发生变化。</p><p>2.以太网数据帧中的MAC地址是否发生了变化？</p><p>MAC地址发生了变化</p><p>3.协议之间是怎样进行数据封装的？请结合TCP/IP模型或OSI模型说明本次实验中数据传输的过程。</p><ol><li><strong>应用层（Application Layer）</strong>：<ul><li>发送端：应用层负责生成应用层数据，并将其传递给传输层。例如，在HTTP中，这可能是一个HTTP请求。</li><li>接收端：应用层接收传输层的数据，然后将其传递给上层应用。</li></ul></li><li><strong>传输层（Transport Layer）</strong>：<ul><li>发送端：传输层负责将上层数据分割为适当的大小，管理数据的流动，并添加传输层的首部信息。在TCP中，这包括源端口、目标端口、序列号等。</li><li>接收端：传输层接收底层数据，去除传输层的首部，然后将其传递给上层。</li></ul></li><li><strong>网络层（Network Layer）</strong>：<ul><li>发送端：网络层添加网络层的首部，包括源IP地址和目标IP地址等。这个包含了数据从一个节点到另一个节点的路径信息。</li><li>接收端：网络层接收数据，去除网络层的首部，然后将其传递给传输层。</li></ul></li><li><strong>数据链路层（Data Link Layer）</strong>：<ul><li>发送端：数据链路层添加数据链路层的首部，通常包括物理地址（MAC地址）等信息。</li><li>接收端：数据链路层接收数据，去除数据链路层的首部，然后将其传递给网络层。</li></ul></li><li><strong>物理层（Physical Layer）</strong>：<ul><li>发送端：物理层将数据转化为比特流，通过物理媒体传输。</li><li>接收端：物理层接收比特流，然后将其传递给数据链路层。</li></ul></li></ol><p><img src="/../images/image-20231205194429709.png" alt="image-20231205194429709"></p><p><img src="/../images/image-20231205194436611.png" alt="image-20231205194436611"></p><p><img src="/../images/image-20231205194442373.png" alt="image-20231205194442373"></p><p><img src="/../images/image-20231205194447888.png" alt="image-20231205194447888"></p><p><img src="/../images/image-20231205194452895.png" alt="image-20231205194452895"></p><p><img src="/../images/image-20231205194457344.png" alt="image-20231205194457344"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity中实现摄像头跟随物体旋转移动</title>
      <link href="/2023/12/04/Unity%E4%B8%AD%E5%AE%9E%E7%8E%B0%E6%91%84%E5%83%8F%E5%A4%B4%E8%B7%9F%E9%9A%8F%E7%89%A9%E4%BD%93%E6%97%8B%E8%BD%AC%E7%A7%BB%E5%8A%A8/"/>
      <url>/2023/12/04/Unity%E4%B8%AD%E5%AE%9E%E7%8E%B0%E6%91%84%E5%83%8F%E5%A4%B4%E8%B7%9F%E9%9A%8F%E7%89%A9%E4%BD%93%E6%97%8B%E8%BD%AC%E7%A7%BB%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><p>想做一个类似于很多游戏中，你移动了视角，摄像机移动了视角，物体移动了角度。但是物体还是保持在屏幕中心，而且当你移动之后，wasd控制的移动是根据你的视角向前移动的，而不是向初始的方向移动，这个其实做起来还是有点难度（新。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p><code>player.cs</code></p><pre><code class="c#">using System.Collections;using System.Collections.Generic;using UnityEngine;public class player : MonoBehaviour{    public Camera playerCamera;    public float rotateSpeed = 3f;    public float moveSpeed = 1f;    public Rigidbody rb;    private int raycastDistance;    // Start is called before the first frame update    void Start()    {        rb = GetComponent&lt;Rigidbody&gt;();    }    // Update is called once per frame    void Update()    {        //// 获取输入        //float horizontal = Input.GetAxis("Horizontal");        //float vertical = Input.GetAxis("Vertical");        //// 获取相机的正前方和正右方向        //Vector3 cameraForward = Camera.main.transform.forward;        //Vector3 cameraRight = Camera.main.transform.right;        //// 计算移动方向        ////Vector3 movement = new Vector3(horizontal, 0f, vertical) * moveSpeed;        //Vector3 movement = (cameraForward * vertical + cameraRight * horizontal).normalized;        ////Vector3 movement = new Vector3(horizontal, 0f, vertical) * moveSpeed;        //// 应用移动        ////rb.AddForce(movement, ForceMode.Acceleration);        //rb.MovePosition(transform.position + movement);        //// 获取鼠标水平移动的输入        //float mouseX = Input.GetAxis("Mouse X");        //// 计算旋转角度        //float rotationAmount = mouseX * rotateSpeed;        //// 应用旋转        //transform.Rotate(Vector3.up, rotationAmount);        float horizontal = Input.GetAxis("Horizontal");        float vertical = Input.GetAxis("Vertical");        // 获取摄像机的朝向        Vector3 cameraForward = playerCamera.transform.forward;        Vector3 cameraRight = playerCamera.transform.right;        //cameraForward.y = 0f;        //cameraRight.y = 0f;        // 计算移动方向        //Vector3 movement = new Vector3(horizontal, 0f, vertical) * moveSpeed;        // 根据输入和摄像机的朝向计算移动方向        Vector3 movement = (cameraForward.normalized * vertical + cameraRight.normalized * horizontal) * moveSpeed;        movement.y = 0f;        // 应用移动        //rb.AddForce(movement, ForceMode.VelocityChange);        rb.MovePosition(movement + rb.position);    }}</code></pre><p><code>camera.cs</code></p><pre><code class="C#">using System.Collections;using System.Collections.Generic;using UnityEngine;public class camera : MonoBehaviour{    public Transform target;    public Vector3 offset;  // 相机相对于物体的偏移量    public Vector3 newPosition;    public float followSpeed = 5f; // 跟随速度    public float rotationSpeed = 2f; // 旋转速度    public float rotateSpeed = 3f;    // Start is called before the first frame update    void Start()    {        offset = transform.position - target.position;    }    // Update is called once per frame    void Update()    {        //newPosition = target.position + offset;        //transform.position = newPosition;        //transform.position = Vector3.Lerp(transform.position, newPosition, Time.deltaTime * followSpeed);        //Vector3 targetDirection = target.position - transform.position;        // 计算目标旋转角度，并将 y 分量设为 0        //Quaternion targetRotation = Quaternion.LookRotation(targetDirection, Vector3.up);        //targetRotation.eulerAngles = new Vector3(targetRotation.eulerAngles.x, 0f, 0f);        // 使用 Slerp 函数平滑地旋转摄像机        //transform.rotation = Quaternion.Slerp(transform.rotation, targetRotation, Time.deltaTime * rotationSpeed);        float mouseX = Input.GetAxis("Mouse X");        float mouseY = Input.GetAxis("Mouse Y");        // 计算旋转角度        float rotationAmountX = mouseX * rotateSpeed;        //float rotationAmountY = mouseY * rotateSpeed;        Vector3 rotation = new Vector3(0, rotationAmountX, 0);        // 围绕目标旋转摄像机        target.Rotate(rotation);    }}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总体来说是物体作为摄像机的父物体，但传入移动信号时，游戏物体找到摄像机的前后左右，控制方向的移动，而不是摄像机移动。当鼠标控制视角，是摄像机控制了父物体，也就是游戏物体的旋转，因为摄像机是子物体，所以会跟随进行旋转。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习中灰色模型学习</title>
      <link href="/2023/12/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%81%B0%E8%89%B2%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/12/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%81%B0%E8%89%B2%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="应用背景"><a href="#应用背景" class="headerlink" title="应用背景"></a>应用背景</h1><ol><li><strong>数据不足：</strong> 在实际问题中，很多时候我们面对的数据可能是有限的、不足的，尤其是对于一些新兴、不成熟的领域或者新产品的推测。传统的统计方法和机器学习方法通常对于数据量的要求较高，而在这些情况下，数据量可能不足以支持建立复杂的模型。</li><li><strong>不确定性：</strong> 一些系统的演化规律可能比较复杂，而且系统内部的因素相互影响，导致建模时存在较大的不确定性。灰色预测模型的设计目的就是在信息不完备和不确定性的情况下，提供一种相对简单但有效的预测手段。</li><li><strong>小样本问题：</strong> 在某些情况下，由于资源有限或者系统较为封闭，我们只能获得有限的样本数据。灰色预测模型的一些变体，尤其是GM(1,1)，在小样本问题上表现出一定的优势。</li></ol><h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><p>灰色预测模型的核心思想是将时间序列数据分为两个部分：已知部分和未知部分。已知部分包括具有完整信息的历史数据，而未知部分包括缺乏信息的未来数据。灰色预测模型的目标是通过已知部分推测未知部分。</p><p>这个方法采用灰色系统理论中的灰色关联度原理，即建立已知数据与未知数据之间的关联度，通过这种关联度进行预测。具体来说，常见的灰色预测模型有灰色一阶模型（GM(1,1)）。</p><p>简单来说，灰色预测模型的步骤包括：</p><ol><li><strong>建立灰色微分方程：</strong> 通过已知数据建立一个微分方程，描述系统的发展趋势。通常使用一阶微分方程。</li><li><strong>求解微分方程：</strong> 对微分方程进行求解，得到系统的发展规律。</li><li><strong>建立预测模型：</strong> 根据已知数据和求解的微分方程，建立一个预测模型。</li><li><strong>预测未来值：</strong> 利用建立的模型进行未来数值的预测。</li></ol><h1 id="检验方法"><a href="#检验方法" class="headerlink" title="检验方法"></a>检验方法</h1><p>检验灰色预测模型的精度通常包括以下步骤。在这里，我将以灰色一阶模型（GM(1,1)）为例进行说明：</p><ol><li><p><strong>残差检验：</strong> 计算预测值与实际观测值之间的残差。残差是模型对观测值的拟合误差。可以通过计算残差序列的平均值、方差等统计量来初步判断模型的拟合情况。</p></li><li><p><strong>相对误差检验：</strong> 计算相对误差，即每个预测值与实际观测值之间的相对误差。相对误差的计算公式为：</p><p>相对误差=∣实际观测值−预测值∣实际观测值×100%相对误差=实际观测值∣实际观测值−预测值∣×100%</p><p>通过比较相对误差的大小，可以评估模型的预测精度。</p></li><li><p><strong>均方根误差（Root Mean Square Error，RMSE）：</strong> RMSE 是衡量预测误差的一种常用指标。计算方法为：</p><p><img src="/../images/image-20231201112520040.png" alt="image-20231201112520040"></p><p>RMSE 越小，表示模型的拟合效果越好。</p></li><li><p><strong>平均相对误差（Mean Absolute Percentage Error，MAPE）：</strong> MAPE 是另一种常用的评估预测精度的指标。计算方法为：</p><p><img src="/../images/image-20231201112534367.png" alt="image-20231201112534367"></p><p>MAPE 也用于衡量模型的相对精度，值越小表示模型的预测效果越好。</p></li><li><p><strong>统计检验：</strong> 可以使用一些统计检验方法，如 t 检验，来检验模型的残差是否显著不等于零。如果残差不显著不等于零，则说明模型的拟合可能较好。</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MATLABQ艮课堂任务之两张给定的图像数据规定化</title>
      <link href="/2023/12/01/MATLABQ%E8%89%AE%E8%AF%BE%E5%A0%82%E4%BB%BB%E5%8A%A1%E4%B9%8B%E4%B8%A4%E5%BC%A0%E7%BB%99%E5%AE%9A%E7%9A%84%E5%9B%BE%E5%83%8F%E6%95%B0%E6%8D%AE%E8%A7%84%E5%AE%9A%E5%8C%96/"/>
      <url>/2023/12/01/MATLABQ%E8%89%AE%E8%AF%BE%E5%A0%82%E4%BB%BB%E5%8A%A1%E4%B9%8B%E4%B8%A4%E5%BC%A0%E7%BB%99%E5%AE%9A%E7%9A%84%E5%9B%BE%E5%83%8F%E6%95%B0%E6%8D%AE%E8%A7%84%E5%AE%9A%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="任务描述"><a href="#任务描述" class="headerlink" title="任务描述"></a>任务描述</h1><p>天气很冷，Q艮又是作为最后一节课，没想到是布置了上课的作业（其实是课上交给他的话会有一扣扣的加分啊）。任务呢，是给定了图像像素的分布，为了简化，只有八像素的灰度。将原本图像，按照给定的分布，重新排布，称之为规定化。</p><p><img src="/../images/image-20231201102436343.png" alt="image-20231201102436343"><img src="/../images/image-20231201102442272.png" alt="image-20231201102442272"><img src="/../images/image-20231201102452193.png" alt="image-20231201102452193"><img src="/../images/image-20231201102459198.png" alt="image-20231201102459198"><img src="/../images/image-20231201102516264.png" alt="image-20231201102516264"></p><p>代码如下：</p><pre><code class="matlab">% 给定数组 A、B 和 CA = [790, 1023, 850, 656, 329, 245, 122, 81];B = [0, 1, 2, 3, 4, 5, 6, 7];C = [0, 0, 0, 15, 20, 30, 20, 15];% 初始化结果数组result = zeros(1, 8);resultadd = zeros(1, 8);% 计算数组 A 和 C 的累积和A_sum = cumsum(A);A_p = A / max(A_sum); % 对 A 进行归一化C_sum = cumsum(C);% 对 A_sum 和 C_sum 进行归一化A_normalized = A_sum / max(A_sum);C_normalized = C_sum / max(C_sum);% 显示归一化后的数组disp('A 经过归一化');disp(A_normalized);disp('C 经过归一化');disp(C_normalized);% 循环遍历归一化后的 A，并在归一化后的 C 中找到最接近的值for i = 1:length(A_normalized)    targetNumber = A_normalized(i);    [closestValue, index] = min(abs(C_normalized - targetNumber));    result(i) = index;end% 显示归一化后 A 与 C 之间的相似性结果disp('归一化后的相似性结果');disp(result);% 计算并显示添加近似值后的概率结果for i = 1:length(result)    resultadd(result(i)) = A_p(i) + resultadd(result(i));end% 显示最终的概率结果disp('添加所有近似值后的概率和');disp(resultadd);% 绘制归一化分布的条形图bar(resultadd);title('数值分布的归一化');xlabel('像素值');ylabel('概率');</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> MATLAB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>路由器RIP协议实验</title>
      <link href="/2023/11/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%B7%AF%E7%94%B1%E5%99%A8RIP%E5%8D%8F%E8%AE%AE%E5%AE%9E%E9%AA%8C/"/>
      <url>/2023/11/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%B7%AF%E7%94%B1%E5%99%A8RIP%E5%8D%8F%E8%AE%AE%E5%AE%9E%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<p>实验九、路由信息协议（RIP）实验</p><p>请大家画出如图所示拓扑图（与上次实验一样，这次采用动态路由协议进行配置）</p><p><img src="/../images/clip_image002-1701162382756-3.jpg" alt="img"></p><table><thead><tr><th>名称</th><th>接口</th><th>IP地址</th><th>网关</th></tr></thead><tbody><tr><td>Router1</td><td>F0/0</td><td>192.168.1.1/24</td><td></td></tr><tr><td>F0/1</td><td>172.1.1.1/24</td><td></td><td></td></tr><tr><td>Router2</td><td>F0/0</td><td>172.2.2.1/24</td><td></td></tr><tr><td>F0/1</td><td>192.168.1.2/24</td><td></td><td></td></tr><tr><td>PC1</td><td></td><td>172.1.1.2/24</td><td>172.1.1.1</td></tr><tr><td>PC2</td><td></td><td>172.1.1.3/24</td><td>172.1.1.1</td></tr><tr><td>PC3</td><td></td><td>172.2.2.2/24</td><td>172.2.2.1</td></tr><tr><td>PC4</td><td></td><td>172.2.2.3/24</td><td>172.2.2.1</td></tr></tbody></table><pre><code class="bash">Router1：基本配置如下： Router(config)#router ripRouter(config-router)#version 2Router(config-router)#no auto-summary //这句话的意思是禁止路由器自动汇总网段的子网掩码,自作聪明的判断网段归属于哪一类地址自动添加子网掩码.只有version2版本才能输入此命令,v1版本没有此功能.大家可以试一下,不加这句话,会自动识别成172.1.0.0,思考为什么 Router(config-router)#network 172.1.1.0Router(config-router)#network 192.168.1.0</code></pre><pre><code class="bash">Router2Router(config)#router ripRouter(config-router)#version 2Router(config-router)#no auto-summary  Router(config-router)#network 172.2.2.0Router(config-router)#network 192.168.1.0</code></pre><p>上面这两步也可以在图形界面配置，配置完成后分别在两个路由器上查看路由表：</p><p>Router1上显示信息如下：</p><pre><code class="bash">Router#show ip routeCodes: C - connected, S - static, I - IGRP, R - RIP, M - mobile, B - BGP​    D - EIGRP, EX - EIGRP external, O - OSPF, IA - OSPF inter area​    N1 - OSPF NSSA external type 1, N2 - OSPF NSSA external type 2​    E1 - OSPF external type 1, E2 - OSPF external type 2, E - EGP​    i - IS-IS, L1 - IS-IS level-1, L2 - IS-IS level-2, ia - IS-IS inter area​    \* - candidate default, U - per-user static route, o - ODR​    P - periodic downloaded static route Gateway of last resort is not set    172.1.0.0/24 is subnetted, 1 subnetsC    172.1.1.0 is directly connected, FastEthernet0/1   172.2.0.0/24 is subnetted, 1 subnetsR    172.2.2.0 [120/1] via 192.168.1.2, 00:00:13, FastEthernet0/0 //R代表通过RIP协议学习到的路由条目管理距离值为120,而静态路由条目的管理距离值为1,如果一个网段同时手工配置了静态路由又自动通过RIP 学到了路由条目,会优先选择网段的静态路由.后面的数字是跳数( 度量值),注意，思科路由器的距离定义和书上的不一致，按书上的定义，这个距离应该是2C  192.168.1.0/24 is directly connected, FastEthernet0/0 注意,如果不在version2下加入no auto-summary,则显示结果是下面这样的: 172.1.0.0/24 is subnetted, 1 subnetsC  172.1.1.0 is directly connected, FastEthernet0/1R  172.2.0.0/16 [120/1] via 192.168.1.2, 00:00:10, FastEthernet0/0C  192.168.1.0/24 is directly connected, FastEthernet0/0</code></pre><pre><code class="bash">这是Router2上的信息 172.1.0.0/24 is subnetted, 1 subnetsR    172.1.1.0 [120/1] via 192.168.1.1, 00:00:10, FastEthernet0/1   172.2.0.0/24 is subnetted, 1 subnetsC    172.2.2.0 is directly connected, FastEthernet0/0C  192.168.1.0/24 is directly connected, FastEthernet0/1</code></pre><p>测试一下四个PC是否都能互相ping通。</p><p>思考并回答这个实验和上次的静态路由配置有何不同。</p><p> ==这次使用端口的ip，通过rip协议，生成自己的学习路径，自动获取通信==</p><ul><li><strong>静态路由配置</strong>是手动配置的，管理员需要明确指定网络和下一跳路由器的信息。这种方式适用于小型网络或者需要精确控制路由流量的情况，适用于相对稳定的网络环境，其中网络拓扑变化不频繁。</li><li><strong>RIP协议</strong>是一种动态路由协议，它允许路由器之间交换路由信息，并根据网络拓扑和跳数等信息动态更新路由表。这种方式适用于较大规模的网络，可以自动适应网络拓扑的变化，适用于需要自适应网络拓扑变化的环境，可以更快地适应网络变化。</li></ul><p><strong>请大家截屏记录实验结果，提交报告实验9。</strong></p><p><img src="/../images/clip_image004-1701162382756-2.jpg" alt="img"></p><p><img src="/../images/clip_image006-1701162382755-1.jpg" alt="img"></p><p><img src="/../images/clip_image008-1701162382756-4.jpg" alt="img"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于android的一个语录开发过程记录</title>
      <link href="/2023/11/25/%E5%9F%BA%E4%BA%8Eandroid%E7%9A%84%E4%B8%80%E4%B8%AA%E8%AF%AD%E5%BD%95%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/"/>
      <url>/2023/11/25/%E5%9F%BA%E4%BA%8Eandroid%E7%9A%84%E4%B8%80%E4%B8%AA%E8%AF%AD%E5%BD%95%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="开发开始"><a href="#开发开始" class="headerlink" title="开发开始"></a>开发开始</h1><p>很早之前参与编写了一篇语录，大概有3W字，正好学习了android开发的一些相关知识，能否通过这个机会开发出一个app展示语录，就类似阅读器这种的。</p><h1 id="尝试写第一个页面"><a href="#尝试写第一个页面" class="headerlink" title="尝试写第一个页面"></a>尝试写第一个页面</h1><h2 id="刘"><a href="#刘" class="headerlink" title="刘"></a>刘</h2><p>这一部分是关于将的介绍，那么肯定是从宇轩开始。</p><pre><code class="xml">&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"    xmlns:app="http://schemas.android.com/apk/res-auto"    xmlns:tools="http://schemas.android.com/tools"    android:layout_width="match_parent"    android:layout_height="match_parent"    tools:context=".family.FamilyLiuYuxuan"&gt;    &lt;ImageButton        android:id="@+id/FamilyLiuYuxuanSettingButton"        android:layout_width="40sp"        android:layout_height="40sp"        android:layout_alignParentTop="true"        android:layout_alignParentRight="true"        android:layout_marginTop="20sp"        android:src="@mipmap/ic_launcher"&gt;    &lt;/ImageButton&gt;    &lt;ScrollView        android:id="@+id/ScrollView"        android:layout_width="match_parent"        android:layout_height="550sp"        android:layout_below="@id/FamilyLiuYuxuanSettingButton"&gt;        &lt;TextView            android:id="@+id/FamilyLiuYuxuanText"            android:layout_width="wrap_content"            android:layout_height="match_parent"            android:layout_marginLeft="40dp"            android:layout_marginTop="0dp"            android:layout_marginRight="40dp"            android:text="\t\t\t\t刘宇轩(大将)女,一般称宇轩,别名SHEEN,YUEAI,妞鬼,八怪,小轩轩,刘头,宇呕,宇X(X读作lāi),夫妻,大球,(在宇呕荣耀中)大龙,李蓉泉称其为井盖脸,跟她勾肩搭背的女生称其为混世女魔头,有,圆,有和圆合称原油(由一帆创始),还有某些女生称其为老大。            \n\t\t\t\t英文名LIGHT SHEEN(简称LS),来自一班。是戏曲里的彩旦,因为彩旦专演丑角。具有纯正的宇轩血统,是唯一的光系宇轩。长相奇丑无比,也不知道是什么原因。具有满脸痘和超亮大奔头。长相很奇特而且较黑,正面看根本看不见头发,一低头就可以看见她的发际线离眉毛很远,于是奔头就很大,而且侧面的头发也濒临消失,但她在合影的时候永远站在第一个,真够惊悚的。            \n\t\t\t\t宇轩奔遇阳光可反射光芒,储存光芒,放光芒。但长相都是次要的,最关键她道德品质极其败坏,允许她说别人但不允许别人说她,不愧是相由心生。坐在别人椅子上,嫌人家书包硌得慌,就直接把人家的书包扔在地上。对鸡毛蒜皮不值得一提的小事斤斤计较个没完没了。初三上半学期的最后,老师发糖,宇呕就用臭爪子把糖抓来抓去,乱挑,真是恶心到家了。            \n\t\t\t\t为了寻求保护和宠爱,经常拍老师马屁,当老师一面,背着老师一面。脾气暴,嗓门大,极其张扬。令人胆怯,闻其声而知其名,闻风丧胆,一眼都不能看,因为看完就会失明。挑拨离间女生间关系,还掐女生脖子,使得全班人都排斥她。贪污退回的饭费,一向一毛不拔的宇来还拿赃款请女生吃东西。\n\t\t\t\t著有名言:(宇轩怒之千古绝唱)“给我道歉。”"            &gt;&lt;/TextView&gt;    &lt;/ScrollView&gt;    &lt;Button        android:id="@+id/FamilyLiuYuxuanButton"        android:layout_width="wrap_content"        android:layout_height="wrap_content"        android:layout_below="@id/ScrollView"        android:layout_centerHorizontal="true"        android:text="返回"        android:textSize="20sp" /&gt;&lt;/RelativeLayout&gt;</code></pre><pre><code class="java">package com.example.yuouquotation.family;import androidx.appcompat.app.AppCompatActivity;import android.annotation.SuppressLint;import android.content.Intent;import android.content.SharedPreferences;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.ImageButton;import android.widget.TextView;import com.example.yuouquotation.R;public class FamilyLiuYuxuan extends AppCompatActivity {    private static final int REQUEST_CODE_SETTINGS = 1;    private Button familyLiuYuxuanButton;    private int textSize;    private ImageButton familyLiuYuxuanSettingButton;    private TextView familyLiuYuxuanText;        @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_family_liu_yuxuan);        familyLiuYuxuanButton = findViewById(R.id.FamilyLiuYuxuanButton);        familyLiuYuxuanSettingButton = findViewById(R.id.FamilyLiuYuxuanSettingButton);        familyLiuYuxuanText = findViewById(R.id.FamilyLiuYuxuanText);        SharedPreferences sharedPreferences = getSharedPreferences("app_settings", MODE_PRIVATE);        SharedPreferences.Editor editor = sharedPreferences.edit();        textSize = sharedPreferences.getInt("textSize", 20);        familyLiuYuxuanText.setTextSize(textSize);        //返回按钮        familyLiuYuxuanButton.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View view) {                finish();            }        });        //设置按钮        familyLiuYuxuanSettingButton.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View view) {                Intent intent = new Intent(FamilyLiuYuxuan.this, FamilySettings.class);                startActivityForResult(intent, REQUEST_CODE_SETTINGS);            }        });    }    @Override    protected void onActivityResult(int requestCode , int resultCode, Intent data) {        super.onActivityResult(requestCode, resultCode, data);        if (requestCode == REQUEST_CODE_SETTINGS &amp;&amp; resultCode == RESULT_OK) {            Bundle parameters = data.getExtras();            // 使用返回的参数更新初始界面的状态            textSize = parameters.getInt("textSize");            familyLiuYuxuanText.setTextSize(textSize);        }    }}</code></pre><p>调整了布局以及按钮的逻辑，同理制作出张，伪，中将和小将的信息。</p><h2 id="张"><a href="#张" class="headerlink" title="张"></a>张</h2><pre><code class="xml">&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;ScrollView xmlns:android="http://schemas.android.com/apk/res/android"    xmlns:app="http://schemas.android.com/apk/res-auto"    xmlns:tools="http://schemas.android.com/tools"    android:layout_width="match_parent"    android:layout_height="match_parent"    tools:context=".family.FamilyLiuYuxuan"&gt;    &lt;RelativeLayout        android:layout_width="match_parent"        android:layout_height="wrap_content"&gt;        &lt;ImageButton            android:id="@+id/FamilyZhangYuxuanSettingButton"            android:layout_width="40sp"            android:layout_height="40sp"            android:layout_alignParentTop="true"            android:layout_alignParentRight="true"            android:layout_marginTop="20sp"            android:src="@mipmap/ic_launcher"/&gt;        &lt;TextView            android:id="@+id/FamilyZhangYuxuanText"            android:layout_width="wrap_content"            android:layout_height="wrap_content"            android:text="\t\t\t\t张雨轩(大将)男,一般称雨轩,别名老张头,英文名BLACK SHEEN(简称BS),来自五班。\n\t\t\t\t长相比黑人还黑,屁多,屁话更多,口齿不清,满身痘痘,1厘米的屌呈尖型,长相不佳但喜欢贴近别人。看起来脸上不发光,其实张头发紫外线,会吸收(吸收紫外线用来把自己变得更黑),储存,放紫外线。\n\t\t\t\t不知羞耻 ,自称对刘时骏和赵健程有爱意。整天就挠他自己脸上的痘,长满泥的指甲长得能挠破皮。爱瞎bb,还学别人说话。从初三开始就不来了,他其实还是挺可怜的。\n\t\t\t\t著有名言:“啊哈哈。”“滚犊子。”“健程。”“小健健。“ “小京楠。”“屙,好诡异!”“若熙奶奶。”“不能那么残忍!”“别闹!”“(扶着痘说)完,完,完,完,完!”"            android:layout_marginLeft="40dp"            android:layout_marginRight="40dp"            android:layout_marginTop="20dp"            &gt;&lt;/TextView&gt;        &lt;Button            android:id="@+id/FamilyZhangYuxuanButton"            android:layout_width="wrap_content"            android:layout_height="wrap_content"            android:text="返回"            android:textSize="20sp"            android:layout_below="@id/FamilyZhangYuxuanText"            android:layout_centerHorizontal="true"/&gt;    &lt;/RelativeLayout&gt;&lt;/ScrollView&gt;</code></pre><pre><code class="java">package com.example.yuouquotation.family;import androidx.annotation.Nullable;import androidx.appcompat.app.AppCompatActivity;import android.content.Intent;import android.content.SharedPreferences;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.ImageButton;import android.widget.TextView;import com.example.yuouquotation.R;public class FamilyZhangYuxuan extends AppCompatActivity {    private Button familyZhangYuxuanButton;    private TextView familyZhangYuxuanText;    private int textSize;    SharedPreferences sharedPreferences;    SharedPreferences.Editor editor;    ImageButton familyZhangYuxuanSettingButton;    private int REQUEST_CODE = 1;    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_family_zhang_yuxuan);        familyZhangYuxuanButton = findViewById(R.id.FamilyZhangYuxuanButton);        familyZhangYuxuanText = findViewById(R.id.FamilyZhangYuxuanText);        familyZhangYuxuanSettingButton = findViewById(R.id.FamilyZhangYuxuanSettingButton);        sharedPreferences = getSharedPreferences("app_settings", MODE_PRIVATE);        editor = sharedPreferences.edit();        textSize = sharedPreferences.getInt("textSize", 20);        familyZhangYuxuanText.setTextSize(textSize);        familyZhangYuxuanButton.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View view) {                finish();            }        });        familyZhangYuxuanSettingButton.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View view) {                Intent intent = new Intent(FamilyZhangYuxuan.this, FamilySettings.class);                startActivityForResult(intent, REQUEST_CODE);            }        });    }    @Override    protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) {        super.onActivityResult(requestCode, resultCode, data);        if (requestCode == REQUEST_CODE &amp;&amp; resultCode == RESULT_OK) {            textSize = sharedPreferences.getInt("textSize", 20);            familyZhangYuxuanText.setTextSize(textSize);        }    }}</code></pre><h2 id="伪"><a href="#伪" class="headerlink" title="伪"></a>伪</h2><pre><code class="xml">&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;ScrollView xmlns:android="http://schemas.android.com/apk/res/android"    xmlns:app="http://schemas.android.com/apk/res-auto"    xmlns:tools="http://schemas.android.com/tools"    android:layout_width="match_parent"    android:layout_height="match_parent"    tools:context=".family.FamilyLiuYuxuan"&gt;    &lt;RelativeLayout        android:layout_width="match_parent"        android:layout_height="wrap_content"&gt;        &lt;ImageButton            android:id="@+id/FamilyWeiYuxuanSettingButton"            android:layout_width="40sp"            android:layout_height="40sp"            android:layout_alignParentTop="true"            android:layout_alignParentRight="true"            android:layout_marginTop="20sp"            android:src="@mipmap/ic_launcher"/&gt;        &lt;TextView            android:id="@+id/FamilyWeiYuxuanText"            android:layout_width="wrap_content"            android:layout_height="wrap_content"            android:layout_marginLeft="40dp"            android:layout_marginTop="20dp"            android:layout_marginRight="40dp"            android:text="\t\t\t\t伪宇轩(大将)女,真名刘思多,别名伪头,英文名FALSE SHEEN(简称FS),来自四班。长相剧黑无比。\n\t\t\t\t源于菊花村,远看神似张雨轩,近看半似刘宇轩,痘虽少,但也挺丑的。学习好,一帆致词:自古英雄出宇轩。(伪宇轩夫:四班口齿不清、智商低下的儿童贺铂中。思多哥:刘思宇)"&gt;&lt;/TextView&gt;        &lt;Button            android:id="@+id/FamilyWeiYuxuanButton"            android:layout_width="wrap_content"            android:layout_height="wrap_content"            android:layout_below="@id/FamilyWeiYuxuanText"            android:layout_centerHorizontal="true"            android:text="返回"            android:textSize="20sp" /&gt;    &lt;/RelativeLayout&gt;&lt;/ScrollView&gt;</code></pre><pre><code class="java">package com.example.yuouquotation.family;import androidx.appcompat.app.AppCompatActivity;import android.content.Intent;import android.content.SharedPreferences;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.ImageButton;import android.widget.TextView;import com.example.yuouquotation.R;public class FamilyWeiYuxuan extends AppCompatActivity {    private Button familyWeiYuxuanButton;    private TextView familyWeiYuxuanText;    private int textSize;    private ImageButton familyWeiYuxuanSettingButton;    SharedPreferences sharedPreferences;    SharedPreferences.Editor editor;    private int REQUEST_CODE = 1;    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_family_wei_yuxuan);        sharedPreferences = getSharedPreferences("app_settings", MODE_PRIVATE);        editor = sharedPreferences.edit();        textSize = sharedPreferences.getInt("textSize", 20);        familyWeiYuxuanButton = findViewById(R.id.FamilyWeiYuxuanButton);        familyWeiYuxuanText = findViewById(R.id.FamilyWeiYuxuanText);        familyWeiYuxuanSettingButton = findViewById(R.id.FamilyWeiYuxuanSettingButton);        familyWeiYuxuanText.setTextSize(textSize);        familyWeiYuxuanButton.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View view) {                finish();            }        });        familyWeiYuxuanSettingButton.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View view) {                Intent intent = new Intent(FamilyWeiYuxuan.this, FamilySettings.class);                startActivityForResult(intent, REQUEST_CODE);            }        });    }    @Override    protected void onActivityResult(int requestCode, int resultCode, Intent data) {        super.onActivityResult(requestCode, resultCode, data);        if (requestCode == REQUEST_CODE &amp;&amp; resultCode == RESULT_OK) {            textSize = sharedPreferences.getInt("textSize", 20);            familyWeiYuxuanText.setTextSize(textSize);        }    }}</code></pre><h2 id="中将"><a href="#中将" class="headerlink" title="中将"></a>中将</h2><pre><code class="xml">&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;ScrollView xmlns:android="http://schemas.android.com/apk/res/android"    xmlns:app="http://schemas.android.com/apk/res-auto"    xmlns:tools="http://schemas.android.com/tools"    android:layout_width="match_parent"    android:layout_height="match_parent"    tools:context=".family.FamilyLiuYuxuan"&gt;    &lt;RelativeLayout        android:layout_width="match_parent"        android:layout_height="wrap_content"&gt;        &lt;ImageButton            android:id="@+id/FamilyZhongjiangSettingButton"            android:layout_width="40sp"            android:layout_height="40sp"            android:layout_alignParentTop="true"            android:layout_alignParentRight="true"            android:layout_marginTop="20sp"            android:src="@mipmap/ic_launcher"/&gt;        &lt;TextView            android:id="@+id/FamilyZhongjiangText"            android:layout_width="wrap_content"            android:layout_height="wrap_content"            android:text="\t\t\t\t二伪宇轩(中将)\n\t\t\t\t女,真名张静宇,英文名2 FALSE SHEEN(简称2FS)来自二班。"            android:layout_marginLeft="40dp"            android:layout_marginRight="40dp"            android:layout_marginTop="20dp"            android:textSize="20sp"            &gt;&lt;/TextView&gt;        &lt;TextView            android:id="@+id/FamilyZhongjiangText2"            android:layout_width="wrap_content"            android:layout_height="wrap_content"            android:text="\t\t\t\t伪二伪宇轩(中将)\n\t\t\t\t女,真名朱祎文,英文名3 FALSE SHEEN(简称3FS),来自六班。"            android:layout_marginLeft="40dp"            android:layout_marginRight="40dp"            android:layout_marginTop="20dp"            android:layout_below="@id/FamilyZhongjiangText"            android:textSize="20sp"            &gt;&lt;/TextView&gt;        &lt;TextView            android:id="@+id/FamilyZhongjiangText3"            android:layout_width="wrap_content"            android:layout_height="wrap_content"            android:text="\t\t\t\t伪张雨轩(中将)男,真名薛斌,别名伪张。\n\t\t\t\t英文名FALSE BLACK SHEEN(简称FBS)。来自比第一大将刘宇轩低一届的一班。经典动作有:上齿咬下唇,挠头。与张雨轩极其相似:长相丑无奔头,脸色不黑,痘多却比张雨轩少,不愧是老张的化身。"            android:layout_marginLeft="40dp"            android:layout_marginRight="40dp"            android:layout_marginTop="20dp"            android:layout_below="@id/FamilyZhongjiangText2"            android:textSize="20sp"            &gt;&lt;/TextView&gt;        &lt;Button            android:id="@+id/FamilyZhongjiangButton"            android:layout_width="wrap_content"            android:layout_height="wrap_content"            android:text="返回"            android:textSize="20sp"            android:layout_below="@id/FamilyZhongjiangText3"            android:layout_centerHorizontal="true"/&gt;    &lt;/RelativeLayout&gt;&lt;/ScrollView&gt;</code></pre><pre><code class="java">package com.example.yuouquotation.family;import androidx.annotation.Nullable;import androidx.appcompat.app.AppCompatActivity;import android.content.Intent;import android.content.SharedPreferences;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.ImageButton;import android.widget.TextView;import com.example.yuouquotation.R;public class FamilyZhongjiang extends AppCompatActivity {    private Button familyZhongjiangButton;    private TextView familyZhongjiangText;    private TextView familyZhongjiangText2;    private TextView familyZhongjiangText3;    private int textSize;    private ImageButton familyZhongjiangSettingButton;    SharedPreferences sharedPreferences;    SharedPreferences.Editor editor;    private int REQUEST_CODE = 1;    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_family_zhongjiang);        familyZhongjiangButton = findViewById(R.id.FamilyZhongjiangButton);        familyZhongjiangText = findViewById(R.id.FamilyZhongjiangText);        familyZhongjiangText2 = findViewById(R.id.FamilyZhongjiangText2);        familyZhongjiangText3 = findViewById(R.id.FamilyZhongjiangText3);        familyZhongjiangSettingButton = findViewById(R.id.FamilyZhongjiangSettingButton);        sharedPreferences = getSharedPreferences("app_settings", MODE_PRIVATE);        editor = sharedPreferences.edit();        textSize = sharedPreferences.getInt("textSize", 20);        familyZhongjiangText.setTextSize(textSize);        familyZhongjiangText2.setTextSize(textSize);        familyZhongjiangText3.setTextSize(textSize);        familyZhongjiangButton.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View view) {                finish();            }        });        familyZhongjiangSettingButton.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View view) {                Intent intent = new Intent(FamilyZhongjiang.this, FamilySettings.class);                startActivityForResult(intent, REQUEST_CODE);            }        });    }    @Override    protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) {        super.onActivityResult(requestCode, resultCode, data);        if(REQUEST_CODE == requestCode &amp;&amp; resultCode == RESULT_OK){            textSize = sharedPreferences.getInt("textSize", 20);            familyZhongjiangText.setTextSize(textSize);            familyZhongjiangText2.setTextSize(textSize);            familyZhongjiangText3.setTextSize(textSize);        }    }}</code></pre><h2 id="小将"><a href="#小将" class="headerlink" title="小将"></a>小将</h2><pre><code class="xml">&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;ScrollView xmlns:android="http://schemas.android.com/apk/res/android"    xmlns:app="http://schemas.android.com/apk/res-auto"    xmlns:tools="http://schemas.android.com/tools"    android:layout_width="match_parent"    android:layout_height="match_parent"    tools:context=".family.FamilyLiuYuxuan"&gt;    &lt;RelativeLayout        android:layout_width="match_parent"        android:layout_height="wrap_content"&gt;        &lt;ImageButton            android:id="@+id/FamilyXiaojiangSettingButton"            android:layout_width="40sp"            android:layout_height="40sp"            android:layout_alignParentTop="true"            android:layout_alignParentRight="true"            android:layout_marginTop="20sp"            android:src="@mipmap/ic_launcher"/&gt;        &lt;TextView            android:id="@+id/FamilyXiaojiangText"            android:layout_width="wrap_content"            android:layout_height="wrap_content"            android:text="\t\t\t\t侯宇轩(小将)\n\t\t\t\t男,英文名MONKEY SHEEN(简称MS),来自四班。无奔头,无痘,但高颧骨,长相似骷髅。是宇轩家族的一代炮灰。\n\t\t\t\t出场率极少,在宇轩界中不受重视。"            android:layout_marginLeft="40dp"            android:layout_marginRight="40dp"            android:layout_marginTop="20dp"            android:textSize="20sp"            &gt;&lt;/TextView&gt;        &lt;Button            android:id="@+id/FamilyXiaojiangButton"            android:layout_width="wrap_content"            android:layout_height="wrap_content"            android:text="返回"            android:textSize="20sp"            android:layout_below="@id/FamilyXiaojiangText"            android:layout_centerHorizontal="true"/&gt;    &lt;/RelativeLayout&gt;&lt;/ScrollView&gt;</code></pre><pre><code class="java">package com.example.yuouquotation.family;import androidx.appcompat.app.AppCompatActivity;import android.content.Intent;import android.content.SharedPreferences;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.ImageButton;import android.widget.TextView;import com.example.yuouquotation.R;public class FamilyXiaojiang extends AppCompatActivity {    private Button familyXiaojiangButton;    private TextView familyXiaojiangText;    private int textSize;    private SharedPreferences sharedPreferences;    private SharedPreferences.Editor editor;    private ImageButton familyXiaojiangSettingButton;    private int REQUEST_CODE = 1;    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_family_xiaojiang);        familyXiaojiangButton = findViewById(R.id.FamilyXiaojiangButton);        familyXiaojiangText = findViewById(R.id.FamilyXiaojiangText);        familyXiaojiangSettingButton = findViewById(R.id.FamilyXiaojiangSettingButton);        sharedPreferences = getSharedPreferences("app_settings", MODE_PRIVATE);        editor = sharedPreferences.edit();        textSize = sharedPreferences.getInt("textSize", 20);        familyXiaojiangText.setTextSize(textSize);        familyXiaojiangButton.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View view) {                finish();            }        });        familyXiaojiangSettingButton.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View view) {                Intent intent = new Intent(FamilyXiaojiang.this, FamilySettings.class);                startActivityForResult(intent, REQUEST_CODE);            }        });    }    @Override    protected void onActivityResult(int requestCode, int resultCode, Intent data) {        super.onActivityResult(requestCode, resultCode, data);        if (requestCode == REQUEST_CODE &amp;&amp; resultCode == RESULT_OK) {            textSize = sharedPreferences.getInt("textSize", 20);            familyXiaojiangText.setTextSize(textSize);        }    }}</code></pre><h2 id="关于其中的信息传递逻辑实现"><a href="#关于其中的信息传递逻辑实现" class="headerlink" title="关于其中的信息传递逻辑实现"></a>关于其中的信息传递逻辑实现</h2><p>本来使用的是相应的每一个界面都有一个Setting按钮，对于文字颜色进行调整，而后发现比如A界面更改了信息，B界面还要经历一次修改过程，每一步都要用Bundle来完成么？显然繁琐，于是找到了sharedPreferences的方式，类似共享内存，不过建议是存储一些简单的信息。</p><h1 id="完成夫的相应逻辑"><a href="#完成夫的相应逻辑" class="headerlink" title="完成夫的相应逻辑"></a>完成夫的相应逻辑</h1><h2 id="思考能否进一步精简"><a href="#思考能否进一步精简" class="headerlink" title="思考能否进一步精简"></a>思考能否进一步精简</h2><p>因为之前每一次都是要定义类似的控件，能否创建一个类，使得其new一个实例，再往里赋值就可以了。在实现的过程中，发现可以直接采用继承的方式，甚至不需要使用new一个实例。</p><p>不过在获取对象时遇到了空指针的问题如下</p><h2 id="sharedPreferences-null-pointer"><a href="#sharedPreferences-null-pointer" class="headerlink" title="sharedPreferences null pointer?"></a>sharedPreferences null pointer?</h2><p>我最初是在那个基类中获取的所有的Button，View等控件，会出现android：Initializing SharedPreferences提供：尝试在空对象引用上调用虚拟方法的问题。而后下午更改至OnCreate方法中竟然就不再报错，那么暂时不想深究，继续其他的开发。</p><p>当解决这个问题后发现采用相应的类进行开发，编写速度会有很大的提升，因为此时对于一个新的类，仅仅在获取控件的时候采用不同的id即可，而无需创建新的不同命名的控件。</p><p>于是创建了相应夫的xml与java文件进行交互。</p><h2 id="模板类"><a href="#模板类" class="headerlink" title="模板类"></a>模板类</h2><pre><code class="java">package com.example.yuouquotation.fu;import android.content.SharedPreferences;import android.widget.Button;import android.widget.ImageButton;import android.widget.TextView;import androidx.appcompat.app.AppCompatActivity;public class FuView extends AppCompatActivity {    //布局文件    private android.view.View fuActivity;    //文字大小    private int textSize;    //设置请求    public static final int REQUEST_CODE = 1;    //返回按钮    private Button fuButton;    //介绍文字    private TextView fuText;    //设置按钮    private ImageButton fuSettingButton;    public SharedPreferences sharedPreferences;    public SharedPreferences.Editor editor;    public TextView getFuText() {        return fuText;    }    public void setFuText(int fuText) {        this.fuText = findViewById(fuText);    }    public ImageButton getFuSettingButton() {        return fuSettingButton;    }    public void setFuSettingButton(int fuSettingButton) {        this.fuSettingButton = findViewById(fuSettingButton);    }    public int getTextSize() {        return textSize;    }    public void setTextSize(int textSize) {        this.textSize = textSize;    }    public Button getFuButton() {        return fuButton;    }    public void setFuButton(int fuButton) {        this.fuButton = findViewById(fuButton);    }    public FuView() {        super();        //sharedPreferences = getSharedPreferences("app_settings", MODE_PRIVATE);        //editor = sharedPreferences.edit();    }    public android.view.View getFuActivity() {        return fuActivity;    }    public void setFuActivity(int fuActivity) {        this.fuActivity = findViewById(fuActivity);    }}</code></pre><h1 id="建立第一章-家族介绍"><a href="#建立第一章-家族介绍" class="headerlink" title="建立第一章 家族介绍"></a>建立第一章 家族介绍</h1><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>包含两大家族宇轩和夫，同样是通过Intent进行交互，不过为他们设置了不同的图标，在drawable文件夹下放置了需要使用的图片，使用的时候将其通过id引用。</p>]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022ICPC济南部分题解</title>
      <link href="/2023/11/25/2022ICPC%E6%B5%8E%E5%8D%97%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/"/>
      <url>/2023/11/25/2022ICPC%E6%B5%8E%E5%8D%97%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="Tower"><a href="#Tower" class="headerlink" title="Tower"></a>Tower</h1><p><a href="https://www.luogu.com.cn/problem/list?keyword=icpc2022jinan&amp;type=AT%7CB%7CCF%7CP%7CSP%7CUVA&amp;page=1">https://www.luogu.com.cn/problem/list?keyword=icpc2022jinan&amp;type=AT%7CB%7CCF%7CP%7CSP%7CUVA&amp;page=1</a></p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define endl "\n"#define int long longusing namespace std;const int N = 5005;int n,m;int a[N],ans[N],cha[N];int T;void solve(){    cin&gt;&gt;n&gt;&gt;m;    int geshu=0;    for(int i=1;i&lt;=n;i++){        cin&gt;&gt;a[i];        int x=a[i];        while(x){            ans[++geshu]=x;//记录最终答案可能的值            x/=2;        }    }    int minn=1e17;    for(int i=1;i&lt;=geshu;i++){//枚举所有最终答案        int x=ans[i];        int cnt=0;        for(int j=1;j&lt;=n;j++){            cha[j]=1e10;            if(a[j]&lt;x)cha[j]=x-a[j];//小于最终答案的值只能通过+1来操作            else if(a[j]==x){                cha[j]=0;                continue;            }            else {//大于最终答案的值先不断/2再加减                int num=a[j],shu=0;                while(num&gt;x){                    if(num&gt;x&amp;&amp;(num/2)&lt;=x){                        cha[j]=min(shu+num-x,shu+1+(x-num/2));                        break;                    }                    num/=2;shu++;                }            }        }        sort(cha+1,cha+1+n);        for(int j=1;j&lt;=n-m;j++)cnt+=cha[j];        minn=min(minn,cnt);    }    cout&lt;&lt;minn&lt;&lt;endl;    return;}signed main() {    cin &gt;&gt; T;    while(T--) {        solve();    }    return 0;}</code></pre><h1 id="Best-Carry-Player"><a href="#Best-Carry-Player" class="headerlink" title="Best Carry Player"></a>Best Carry Player</h1><p><a href="https://www.luogu.com.cn/problem/P9679">https://www.luogu.com.cn/problem/P9679</a></p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include &lt;queue&gt;#define LL long long#define endl "\n"#define debug(x) std:: cout &lt;&lt; "---DEBUG--- " &lt;&lt; x &lt;&lt; " -----DEBUG----\n"using namespace std;const int maxn = 3e5+5;string s;char sr[20]= {'0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f'};int T;int n;int sum[20], ans;int t;void solve(){    cin &gt;&gt; n;    ans = 0;    for(int i = 1; i &lt;= 15; i++) sum[i] = 0;    for(int i = 1; i &lt;= n; i++){        cin &gt;&gt; t;        for(int j = 1; t != 0; j++){            sum[j] += t % 10;            t/=10;        }    }    for(int j = 1; j &lt;= 15; j++){        ans += sum[j] / 10;        sum[j+1] += sum[j] / 10;    }    cout &lt;&lt; ans &lt;&lt; endl;}int main() {    cin &gt;&gt; T;    while(T--){        solve();    }    return 0;}</code></pre><h1 id="Identical-Parity"><a href="#Identical-Parity" class="headerlink" title="Identical Parity"></a>Identical Parity</h1><p><a href="https://www.luogu.com.cn/problem/P9671">https://www.luogu.com.cn/problem/P9671</a></p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include &lt;queue&gt;#define LL long long#define endl "\n"#define debug(x) std:: cout &lt;&lt; "---DEBUG--- " &lt;&lt; x &lt;&lt; " -----DEBUG----\n"using namespace std;const int maxn = 3e5+5;string s;char sr[20]= {'0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f'};int T;int n;int k;bool solve() {    cin &gt;&gt; n &gt;&gt; k;    if(k % 2 == 0) return true;    int num1 = (n + 1) / 2 - (k + 1) / 2 * (n / k);    int num2 = n / 2 - k / 2 * (n / k);    if (num1 &gt;= 0 and num1 &lt;= (k + 1) / 2 and num2 &gt;= 0 and num2 &lt;= k / 2) return true; //最后的一块可以分配好么    //if(num1 - num2 == 1 || num1 - num2 == 0) return true;    else return false;}int main() {    cin &gt;&gt; T;    while(T--) {        if(solve()){cout &lt;&lt; "yes" &lt;&lt; endl;}        else {cout &lt;&lt; "no" &lt;&lt; endl;}    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MATLAB关于不同窗口滤波的时间差异</title>
      <link href="/2023/11/22/MATLAB%E5%85%B3%E4%BA%8E%E4%B8%8D%E5%90%8C%E7%AA%97%E5%8F%A3%E6%BB%A4%E6%B3%A2%E7%9A%84%E6%97%B6%E9%97%B4%E5%B7%AE%E5%BC%82/"/>
      <url>/2023/11/22/MATLAB%E5%85%B3%E4%BA%8E%E4%B8%8D%E5%90%8C%E7%AA%97%E5%8F%A3%E6%BB%A4%E6%B3%A2%E7%9A%84%E6%97%B6%E9%97%B4%E5%B7%AE%E5%BC%82/</url>
      
        <content type="html"><![CDATA[<h1 id="任务要求"><a href="#任务要求" class="headerlink" title="任务要求"></a>任务要求</h1><p>今日寒潮降温，Q粿讲了讲规格化的图像处理，留到下节课做，这节课就做一做MATLAB中对于不同的滑动卷积窗口比如说三乘三，五乘五，还有更大的窗口，看看运算时间的差异。</p><p>于是是学习了imfilter滤波函数以及tictok的计时方法</p><h1 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h1><pre><code class="matlab">% 读取图像并调整大小和灰度img = imread('C:\Users\7878\Desktop\my_image.png');img1 = imresize(img, 0.4);img1 = rgb2gray(img1);% 创建子图subplot(3,2,1);set(gcf, 'Position', [0 0 1000 800])  % 设置窗口大小imshow(img1);set(gca, 'Position', [ 0 2/3 1/3 1/3]);  % 设置子图1位置和大小[r,c] = size(img1);% 定义不同的滤波器filter3 = ones(3,3)/(3*3);filter5 = ones(5,5)/(5*5);filter15 = ones(15,15)/(15*15);filter35 = ones(35,35)/(35*35);% 对图像进行不同尺寸的均值滤波，并计算时间ticresult1 = imfilter(img1, filter3, 'conv', 'replicate');  % 对图像进行3*3均值滤波time1 = toc;disp(' 3*3 时间' + time1);subplot(3,2,2);set(gca, 'Position', [ 1/2 2/3 1/3 1/3]);  % 设置子图2位置和大小imshow(result1);ticresult2 = imfilter(img1, filter5, 'conv', 'replicate');  % 对图像进行5*5均值滤波time2 = toc;disp(' 5*5 时间' + time2);subplot(3,2,3);imshow(result2);set(gca, 'Position', [ 0 1/3 1/3 1/3]);  % 设置子图3位置和大小ticresult3 = imfilter(img1, filter15, 'conv', 'replicate');  % 对图像进行15*15均值滤波time3 = toc;disp(' 15*15 时间' + time3);subplot(3,2,4);imshow(result3);set(gca, 'Position', [ 1/2 1/3 1/3 1/3]);  % 设置子图4位置和大小ticresult4 = imfilter(img1, filter35, 'conv', 'replicate');  % 对图像进行35*35均值滤波time4 = toc;disp(' 35*35 时间' + time4);subplot(3,2,5);imshow(result4);set(gca, 'Position', [ 0 0 1/3 1/3]);  % 设置子图5位置和大小</code></pre><h1 id="效果如下"><a href="#效果如下" class="headerlink" title="效果如下"></a>效果如下</h1><p><img src="/../images/image-20231122202258741.png" alt="image-20231122202258741"></p>]]></content>
      
      
      
        <tags>
            
            <tag> MATLAB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络静态路由的配置实验</title>
      <link href="/2023/11/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1%E7%9A%84%E9%85%8D%E7%BD%AE%E5%AE%9E%E9%AA%8C/"/>
      <url>/2023/11/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1%E7%9A%84%E9%85%8D%E7%BD%AE%E5%AE%9E%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="实验八、静态路由的配置"><a href="#实验八、静态路由的配置" class="headerlink" title="实验八、静态路由的配置"></a>实验八、静态路由的配置</h1><h3 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a>一、实验目的</h3><p>1．掌握路由器的主要功能。</p><p>2．掌握静态路由的配置方法。</p><h3 id="二、实验内容"><a href="#二、实验内容" class="headerlink" title="二、实验内容"></a>二、实验内容</h3><p>1．安装CISCO模拟器；</p><p>2．画出网络拓扑图；</p><p>3．进行静态路由的配置；</p><p>4．测试网络的通信效果。</p><h3 id="三、实验原理"><a href="#三、实验原理" class="headerlink" title="三、实验原理"></a>三、实验原理</h3><p>在不同网络之间进行通信时，需要用到路由器这种设备。路由器的两个主要功能就是路由选择和数据转发。路由选择的方法有很多，最简单的一种就是静态路由，通过对路由器进行路径规定，使得数据可以跨不同网段进行通信。</p><p>一般来说，可通过五种方式来设置路由器：</p><p>1．控制台（Console口）接终端，或运行终端仿真软件的微机；</p><p>2．辅助端口（AUX口）接MODEM，通过电话线与远方的终端或运行终端仿真软件的微机相连；</p><p>3．通过Ethernet上的简单文件传输协议（TFTP）服务器；</p><p>4．通过Ethernet上的TELNET程序；</p><p>5．通过Ethernet上的简单网络管理协议（SNMP）,路由器可通过运行网络管理软件的工作站配置。</p><p>但路由器的第一次设置必须通过第一种方式进行,此时终端的硬件设置如下:</p><p>波特率 ：9600</p><p>数据位 ：8</p><p>停止位 ：1</p><p>奇偶校验: 无</p><h3 id="四、实验步骤"><a href="#四、实验步骤" class="headerlink" title="四、实验步骤"></a>四、实验步骤</h3><p>为简化步骤，我们可以直接在路由器上写命令。</p><p><img src="/../images/image-20231121162110199.png" alt="image-20231121162110199"></p><pre><code class="bash">Router0：Router&gt;Router&gt;enable   //进入特权模式Router#conf t   //进入全局配置模式Enter configuration commands, one per line. End with CNTL/Z.Router(config)#int f0/0   //即interface fastEthernet 0/0进入路由器接口配置模式Router(config-if)#ip address 10.1.1.1 255.255.255.0 //配置路由器管理接口的IP地址Router(config-if)#no shutdown  //开启路由器的fastEthernet 0/0接口。注意，给端口配置IP的命令也可以在图形界面上实现，配完别忘记打开端口Router(config-if)#exitRouter(config)#ip route 192.168.1.0 255.255.255.0 10.1.1.2 //先不写这句话，在Router0上ping  192.168.1.1，是否可以ping通？写完之后再试一试Router(config)#end</code></pre><pre><code class="bash">Router1：Router&gt;enableRouter#conf tRouter#conf tRouter(config)#no ip domain-look //关闭域名解析，原因假如你在CLI下输入了1个Cisco设备不能识别的命令,它会默认通过DNS来进行解析(它认为是主机名).这个不好的地方是要花费额外的时间等待DNS解析完.可以在全局配置模式下使用no ip domain-look命令关闭它Router(config)#int f0/0Router(config-if)#ip address 10.1.1.2 255.255.255.0Router(config-if)#no shutdownRouter(config-if)#Router(config-if)#exitRouter(config)#int f0/1Router(config-if)#ip address 192.168.1.1 255.255.255.0Router(config-if)#no shutRouter(config-if)#exit</code></pre><pre><code class="bash">Router2：Router&gt;enable Router#conf tRouter(config)#int f0/1Router(config-if)#ip address 192.168.1.2 255.255.255.0Router(config-if)#no shutRouter(config-if)#Router(config-if)#exitRouter(config)#ip route 10.1.1.0 255.255.255.0 192.168.1.1 //这句命令先不要写，实验一下在Router0上ping其它IP的结果，是不是除了192.168.1.2外都可以ping通？写完这句话后再试一下是不是都可以了？原因是什么？在实验结果1中回答。Router(config)#end</code></pre><h3 id="五、实验结果"><a href="#五、实验结果" class="headerlink" title="五、实验结果"></a>五、实验结果</h3><p>1、在 Router2设置路由表之前之后，用Router0分别和其他的两台路由器进行测试，看一下网络是否联通，并思考为什么会出现这种情况。</p><p><strong>Route0只能ping通直连的10.1.1.2，而不能ping通不直连的192.168.1.1和192.168.1.12。因为路由表中没有存储前往ip地址的下一跳的地址。</strong></p><p><strong>但是如果单单配置单向的也是不能ping通的，是因为ping的包需要返回，二没有配置返回的路径。</strong></p><p>2、用Router1分别和其他的两台路由器进行测试，看一下网络是否联通，并思考为什么会出现这种情况。</p><p><strong>Route1是相通的，因为端口直连要ping的IP地址。</strong></p><p>3、用Router2分别和其他的两台路由器进行测试，看一下网络是否联通，并思考为什么会出现这种情况。</p><p><strong>Router2是可以ping通的，因为已经配置好了路由表的地址的下一跳要经过哪里。</strong></p><p>注意：直接在路由器的CLI中ping即可：</p><pre><code class="bash">Router#ping 192.168.1.1Type escape sequence to abort.Sending 5, 100-byte ICMP Echos to 192.168.1.1, timeout is 2 seconds:!!!!!Success rate is 100 percent (5/5), round-trip min/avg/max = 0/0/1 ms//这就表示通了Router#ping 192.168.1.2Type escape sequence to abort.Sending 5, 100-byte ICMP Echos to 192.168.1.2, timeout is 2 seconds:.....Success rate is 0 percent (0/5)//这就是没有通</code></pre><h3 id="六、实验原理"><a href="#六、实验原理" class="headerlink" title="六、实验原理"></a>六、实验原理</h3><p>在思科模拟器中，使用的是Cisco的设备模拟器，例如Packet Tracer或者GNS3。这些模拟器提供了类似于实际Cisco路由器和交换机的环境，但命令和配置可能略有不同。在Cisco设备上，配置路由表的命令通常是<code>ip route</code>，但具体的语法和选项可能会有些许差异。</p><p>以下是在Cisco设备上的一些基本示例：</p><ul><li><p><strong>显示路由表信息：</strong></p><pre><code class="bash">show ip route</code></pre></li><li><p><strong>添加静态路由：</strong></p><pre><code class="bash">ip route [目标网络] [子网掩码] [下一跳地址或出口接口]</code></pre></li><li><p><strong>删除路由：</strong></p><pre><code class="bash">no ip route [目标网络] [子网掩码] [下一跳地址或出口接口]</code></pre></li><li><p><strong>默认路由设置：</strong></p><pre><code class="bash">ip route 0.0.0.0 0.0.0.0 [默认网关]</code></pre></li></ul><p>请注意，具体的命令可能因设备型号和操作系统版本而异。在使用模拟器时，建议查阅相应设备的文档以获取准确的命令和配置信息。</p><p>添加route之前</p><p>Route0去ping192.168.1.1</p><p><img src="/../images/image-20231121160802070.png" alt="image-20231121160802070"></p><p>ping自身是可以的</p><p><img src="/../images/image-20231121160906323.png" alt="image-20231121160906323"></p><p>ping直接相连的路由端口是可以ping通的</p><p><img src="/../images/image-20231121160951662.png" alt="image-20231121160951662"></p><p>ping192.168.1.2是不可以ping通的</p><p><img src="/../images/image-20231121164730577.png" alt="image-20231121164730577"></p><p>当添加了命令后可以ping通了192.168.1.1，但是192.168.1.2仍然不可以</p><p><img src="/../images/image-20231121161149284.png" alt="image-20231121161149284"></p><p>当我没有配置route2的route时，ping route0是不可以通信的</p><p><img src="/../images/image-20231121161416077.png" alt="image-20231121161416077"></p><p>当配置之后route2是可以和route0的端口通信的</p><p><img src="/../images/image-20231121164824576.png" alt="image-20231121164824576"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity中的自动寻路Navigation使用</title>
      <link href="/2023/11/16/Unity%E4%B8%AD%E7%9A%84%E8%87%AA%E5%8A%A8%E5%AF%BB%E8%B7%AFNavigation%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/11/16/Unity%E4%B8%AD%E7%9A%84%E8%87%AA%E5%8A%A8%E5%AF%BB%E8%B7%AFNavigation%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="包导入"><a href="#包导入" class="headerlink" title="包导入"></a>包导入</h1><p>窗口中选择包管理器，搜索AI，添加相应的包，接下来可以在窗口中选择AI面板，要选择那个过时的使用（泄。</p><h1 id="场景配置"><a href="#场景配置" class="headerlink" title="场景配置"></a>场景配置</h1><p>搭建如图所示的地形</p><p><img src="/../images/image-20231116142557278.png" alt="image-20231116142557278"></p><p>将不需要移动的设置为静态。</p><p><img src="/../images/image-20231116142747375.png" alt="image-20231116142747375"></p><p>点击navigation的面板，生成自动寻路网格。</p><p><img src="/../images/image-20231116143021803.png" alt="image-20231116143021803"></p><h1 id="组件配置"><a href="#组件配置" class="headerlink" title="组件配置"></a>组件配置</h1><p>选择要添加的物体，添加Nav Mesh Agent。再添加一个C#脚本。</p><pre><code class="c#">using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.AI;public class AI : MonoBehaviour{    public GameObject gameObject;    private NavMeshAgent agent;    public Transform target; // 设置目标位置    // Start is called before the first frame update    void Start()    {        //gameObject = GameObject.Find("Tree");                agent = GetComponent&lt;NavMeshAgent&gt;();        SetDestination();    }    // Update is called once per frame    void Update()    {            }    void SetDestination()    {        if (target != null)        {            agent.SetDestination(target.position);        }    }}</code></pre><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p><img src="/../images/image-20231116144928854.png" alt="image-20231116144928854"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于linux的fork进程中stdout中的缓冲问题</title>
      <link href="/2023/11/16/%E5%85%B3%E4%BA%8Elinux%E7%9A%84fork%E8%BF%9B%E7%A8%8B%E4%B8%ADstdout%E4%B8%AD%E7%9A%84%E7%BC%93%E5%86%B2%E9%97%AE%E9%A2%98/"/>
      <url>/2023/11/16/%E5%85%B3%E4%BA%8Elinux%E7%9A%84fork%E8%BF%9B%E7%A8%8B%E4%B8%ADstdout%E4%B8%AD%E7%9A%84%E7%BC%93%E5%86%B2%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="问题发现"><a href="#问题发现" class="headerlink" title="问题发现"></a>问题发现</h1><p>做了一个进程中pipe通信的Demo，结果发现在第二个子进程结束后，又将第一次的结果输出出来了，本来预期结果是第二次进程仅有第二次的进程才对，竟然包含第一次的结果？</p><p>代码如下：</p><p><img src="/../images/image-20231116102300214.png" alt="image-20231116102300214"></p><p><img src="/../images/image-20231116102314858.png" alt="image-20231116102314858"></p><p><img src="/../images/image-20231116102332708.png" alt="image-20231116102332708"></p><p>结果竟然在111之后，也就是父进程执行之后又再次出现p1的相关信息？</p><h1 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h1><p>我先去查找pipe的相关资料，pipe中的信息在读取一次之后就不能再读取了，看来不是pipe的作用，为此我直接删掉了pipe的相关代码。</p><p>如下所示：</p><p><img src="/../images/image-20231116102522179.png" alt="image-20231116102522179"></p><p><img src="/../images/image-20231116102546964.png" alt="image-20231116102546964"></p><p>结果竟然是两个111，为什么父进程第二次创建子进程会再次执行它上一行代码里面所包含的111？到这里更加觉得奇怪。</p><p>询问后有同事认为是孤儿进程的问题。</p><p>如果是 systemd，它的策略是接管孤儿进程，并将其变为独立进程路士磊 202118640111 2023/11/15 19:27:45<br>这个过程会重新分配pcb<br>重新分配pcb &lt;- pid 被充值<br>然后到底是输出多少111就取决于运气了（<br>孤儿进程独立后，pid 不为0 ，会执行15行的代码<br>和 A 的表现几乎一致了<br>如果第二种可能持续发生，可能会有一堆 111</p><p>由于我对孤儿进程了解较少，查询资料后仍然有困惑，为什么我尝试输出很多次都是111，甚至换了设备同样是111呢？</p><p>再次返回到对fork的搜索上。</p><p>发现了这样的解释：</p><p><img src="/../images/image-20231116102911536.png" alt="image-20231116102911536"></p><p>竟然是缓冲区的问题，之前没考虑到这一点，于是饶了弯路，但在我本地的环境\n并不会触发缓冲区的输出，还是要手动的fflush()才可以。</p><p>至此问题解决。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络VTP配置</title>
      <link href="/2023/11/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9CVTP%E9%85%8D%E7%BD%AE/"/>
      <url>/2023/11/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9CVTP%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="实验六plus、VTP的配置"><a href="#实验六plus、VTP的配置" class="headerlink" title="实验六plus、VTP的配置"></a>实验六plus、VTP的配置</h2><h2 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a>一、实验目的</h2><p>测试同学们对VLAN配置及交换机命令的掌握情况</p><h2 id="二、实验内容"><a href="#二、实验内容" class="headerlink" title="二、实验内容"></a>二、实验内容</h2><p>1.安装CISCO模拟器；</p><p>2.画出网络拓扑图；</p><p>3.进行VTP的配置；</p><p>4.测试VLAN的通信效果。</p><h2 id="三、实验步骤"><a href="#三、实验步骤" class="headerlink" title="三、实验步骤"></a>三、实验步骤</h2><p>在模拟器中构建一个如下图所示的网络拓扑图，配置三个VLAN，VLAN111用于教师VLAN，VLAN222用于学生VLAN，VLAN333用于其他用户。</p><p>​                               <img src="/../images/image-20231114160155722.png" alt="image-20231114160155722"></p><p><strong>请自己写命令完成VLAN的配置，要求将Switch0改名为SW111，Switch1改名为SW222，且SW111为VTP服务器，SW222为VTP客户端，在SW111上配置完VLAN后，SW222将自动获取三个VLAN的配置信息。</strong></p><p><strong>记得交换机和VLAN都要改名字，VLAN改名字的方法请自己摸索。</strong></p><p><strong>下面的命令请同学们自己写，步骤已经给大家写好。</strong></p><p><strong>1）配置第一台交换机</strong></p><p>创建VLAN</p><p>将接口加入到各自的VLAN</p><p>配置VLAN Trunk接口</p><p>再配置VTP服务器</p><p><strong>2）配置第二台交换机</strong></p><p>先配置VLAN Trunk接口</p><p>再配置VTP客户端</p><p>配置好之后发现在VTP服务器SW111上的VLAN配置信息、VTP域名以及VLAN配置内容均已通过中继接口f0/24传播到VTP客户机模式的交换机SW222上了。</p><p>下面将接口添加到VLAN</p><p>测试：同一VLAN可以ping通，不同VLAN间的不能ping通。</p><p>第一个配置</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MATLAB关于图像灰度值的一些调整线性与非线性</title>
      <link href="/2023/11/08/MATLAB%E5%85%B3%E4%BA%8E%E5%9B%BE%E5%83%8F%E7%81%B0%E5%BA%A6%E5%80%BC%E7%9A%84%E4%B8%80%E4%BA%9B%E8%B0%83%E6%95%B4%E7%BA%BF%E6%80%A7%E4%B8%8E%E9%9D%9E%E7%BA%BF%E6%80%A7/"/>
      <url>/2023/11/08/MATLAB%E5%85%B3%E4%BA%8E%E5%9B%BE%E5%83%8F%E7%81%B0%E5%BA%A6%E5%80%BC%E7%9A%84%E4%B8%80%E4%BA%9B%E8%B0%83%E6%95%B4%E7%BA%BF%E6%80%A7%E4%B8%8E%E9%9D%9E%E7%BA%BF%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>今天Q艮点名，还整的挺彳亍。晚上实验，先用ps的那个图像有个调整灰度分布的曲线，捏着就调整了，挺彳。</p><p>作业的话当然不是整理成ps那种的形式太难了。而是一个线性的映射，一个对数的映射。</p><p>代码与结果如下：</p><pre><code class="matlab">img = imread('C:\Users\7878\Desktop\my_image.png');img1 = imresize(img, 0.3);img1 = rgb2gray(img1);subplot(2, 2, 1);imshow(img1); [r,c] = size(img1); output_image1 = zeros(size(img1)); %  function1 = @(x) x * 1.5; for i=1:r    for j=1:c        value = double(img1(i, j));        output_image1(i, j) = function1(value);    endend  output_image1 = uint8(max(0, min(255, output_image1))); subplot(2,2,2);imshow(output_image1); % % function2 = @(x) (255 / log(256)) * log(1 + x);% % for i=1:r%     for j=1:c%         value = double(img1(i, j));%         if(value == 0) %             continue;%         end%         output_image1(i, j) = function2(value);%     end% end% % % output_image1 = uint8(max(0, min(255, output_image1))); subplot(2,2,2);imshow(output_image1);  subplot(2,2,3);imhist(img1);subplot(2,2,4);imhist(output_image1);</code></pre><p><img src="/../images/image-20231108204739001.png" alt="image-20231108204739001"></p><p><img src="/../images/image-20231108204744493.png" alt="image-20231108204744493"></p>]]></content>
      
      
      
        <tags>
            
            <tag> MATLAB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络虚拟网实验2</title>
      <link href="/2023/11/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%99%9A%E6%8B%9F%E7%BD%91%E5%AE%9E%E9%AA%8C2/"/>
      <url>/2023/11/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%99%9A%E6%8B%9F%E7%BD%91%E5%AE%9E%E9%AA%8C2/</url>
      
        <content type="html"><![CDATA[<h1 id="实验六-虚拟局域网（VLAN）实验练习"><a href="#实验六-虚拟局域网（VLAN）实验练习" class="headerlink" title="实验六 虚拟局域网（VLAN）实验练习"></a>实验六 虚拟局域网（VLAN）实验练习</h1><h3 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a>一、实验目的</h3><p>1．练习巩固上次实验的内容</p><h3 id="二、实验步骤"><a href="#二、实验步骤" class="headerlink" title="二、实验步骤"></a>二、实验步骤</h3><p>1．画图如下，按表格内容进行配置，并将switch0改名为SWA，switch1改名为SWB。</p><p>​     <img src="/../images/image-20231107163636646.png" alt="image-20231107163636646"></p><table><thead><tr><th>名称</th><th>相连的接口</th><th>IP地址</th></tr></thead><tbody><tr><td>PC1</td><td>F0/5</td><td>172.1.1.2/24</td></tr><tr><td>PC2</td><td>F0/6</td><td>172.1.1.3/24</td></tr><tr><td>PC3</td><td>F0/7</td><td>172.1.1.4/24</td></tr><tr><td>PC4</td><td>F0/5</td><td>172.1.1.10/24</td></tr><tr><td>PC5</td><td>F0/6</td><td>172.1.1.11/24</td></tr><tr><td>PC6</td><td>F0/7</td><td>172.1.1.12/24</td></tr></tbody></table><p><strong>回答问题：</strong></p><p><strong>此时PC1—PC6之间是否是互通的？</strong></p><p>==此时是相互可以通信的。==</p><p>2、分别在SWA和SWB上创建三个vlan，命名为vlan2，vlan3和vlan4</p><p>在SWA上将f0/5端口划分到vlan2，f0/6端口划分到vlan3，f0/7端口划分到vlan4</p><p>在SWB上将f0/5端口划分到vlan2，f0/6端口划分到vlan3，f0/7端口划分到vlan4。</p><p> <img src="/../images/image-20231107165241405.png" alt="image-20231107165241405"></p><p><strong>回答问题：</strong></p><p><strong>此时PC1—PC6之间是否是互通的？</strong></p><p> ==此时是相互不能通信的，任何的通信都会timeout。==</p><p>3、在两台交换机的1、2、3端口上连接三条线，分别将其划分到vlan2，vlan3和vlan4中。</p><p><strong>回答问题：</strong></p><p><strong>此时PC1—PC6之间哪些是互通的？</strong></p><p><img src="/../images/image-20231107171131871.png" alt="image-20231107171131871"></p><p>==此时处在同一个vlan下的pc是可以相互通信的。==</p><p><img src="/../images/image-20231107170901044.png" alt="image-20231107170901044"></p><p><img src="/../images/image-20231107171013906.png" alt="image-20231107171013906"></p><p>4、在两台交换机之间建立一条trunk中继线线路代替上述方法，删除之前的三根线，重接一根，双方都接f0/12。</p><p>SWA的trunk配置如下：</p><pre><code class="shell">SWA&gt;enSWA#conf tSWA(config)int f0/12SWA(config-if)#switch mode trunkSWA(config-if)#exit</code></pre><p>SWB的trunk配置配置与上述一样，其实可以不用配置，即可自动获得。</p><p>观察一下此接口此时包含哪些vlan。（可在图形界面中观察）</p><p><strong>回答问题：</strong></p><p><strong>此时PC1—PC6之间哪些是互通的？</strong></p><p>==此时也是处于同一个vlan下的pc是互通的==</p><p> <img src="/../images/image-20231107171423544.png" alt="image-20231107171423544"></p><p><img src="/../images/image-20231107171414578.png" alt="image-20231107171414578"></p><p><img src="/../images/image-20231107171628253.png" alt="image-20231107171628253"></p><h3 id="三、实验报告要求"><a href="#三、实验报告要求" class="headerlink" title="三、实验报告要求"></a>三、实验报告要求</h3><p>记录步骤，回答问题，将此实验文档加入到上次的实验六中，先不交，下节课课上我会统一发送一个题目，请大家自行完成，完成后找我看结果，将此结果也写到实验六里，最后请将实验四五六一起打包发给学委。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络虚拟局域网实验</title>
      <link href="/2023/11/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%99%9A%E6%8B%9F%E5%B1%80%E5%9F%9F%E7%BD%91%E5%AE%9E%E9%AA%8C/"/>
      <url>/2023/11/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%99%9A%E6%8B%9F%E5%B1%80%E5%9F%9F%E7%BD%91%E5%AE%9E%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<h3 id="实验六-虚拟局域网（VLAN）实验"><a href="#实验六-虚拟局域网（VLAN）实验" class="headerlink" title="实验六 虚拟局域网（VLAN）实验"></a>实验六 虚拟局域网（VLAN）实验</h3><h3 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a>一、实验目的</h3><p>1.掌握VLAN的划分方法。</p><p>2.理解划分VLAN的作用。</p><p>3.掌握VTP的配置方法。</p><h3 id="二、实验内容"><a href="#二、实验内容" class="headerlink" title="二、实验内容"></a>二、实验内容</h3><p>1.画出网络拓扑图。</p><p>2.进行VLAN的划分。</p><p>3.测试VLAN的通信效果。</p><p>4.进行VTP的配置并测试通信效果。</p><h3 id="三、实验原理"><a href="#三、实验原理" class="headerlink" title="三、实验原理"></a>三、实验原理</h3><p>VLAN就是虚拟局域网，它用于把物理上直接相连的网络从逻辑上划分成多个子网。每一个VLAN对应着一个广播域，处于不同VLAN的主机不能直接进行通信，而必须借助第三层交换技术。</p><p>在大型网络中交换机较多的情况下，可以利用交换机的VTP模式进行VLAN划分的学习，统一网络结构，减少网络配置的工作量。</p><h3 id="四、实验步骤"><a href="#四、实验步骤" class="headerlink" title="四、实验步骤"></a>四、实验步骤</h3><p><strong>1、基本VLAN配置</strong></p><p>在模拟器中新建一个如下图所示的网络拓扑图，并设置好每台PC的IP地址和子网掩码。</p><p><img src="/../images/clip_image002.png" alt="img"></p><p>单击交换机，在CLI标签下输入以下命令（注意，逐条输入。不能直接复制粘贴。边输入边思考命令的含义）</p><pre><code class="shell">Switch0：Switch&gt;enableSwitch#conf t: 进入全局配置模式，允许你对交换机进行配置。Switch(config)#vlan 100: 创建一个VLAN 100。这个命令将你带入VLAN配置模式，允许你对该VLAN的属性进行配置。Switch(config-vlan)#exit: 退出VLAN配置模式，返回到全局配置模式。Switch(config)#vlan 200: 创建另一个VLAN，VLAN 200。Switch(config-vlan)#exit: 再次退出VLAN配置模式。Switch(config)#int f0/1: 进入接口配置模式，以配置交换机端口 f0/1。Switch(config-if)#switchport access vlan 100: 将接口 f0/1 配置为访问模式，并指定它属于VLAN 100。Switch(config-if)#exit: 退出接口配置模式。Switch(config)#int f0/2: 进入接口配置模式，以配置交换机端口 f0/2。Switch(config-if)#switchport access vlan 100: 将接口 f0/2 配置为访问模式，并指定它也属于VLAN 100。Switch(config-if)#exit: 再次退出接口配置模式。Switch(config)#int range f0/11-f0/15: 进入一系列接口的范围配置模式，以配置多个连续的端口。Switch(config-if-range)#switchport access vlan 200: 将接口范围 f0/11 到 f0/15 配置为访问模式，并指定它们属于VLAN 200。Switch(config-if-range)#end: 退出接口范围配置模式。Switch#show vlan: 这是一个显示VLAN配置的命令。它会列出所有已配置的VLAN及其属性。VLAN Name               Status  Ports---- -------------------------------- --------- -------------------------------1  default             active  Fa0/3, Fa0/4, Fa0/5, Fa0/6​                        Fa0/7, Fa0/8, Fa0/9, Fa0/10​                        Fa0/16, Fa0/17, Fa0/18, Fa0/19​                        Fa0/20, Fa0/21, Fa0/22, Fa0/23​                        Fa0/24, Gig1/1, Gig1/2100 VLAN0100             active  Fa0/1, Fa0/2200 VLAN0200             active  Fa0/11, Fa0/12, Fa0/13, Fa0/14​                        Fa0/151002 fddi-default           act/unsup 1003 token-ring-default        act/unsup 1004 fddinet-default         act/unsup 1005 trnet-default          act/unsup  </code></pre><p><strong>测试实验结果</strong></p><p>用PC0分别和其他的三台PC机进行测试，看一下网络是否联通，截屏记录实验结果并回答为什么会出现这种情况。</p><p>下图代表不通：</p><p><img src="/../images/clip_image003.png" alt="img"></p><p>下图代表通了</p><p><img src="/../images/clip_image004.png" alt="img"></p><p>结合课堂讲授的VLAN原理，分析为什么会这样。</p><p><strong>2、VTP配置</strong></p><p><img src="/../images/clip_image006-1699343520337-1.jpg" alt="img"></p><p>交换机1：</p><pre><code class="shell">（switch0）：Switch&gt;Switch&gt;enable Switch#conf tSwitch(config)#interface f0/24: 进入接口配置模式，以配置交换机端口 f0/24。Switch(config-if)#switchport mode trunk: 将端口 f0/24 配置为中继模式。中继模式允许传送多个VLAN的数据帧。Switch(config-if)#exit: 退出接口配置模式。Switch(config)#vtp domain 123: 设置VTP域名为 "123"。这定义了一个VTP域，确保所有使用相同域名的VTP设备在同一个VTP域内。Switch(config)#vtp mode server: 将本交换机配置为VTP服务器模式。服务器模式允许你管理VLAN信息并将其同步到其他VTP设备。Switch(config)#vlan 100: 创建一个VLAN 100。Switch(config-vlan)#exit: 退出VLAN配置模式。Switch(config)#vlan 200: 创建另一个VLAN 200。Switch(config-vlan)#exit: 再次退出VLAN配置模式。Switch(config)#int f0/1: 进入接口配置模式，以配置交换机端口 f0/1。Switch(config-if)#switchport access vlan 100: 将端口 f0/1 配置为访问模式，并指定它属于VLAN 100。Switch(config-if)#exit: 退出接口配置模式。Switch(config)#int f0/11: 进入接口配置模式，以配置交换机端口 f0/11。Switch(config-if)#switchport access vlan 200: 将端口 f0/11 配置为访问模式，并指定它属于VLAN 200。Switch(config-if)#exit: 再次退出接口配置模式。Switch(config)#exit: 退出全局配置模式。Switch# show vlan: 这是一个显示VLAN配置的命令，它会列出已配置的VLAN及其属性。Switch#show vtp status: 这是一个显示VTP状态的命令。它将显示VTP域名、VTP模式以及VTP配置的版本等信息。在你的配置中，VTP域名被设置为 "123"，模式为服务器（Server）。</code></pre><p>交换机2</p><pre><code class="shell">(switch1):Switch&gt;Switch&gt;en Switch#conf tSwitch(config)#int f0/24: 进入接口配置模式，以配置交换机端口 f0/24。Switch(config-if)#switchport mode trunk: 将端口 f0/24 配置为中继模式。中继模式允许传送多个VLAN的数据帧。Switch(config-if)#exit: 退出接口配置模式。Switch(config)#vtp domain 123: 设置VTP域名为 "123"。这定义了一个VTP域，确保所有使用相同域名的VTP设备在同一个VTP域内。Switch(config)#vtp mode client: 将本交换机配置为VTP客户端模式。客户端模式表示该交换机将接收来自VTP服务器的VLAN配置信息，但不能修改或添加新的VLAN。Switch(config)#end: 退出配置模式。Switch#conf t: 进入全局配置模式，以便继续配置其他参数。Switch(config)#int f0/1: 进入接口配置模式，以配置交换机端口 f0/1。Switch(config-if)#switchport access vlan 100: 将端口 f0/1 配置为访问模式，并指定它属于VLAN 100。Switch(config-if)#exit: 退出接口配置模式。Switch(config)#int f0/11: 进入接口配置模式，以配置交换机端口 f0/11。Switch(config-if)#switchport access vlan 200: 将端口 f0/11 配置为访问模式，并指定它属于VLAN 200。Switch(config-if)#exit: 再次退出接口配置模式。Switch(config)#: 退出全局配置模式。Switch# </code></pre><p><strong>测试实验结果</strong></p><p>用PC0分别和其他的三台PC机进行测试，看一下网络是否联通，截屏记录实验结果并回答为什么会出现这种情况。</p><h3 id="五、实验报告要求"><a href="#五、实验报告要求" class="headerlink" title="五、实验报告要求"></a>五、实验报告要求</h3><p>1．练习使用Cisco Packet Tracer 画出网络拓扑结构图，掌握虚拟局域网的配置方法（基本配置和VTP配置），截屏+文字记录相关步骤，测试VLAN配置后的通信效果。 </p><p>提交word文档，文件名为：学号姓名实验六。先不交，下节课课上我会统一发送一个题目，请大家自行完成，完成后找我看结果，将此结果也写到实验六里，最后请将实验四五六一起打包发给学委。</p><p><img src="/../images/image-20231107160538893.png" alt="image-20231107160538893"></p><p><img src="/../images/image-20231107160526060.png" alt="image-20231107160526060"></p><p>那么也就是说在同一个vlan中的设备才可以相互访问</p><p><img src="/../images/image-20231107163057232.png" alt="image-20231107163057232"></p><p>那么对于上述的网络同样是只有在相同的vlan中才可以ping通</p><p><img src="/../images/image-20231107163133399.png" alt="image-20231107163133399"></p><p><img src="/../images/image-20231107163138801.png" alt="image-20231107163138801"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>交换机地址学习</title>
      <link href="/2023/11/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%9C%B0%E5%9D%80%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/11/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%9C%B0%E5%9D%80%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="实验五-交换机地址自学习"><a href="#实验五-交换机地址自学习" class="headerlink" title="实验五 交换机地址自学习"></a>实验五 交换机地址自学习</h1><h3 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a>一、实验目的</h3><p>1．了解交换机的作用。</p><p>2.查看MAC地址转发表，理解交换机的基于MAC地址转发表的工作过程。</p><p>3.掌握交换机地址自学习的过程。</p><h3 id="二、实验内容"><a href="#二、实验内容" class="headerlink" title="二、实验内容"></a>二、实验内容</h3><p>1．使用Cisco Packet Tracer画出网络拓扑图。</p><p>2．查看MAC地址转发表。</p><p>3．观察交换机地址自学习的过程。</p><h3 id="三、实验原理"><a href="#三、实验原理" class="headerlink" title="三、实验原理"></a>三、实验原理</h3><p>以太网交换机的自学习功能：</p><p>我们假设一个以太网交换机有1、2、3、4，共4个接口，每个接口都分别连接了一台计算机，他们的MAC地址分别是A、B、C和D。在最开始的时候，交换机的交换表是空的。假如A向B发送了一帧，从接口1进入交换机，交换机收到这一帧之后会先查找交换表，不过很显然表是空的，交换机查不到应该从哪个接口转发这个帧（就是找不到目的地址为B的表项）。那么接下来，交换机就会把这个帧的源地址A和接口1写入交换表中，并向除了接口1之外的所有接口广播这个帧。那么这样一来，不论交换机的哪个接口收到目的地址是A的帧，都只要把这个帧转发到接口1，因为既然A发送的帧能从接口1进入交换机，那么交换机自然也能从接口1找到A。</p><p>上面我们说交换机会向除接口1之外的所有接口广播A发出的那一帧，C跟D收到之后将会丢弃这个帧，因为目的地址与他们的MAC地址不符，只有B会收下这一帧。这种机制也称为过滤。</p><p>那么经过一段时间，交换机会把所有发送过数据的主机的MAC地址与对应接口号记录下来，这样交换表中的表项就齐全了，要转发给任何一台主机的帧都能很快的在交换表中找到相对应的转发接口。</p><h3 id="四、实验步骤"><a href="#四、实验步骤" class="headerlink" title="四、实验步骤"></a>四、实验步骤</h3><p><strong>在模拟器中画出拓扑图，查看思科交换机MAC地址表，并观察交换机进行地质自学习的过程</strong></p><p>一、先画出如下拓扑图：</p><p><img src="/../images/clip_image002.jpg" alt="img"></p><p>然后设置每台PC的IP地址，可单击PC，在弹出的对话框中设置：</p><p><img src="/../images/clip_image004.jpg" alt="img"></p><p>单击交换机，选择CLI标签，在命令行中输入：</p><pre><code class="shell">在Switch&gt;后面输入en（或enable），进入特权模式。然后在Switch#后输入show mac-address-table此时地址表里有可能是空的，也有可能已经有记录了，如果有记录了，请使用清除命令清空地址表。Switch#clear mac-address-table此时再查看，Switch#show mac-address-table应该已经清空了。</code></pre><p>下面单击任何一个PC，选择Desktop 标签的Command Prompt命令：</p><p><img src="/../images/clip_image006.jpg" alt="img"></p><p><img src="/../images/clip_image008.jpg" alt="img"></p><p>Ping 10.0.0.2后如上图所示，代表可以ping通，此时进入交换机，查看mac地址表</p><p>看一下有什么变化。</p><p>再ping另外两台PC，每次ping完，观察地址表的变化。</p><p>观察时，注意mac地址以及端口号，思考一下分别都是哪些PC的？</p><p><img src="/../images/clip_image010.gif" alt="img"></p><p>二、再画出如下拓扑图：</p><p><img src="/../images/clip_image012.gif" alt="img"></p><p>在PC0上ping PC1，观察switch0和switch1中地址表的变化。</p><p>再用PC0去ping PC7，以及PC6 去ping PC0，分别观察两个路由器中地址表的变化，记录变化过程。</p><h3 id="五、实验报告要求"><a href="#五、实验报告要求" class="headerlink" title="五、实验报告要求"></a>五、实验报告要求</h3><p>1．练习使用Cisco Packet Tracer 画出网络拓扑结构图，按照实验步骤完成交换机自学习的实验内容，并截屏+文字记录相关步骤，说明交换机进行地址自学习的过程。 </p><p>提交word文档，文件名为：学号姓名实验五。先不交，与后续交换机实验报告一起交。</p><p> 我先配置设备以及ip地址，我使用pc0来ping pc1，会生成mac表中的一部分</p><p><img src="/../images/image-20231107145502375.png" alt="image-20231107145502375"></p><p>使用pc1 去ping pc2，我把交换机1口连接到pc3, 3口连接到集线器</p><p><img src="/../images/image-20231107145847512.png" alt="image-20231107145847512"></p><p>如图配置所有的设备以及ip地址</p><p><img src="/../images/image-20231107151718970.png" alt="image-20231107151718970"></p><p>地址192.168.1.1 ping 192.168.1.2 </p><p><img src="/../images/image-20231107151823565.png" alt="image-20231107151823565"></p><p>但是右边的并没有更改table</p><p><img src="/../images/image-20231107151948284.png" alt="image-20231107151948284"></p><p>采用192.168.1.1来ping192.1681.1.8后</p><p><img src="/../images/image-20231107152143513.png!%5Bimage-20231107152154886%5D(../images/image-20231107152154886.png"></p><p><img src="/../images/image-20231107152215602.png" alt="image-20231107152215602"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络cisco交换机基本配置</title>
      <link href="/2023/11/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9Ccisco%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/"/>
      <url>/2023/11/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9Ccisco%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="实验四-交换机的基本配置"><a href="#实验四-交换机的基本配置" class="headerlink" title="实验四 交换机的基本配置"></a>实验四 交换机的基本配置</h1><h3 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a>一、实验目的</h3><p>1.了解交换机的作用。</p><p>2.掌握交换机的基本配置方法。</p><p>3.熟悉Cisco Packet Tracer的使用。</p><h3 id="二、实验内容"><a href="#二、实验内容" class="headerlink" title="二、实验内容"></a>二、实验内容</h3><p>1．以星型结构为例，练习使用Cisco Packet Tracer画出网络拓扑图。</p><p>2．掌握交换机的基本配置模式，练习交换机的基本配置命令。</p><h3 id="三、实验原理"><a href="#三、实验原理" class="headerlink" title="三、实验原理"></a>三、实验原理</h3><p>1．交换机的基本配置模式：</p><p>常见的配置模式有：用户模式、特权模式、全局配置模式、接口配置模式、VLAN配置模式和访问配置模式。</p><p><strong>用户模式</strong>：switch&gt;   一旦与交换机建立连接，就进入了用户模式。在这种模式下，只能查看网络设备的运行状态和简单的统计信息。</p><p><strong>特权模式</strong>：Switch#   在该模式下可为交换机设置账号和密码。</p><p>进入方法：在默认的用户模式下输入：enable 进入。</p><p>退出方法：输：exit 退回到用户模式。</p><p>注意用户模式和特权模式的前面代码的区别：一个是switch&gt;；一个是Switch#。</p><p><strong>全局配置模式</strong>：(config)#   在该模式下可对交换机的全局参数进行配置。</p><p>进入方法：在特权模式下，使用命令“configure terminal（或者简写成conf t）”</p><p><strong>接口配置模式</strong>：(config-if)#   在该模式下，仅对该接口的参数进行配置</p><p>进入方法：在全局配置模式下，使用命令“interface 接口名</p><p><strong>VLAN配置模式</strong>：(config-vlan)#</p><p>进入方法：在全局配置模式下输入 vlan database 进入</p><p><strong>访问配置模式：</strong>(config-line)#</p><p>进入方法：在全局配置模式下输入line vty 线路编号 进入</p><p>备注：</p><p>1）在任何模式下，用户在输入命令时，不用全部将其输入，只要前几个字母能够唯一标识该命令即可，此时按Tab键将显示全称。</p><p>如：interface serial 0/1可以写成：int s0/1</p><p>2）在任何模式下，输入一个“？”即可显示所有在该模式下的命令。</p><p>3）如果不会拼写某个命令，可以键入开始的几个字母，在其后紧跟一个“？”，交换机即显示有什么样的命令与其匹配。</p><p>4）如果不知道命令后面的参数应该是什么，可以在该命令的关键字后加一个空格，键入“？”，交换机即会提示与“？”对应的参数是什么，例如：Switch#show ？</p><p>5）要删除某条配置命令，可在原配置命令前加一个no和空格。</p><p>6）退回上一层模式用“exit”，退回到特权模式用“end”</p><p>7）查看交换机配置文件信息用==show startup-config==，查看当前所有配置信息用==show running-config==。保存当前配置用==copy running-config startup-config==（若没保存，重启后配置丢失）。重启交换机用reload命令。这些命令需要在特权模式下输入。</p><p>2．配置交换机(网管型交换机)，首先要把交换机和电脑连接，连接方法是用专门的Console线连接交换机的Console端口和计算机的COM口。现在电脑如果没有COM口，用RS232转USB数据线即可。</p><p>可进行网络管理的交换机上一般都有一个“Console”端口，它是专门用于对交换机进行配置和管理的。通过Console端口连接并配置交换机，是配置和管理交换机必须经过的步骤。因为其他方式的配置往往需要借助于IP地址、域名或设备名称才可以实现，而新购买的交换机显然不可能内置有这些参数，所以Console端口是最常用、最基本的交换机管理和配置端口。</p><p>Console线也分为两种，一种是串行线，即两端均为串行接口(两端均为母头或一端为公头，另一端为母头)，两端可以分别插入至计算机的串口和交换机的Console端口;另一种是两端均为RJ-45接头(RJ-45-to-RJ-45)的扁平线。</p><p>硬件连接好了，就要进行软件配置，安装Console数据线的驱动，并使用系统自带的仿真终端软件，设置好波特率、数据位等信息后，通过交换机的出厂默认用户名和密码就可以登陆交换机。</p><h3 id="四、实验步骤"><a href="#四、实验步骤" class="headerlink" title="四、实验步骤"></a>四、实验步骤</h3><p>在模拟器中构建一个如下图所示的网络拓扑图，PC0和PC1使用直通线与交换就的f0/1口和f0/2口相连，PC3使用RS232接口通过Console线缆与交换机的Console接口连接。配置每个PC的IP地址如下图所示，子网掩码都为255.255.255.0。</p><p><img src="/../images/clip_image002.gif" alt="说明: C:\Users\LZ\AppData\Local\Temp\1603173757(1).png"></p><p>1）连接到交换机</p><p>对交换机的第一次配置，要在PC3的配置窗口的Desktop选项卡下，选择Terminal，打开下图所示对话框，</p><p><img src="/../images/clip_image004.gif" alt="说明: C:\Users\LZ\AppData\Local\Temp\1603174148(1).png"></p><p>按下OK键开始进入交换机的配置。</p><p>也可以直接单击交换机，点击CLI标签进行配置。</p><p>请输入以下命令，思考并练习。</p><p>2）修改交换机的名称</p><pre><code class="shell">Switch&gt;                         用户模式Switch&gt;enable                      enable进入特权模式Switch#config terminal                   进入全局配置模式Switch(config)#hostname SW                设置交换机名称为SW</code></pre><p>3）设置口令</p><pre><code class="shell">SW(config)#enable password cisco              设置使能口令ciscoSW(config)#enable secret cisco1                设置使能密码cisco1SW(config)#line vty 0 4             开启5个vty会话线路，线路编号为0-4SW(config-line)#password ptxy         设置远程登录密码SW(config-line)#login             设置在远程登录时用密码验证SW(config-line)#end              保存并退出</code></pre><p>注：enable password在交换机的配置文件中以明文形式存储；而enable secret以密文形式存储如果同时设置两个口令，则只有enable secret有效，为了安全起见，通常只配置enable secret。</p><p>当需要远程登录（如TELNET）管理交换机时，必须有line vty 0 4开始的这三行命令，line vty 0 4表示开启0-4共5条远程终端会话线路，password ptxy设置远程登录密码，login这里如果写成no login，则远程登录时不需要密码。</p><p>4）配置交换机的管理IP地址和默认网关</p><p>交换机完成首次配置后，后期可能需要通过TELNET等方式对其进行远程管理，这时就需要设置交换机的IP地址和默认网关等管理信息，具体命令如下：</p><pre><code class="shell">SW&gt;enPassword:                  输入前面设置的使能密码cisco1SW#conf tSW(config)#interface vlan1           进入VLAN1虚拟接口配置模式SW(config-if)#ip address 192.168.1.8 255.255.255.0    设置交换机的IP地址与子网掩码SW(config-if)#no shutdown              激活该接口SW(config-if)#exit                  返回到上一层模式SW(config)#ip default-gateway 192.168.1.8        设置交换机默认网关SW(config)#endSW#</code></pre><p>此时，在PC0或PC1的配置窗口的Desktop选项卡下，打开Command Prompt窗口，输入命令telnet 192.168.1.8，当提示要输密码时，输入前面设置的远程登录密码就成功连接到了交换机。</p><h3 id="五、实验报告要求"><a href="#五、实验报告要求" class="headerlink" title="五、实验报告要求"></a>五、实验报告要求</h3><p>1．练习使用Cisco Packet Tracer 画出网络拓扑结构图，掌握交换机的基本配置模式，练习交换机的基本配置命令，并截屏+文字记录相关步骤。提交word文档，文件名为：学号姓名实验四。先不交，与后续交换机实验报告一起交。</p><p><img src="/../images/image-20231107142742550.png" alt="image-20231107142742550"></p><p> <img src="/../images/image-20231107142901504.png" alt="image-20231107142901504"></p><pre><code class="shell">version 12.1no service timestamps log datetime msecno service timestamps debug datetime msecno service password-encryption!hostname SW!enable secret 5 $1$mERr$q.MA2tj.WFptzvbifq/1i.enable password cisco!!spanning-tree mode pvst!interface FastEthernet0/1!interface FastEthernet0/2!interface FastEthernet0/3!interface FastEthernet0/4!interface FastEthernet0/5!interface FastEthernet0/6!interface FastEthernet0/7!interface FastEthernet0/8!interface FastEthernet0/9!interface FastEthernet0/10!interface FastEthernet0/11!interface FastEthernet0/12!interface FastEthernet0/13!interface FastEthernet0/14!interface FastEthernet0/15!interface FastEthernet0/16!interface FastEthernet0/17!interface FastEthernet0/18!interface FastEthernet0/19!interface FastEthernet0/20!interface FastEthernet0/21!interface FastEthernet0/22!interface FastEthernet0/23!interface FastEthernet0/24!interface Vlan1 no ip address shutdown!!line con 0!line vty 0 4 password ptxy loginline vty 5 15 login!!</code></pre><pre><code class="bash">version 12.1: 这一行指定了配置文件所使用的Cisco IOS软件的版本。no service timestamps log datetime msec 和 no service timestamps debug datetime msec: 这两行命令禁用了日志和调试信息中的时间戳，并且不包括毫秒级别的时间信息。这可以使日志文件更加简洁。no service password-encryption: 这一行命令禁用了密码加密。通常情况下，Cisco设备会对配置中的密码进行加密存储，但这个命令会取消加密，以便在配置文件中明文显示密码。hostname SW: 这一行命令设置了设备的主机名为 "SW"，这是设备的标识符。enable secret 5 $1$mERr$q.MA2tj.WFptzvbifq/1i.: 这一行设置了特权模式的密码，这是用于访问设备特权模式的密码。密码是加密的，以提高安全性。密码的实际值是 "11mERr$q.MA2tj.WFptzvbifq/1i."。enable password cisco: 这一行设置了备用的特权模式密码，如果启用密码被忘记，可以使用这个密码来访问特权模式。不像前面的密码，这个密码以明文形式存储在配置中。spanning-tree mode pvst: 这一行命令配置了Spanning Tree Protocol (STP) 的模式为Per-VLAN Spanning Tree (PVST)。PVST是Cisco的STP实现，允许每个VLAN都有自己的STP实例，以提高网络的冗余性和可靠性。接口配置部分: 这一部分包括了多个FastEthernet接口（FastEthernet0/1 到 FastEthernet0/24）。在这个示例中，这些接口没有配置IP地址或其他参数，因此它们可能是未配置的接口或者处于交换机模式。interface Vlan1: 这一行配置了VLAN 1 接口，但没有分配IP地址，并将接口关闭（shutdown）。通常情况下，VLAN 1 用于管理目的，但在这个配置中，它被禁用了。line con 0 和 line vty 0 4 配置了控制台和虚拟终端（Telnet或SSH）的访问。它们分别设置了密码（控制台密码为 "ptxy"）和允许登录。line vty 5 15 配置了更多的虚拟终端线路，允许更多的远程Telnet或SSH会话。</code></pre><p>最后在交换机这里进行配置，让他可以被远程的telnet</p><p><img src="/../images/image-20231107144113020.png" alt="image-20231107144113020"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P1006 [NOIP2008 提高组] 传纸条</title>
      <link href="/2023/11/06/P1006-NOIP2008-%E6%8F%90%E9%AB%98%E7%BB%84-%E4%BC%A0%E7%BA%B8%E6%9D%A1/"/>
      <url>/2023/11/06/P1006-NOIP2008-%E6%8F%90%E9%AB%98%E7%BB%84-%E4%BC%A0%E7%BA%B8%E6%9D%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="NOIP2008-提高组-传纸条"><a href="#NOIP2008-提高组-传纸条" class="headerlink" title="[NOIP2008 提高组] 传纸条"></a>[NOIP2008 提高组] 传纸条</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>小渊和小轩是好朋友也是同班同学，他们在一起总有谈不完的话题。一次素质拓展活动中，班上同学安排坐成一个 $m$ 行 $n$ 列的矩阵，而小渊和小轩被安排在矩阵对角线的两端，因此，他们就无法直接交谈了。幸运的是，他们可以通过传纸条来进行交流。纸条要经由许多同学传到对方手里，小渊坐在矩阵的左上角，坐标 $(1,1)$，小轩坐在矩阵的右下角，坐标 $(m,n)$。从小渊传到小轩的纸条只可以向下或者向右传递，从小轩传给小渊的纸条只可以向上或者向左传递。</p><p>在活动进行中，小渊希望给小轩传递一张纸条，同时希望小轩给他回复。班里每个同学都可以帮他们传递，但只会帮他们一次，也就是说如果此人在小渊递给小轩纸条的时候帮忙，那么在小轩递给小渊的时候就不会再帮忙。反之亦然。</p><p>还有一件事情需要注意，全班每个同学愿意帮忙的好感度有高有低（注意：小渊和小轩的好心程度没有定义，输入时用 $0$ 表示），可以用一个 $[0,100]$ 内的自然数来表示，数越大表示越好心。小渊和小轩希望尽可能找好心程度高的同学来帮忙传纸条，即找到来回两条传递路径，使得这两条路径上同学的好心程度之和最大。现在，请你帮助小渊和小轩找到这样的两条路径。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行有两个用空格隔开的整数 $m$ 和 $n$，表示班里有 $m$ 行 $n$ 列。</p><p>接下来的 $m$ 行是一个 $m \times n$ 的矩阵，矩阵中第 $i$ 行 $j$ 列的整数表示坐在第 $i$ 行 $j$ 列的学生的好心程度。每行的 $n$ 个整数之间用空格隔开。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出文件共一行一个整数，表示来回两条路上参与传递纸条的学生的好心程度之和的最大值。</p><h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><pre><code>3 30 3 92 8 55 7 0</code></pre><h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><pre><code>34</code></pre><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p><strong>【数据范围】</strong></p><p>对于 $30%$ 的数据，满足 $1 \le m,n \le 10$。<br>对于 $100%$ 的数据，满足 $1 \le m,n \le 50$。</p><p><strong>【题目来源】</strong></p><p>NOIP 2008 提高组第三题。</p><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>类似于走两条路取最大，使用的是四维的数组来进行，ij表示第一个路径，kl表示第二个路径，不能走两次，也就是走一次之后会使得好感度为0。</p><p>ac代码：</p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include &lt;queue&gt;#define LL long long#define endl "\n"#define int long long#define rg register#define pli pair&lt;LL,int&gt;#define pil pair&lt;int,LL&gt;#define debug(x) std:: cout &lt;&lt; "---DEBUG--- " &lt;&lt; x &lt;&lt; " -----DEBUG----\n"#define rep(a,b,c) for(int i = a; i &lt; b; i += c)#define repr(a,b,c) for(int i = a; i &gt; b; i -= c)using namespace std;int a[100][100];int dp[56][59][56][56];signed main() {    int n;    int m;    cin &gt;&gt; n &gt;&gt; m;    for(int i = 1; i &lt;= n; i++){        for(int j = 1; j &lt;= m; j++){            cin &gt;&gt; a[i][j];        }    }    for(int i = 1; i &lt;= n; i++){        for(int j = 1; j &lt;= m; j++){            for(int k = 1; k &lt;= n; k++){                for(int l = 1; l &lt;= m; l++){                    dp[i][j][k][l] = max(                                         max(dp[i-1][j][k-1][l], dp[i][j-1][k-1][l]),                                         max(dp[i-1][j][k][l-1], dp[i][j-1][k][l-1]))                                         + a[i][j] + a[k][l];                    if(i == k &amp;&amp; j == l) dp[i][j][k][l] -= a[i][j];                }            }        }    }    cout &lt;&lt; dp[n][m][n][m];    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P1004 [NOIP2000 提高组] 方格取数解析</title>
      <link href="/2023/11/06/P1004-NOIP2000-%E6%8F%90%E9%AB%98%E7%BB%84-%E6%96%B9%E6%A0%BC%E5%8F%96%E6%95%B0%E8%A7%A3%E6%9E%90/"/>
      <url>/2023/11/06/P1004-NOIP2000-%E6%8F%90%E9%AB%98%E7%BB%84-%E6%96%B9%E6%A0%BC%E5%8F%96%E6%95%B0%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="NOIP2000-提高组-方格取数"><a href="#NOIP2000-提高组-方格取数" class="headerlink" title="[NOIP2000 提高组] 方格取数"></a>[NOIP2000 提高组] 方格取数</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>设有 $N \times N$ 的方格图 $(N \le 9)$，我们将其中的某些方格中填入正整数，而其他的方格中则放入数字 $0$。如下图所示（见样例）:</p><p><img src="/../images/zj4bo91w.png"></p><p>某人从图的左上角的 $A$ 点出发，可以向下行走，也可以向右走，直到到达右下角的 $B$ 点。在走过的路上，他可以取走方格中的数（取走后的方格中将变为数字 $0$）。<br>此人从 $A$ 点到 $B$ 点共走两次，试找出 $2$ 条这样的路径，使得取得的数之和为最大。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入的第一行为一个整数 $N$（表示 $N \times N$ 的方格图），接下来的每行有三个整数，前两个表示位置，第三个数为该位置上所放的数。一行单独的 $0$ 表示输入结束。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>只需输出一个整数，表示 $2$ 条路径上取得的最大的和。</p><h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><pre><code>82 3 132 6  63 5  74 4 145 2 215 6  46 3 157 2 140 0  0</code></pre><h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><pre><code>67</code></pre><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>NOIP 2000 提高组第四题</p><p>使用四维的dp，因为这里来说，可以ij当做第一次走过到了的点，kl当做第二次走过到了的点，所以就是</p><pre><code class="c++">dp[i][j][k][l] = //最大值dp[i-1][j][k-1][l]dp[i][j-1][k-1][l]dp[i-1][j][k][l-1]dp[i][j-1][k][l-1]//加上本身所到了的a[i][j],a[k][l]//如果两个是一样的位置，那么只要加一次</code></pre><p>ac代码如下：</p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include &lt;queue&gt;#define LL long long#define endl "\n"#define int long long#define rg register#define pli pair&lt;LL,int&gt;#define pil pair&lt;int,LL&gt;#define debug(x) std:: cout &lt;&lt; "---DEBUG--- " &lt;&lt; x &lt;&lt; " -----DEBUG----\n"#define rep(a,b,c) for(int i = a; i &lt; b; i += c)#define repr(a,b,c) for(int i = a; i &gt; b; i -= c)using namespace std;int m[100][100];int dp[50][59][50][50];signed main() {    int n;    int a, b, c;    cin &gt;&gt; n;    while(cin &gt;&gt; a &gt;&gt; b &gt;&gt; c){        if(a == b &amp;&amp; a == 0) break;        m[a][b] = c;    }    for(int i = 1; i &lt;= n; i++){        for(int j = 1; j &lt;= n; j++){            for(int k = 1; k &lt;= n; k++){                for(int l = 1; l &lt;= n; l++){                    dp[i][j][k][l] = max(                                         max(dp[i-1][j][k-1][l], dp[i][j-1][k-1][l]),                                         max(dp[i-1][j][k][l-1], dp[i][j-1][k][l-1]))                                         + m[i][j] + m[k][l];                    if(i == k &amp;&amp; j == l) dp[i][j][k][l] -= m[i][j];                }            }        }    }    cout &lt;&lt; dp[n][n][n][n];    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P1002 [NOIP2002 普及组] 过河卒解析</title>
      <link href="/2023/11/06/P1002-NOIP2002-%E6%99%AE%E5%8F%8A%E7%BB%84-%E8%BF%87%E6%B2%B3%E5%8D%92%E8%A7%A3%E6%9E%90/"/>
      <url>/2023/11/06/P1002-NOIP2002-%E6%99%AE%E5%8F%8A%E7%BB%84-%E8%BF%87%E6%B2%B3%E5%8D%92%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="NOIP2002-普及组-过河卒"><a href="#NOIP2002-普及组-过河卒" class="headerlink" title="[NOIP2002 普及组] 过河卒"></a>[NOIP2002 普及组] 过河卒</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>棋盘上 $A$ 点有一个过河卒，需要走到目标 $B$ 点。卒行走的规则：可以向下、或者向右。同时在棋盘上 $C$ 点有一个对方的马，该马所在的点和所有跳跃一步可达的点称为对方马的控制点。因此称之为“马拦过河卒”。</p><p>棋盘用坐标表示，$A$ 点 $(0, 0)$、$B$ 点 $(n, m)$，同样马的位置坐标是需要给出的。</p><p><img src="/../images/f3wwgqj6.png"></p><p>现在要求你计算出卒从 $A$ 点能够到达 $B$ 点的路径的条数，假设马的位置是固定不动的，并不是卒走一步马走一步。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>一行四个正整数，分别表示 $B$ 点坐标和马的坐标。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个整数，表示所有的路径条数。</p><h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><pre><code>6 6 3 3</code></pre><h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><pre><code>6</code></pre><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>对于 $100 %$ 的数据，$1 \le n, m \le 20$，$0 \le$ 马的坐标 $\le 20$。</p><p><strong>【题目来源】</strong></p><p>NOIP 2002 普及组第四题</p><p>分析得知可以按照递推的方式向后做，因为没有向前的可以影响的。</p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include &lt;queue&gt;#define LL long long#define endl "\n"#define int long long#define rg register#define pli pair&lt;LL,int&gt;#define pil pair&lt;int,LL&gt;#define debug(x) std:: cout &lt;&lt; "---DEBUG--- " &lt;&lt; x &lt;&lt; " -----DEBUG----\n"#define rep(a,b,c) for(int i = a; i &lt; b; i += c)#define repr(a,b,c) for(int i = a; i &gt; b; i -= c)using namespace std;int dp[50][59];signed main() {    int n, m;    int a, b;    cin &gt;&gt; n &gt;&gt; m;    cin &gt;&gt; a &gt;&gt; b;    n++,m++,a++,b++;    int x[10], y[10];    x[1]=a-1;    y[1]=b-2;    x[2]=a-2;    y[2]=b-1;    x[3]=a+1;    y[3]=b-2;    x[4]=a+2;    y[4]=b-1;    x[5]=a-1;    y[5]=b+2;    x[6]=a-2;    y[6]=b+1;    x[7]=a+1;    y[7]=b+2;    x[8]=a+2;    y[8]=b+1;    x[9]=a;    y[9]=b;    dp[1][1]=1;    for(int i = 1; i &lt;= n; i++){        for(int j = 1; j &lt;= m; j++){            int flag = 1;            for(int k = 1; k &lt;= 9; k++){                if(x[k] == i &amp;&amp; y[k] == j) flag = 0;            }            if(flag == 0) continue;            dp[i][j] += dp[i][j-1] + dp[i-1][j];        }    }    cout &lt;&lt; dp[n][m];    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis使用</title>
      <link href="/2023/11/04/MyBatis%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/11/04/MyBatis%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="官方网站"><a href="#官方网站" class="headerlink" title="官方网站"></a>官方网站</h1><p><a href="https://mybatis.org/mybatis-3/zh/index.html">https://mybatis.org/mybatis-3/zh/index.html</a></p><h1 id="什么是Mybatis"><a href="#什么是Mybatis" class="headerlink" title="什么是Mybatis"></a>什么是Mybatis</h1><p>一种用于 Java 编程语言的开源持久性框架。它提供了一种将对象与数据库表进行映射的方法，允许开发人员使用面向对象的编程方式来访问和操作数据库。</p><p>MyBatis 的主要功能和特点包括：</p><ol><li><strong>对象-关系映射（ORM）</strong>：MyBatis 允许开发人员将 Java 对象和数据库表进行映射，从而避免了手动编写大量的 SQL 查询语句。这使得开发人员可以更专注于业务逻辑，而不是 SQL 语句的编写。</li><li><strong>XML 或注解配置</strong>：MyBatis 支持通过 XML 文件或注解来配置数据映射和 SQL 查询。这种配置的方式使得开发人员可以更容易地维护和修改 SQL 查询。</li><li><strong>动态 SQL</strong>：MyBatis 支持动态 SQL 查询，这意味着你可以根据不同的条件生成不同的 SQL 查询语句，而不必编写大量重复的 SQL 语句。</li><li><strong>缓存支持</strong>：MyBatis 具有内置的缓存支持，可以提高应用程序的性能，减少数据库查询的次数。</li><li><strong>自动映射</strong>：MyBatis 可以自动将查询结果映射到 Java 对象，无需手动编写映射代码。</li><li><strong>批处理</strong>：MyBatis 支持批处理操作，可以有效地处理多个数据库操作。</li><li><strong>插件支持</strong>：MyBatis 允许开发人员编写自定义插件来扩展框架的功能。</li></ol><p>MyBatis 在 Java 开发中广泛使用，特别是在与关系型数据库的交互方面。它为开发人员提供了一种直观且灵活的方法，以简化数据库访问和操作。</p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>在maven中配置,修改版本号</p><pre><code class="xml">        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;version&gt;8.0.27&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;            &lt;version&gt;3.5.7&lt;/version&gt; &lt;!-- 使用适当的版本号 --&gt;</code></pre><p>sources中的配置，修改驱动等信息，同时修改所使用的mapper对象</p><pre><code class="xml">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration  PUBLIC "-//mybatis.org//DTD Config 3.0//EN"  "https://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt;  &lt;environments default="development"&gt;    &lt;environment id="development"&gt;      &lt;transactionManager type="JDBC"/&gt;      &lt;dataSource type="POOLED"&gt;        &lt;property name="driver" value="${driver}"/&gt;        &lt;property name="url" value="${url}"/&gt;        &lt;property name="username" value="${username}"/&gt;        &lt;property name="password" value="${password}"/&gt;      &lt;/dataSource&gt;    &lt;/environment&gt;  &lt;/environments&gt;  &lt;mappers&gt;    &lt;mapper resource="org/mybatis/example/BlogMapper.xml"/&gt;  &lt;/mappers&gt;&lt;/configuration&gt;</code></pre><p>配置用户的mappers，包含sql语句等</p><pre><code class="xml">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"  "https://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="org.mybatis.example.BlogMapper"&gt;  &lt;select id="selectBlog" resultType="Blog"&gt;    select * from Blog where id = #{id}  &lt;/select&gt;&lt;/mapper&gt;</code></pre><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>MyBatis 包含一个名叫 Resources 的工具类，它包含一些实用方法，使得从类路径或其它位置加载资源文件更加容易。</p><pre><code class="java">String resource = "org/mybatis/example/mybatis-config.xml";InputStream inputStream = Resources.getResourceAsStream(resource);SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);</code></pre><p>既然有了 SqlSessionFactory，顾名思义，我们可以从中获得 SqlSession 的实例。SqlSession 提供了在数据库执行 SQL 命令所需的所有方法。你可以通过 SqlSession 实例来直接执行已映射的 SQL 语句。例如：</p><pre><code class="java">try (SqlSession session = sqlSessionFactory.openSession()) {  Blog blog = (Blog) session.selectOne("org.mybatis.example.BlogMapper.selectBlog", 101);}</code></pre><p>目录结构为resources和java同级，在main下一级</p><p><img src="/../images/image-20231104211112060.png" alt="image-20231104211112060"></p><p>使用修改后的代码如下</p><pre><code class="java">package com.example.batis;import java.io.IOException;import java.io.InputStream;import java.util.List;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;public class Test {         private int book_id;    private String book_name;    private String book_author;    private double book_price;    private int book_stock;    private String book_desc;            public Test(int book_id, String book_name, String book_author, double book_price, int book_stock,            String book_desc) {        super();        this.book_id = book_id;        this.book_name = book_name;        this.book_author = book_author;        this.book_price = book_price;        this.book_stock = book_stock;        this.book_desc = book_desc;    }        @Override    public String toString() {        return "Test [book_id=" + book_id + ", book_name=" + book_name + ", book_author=" + book_author                + ", book_price=" + book_price + ", book_stock=" + book_stock + ", book_desc=" + book_desc + "]";    }    public static void main(String[] args) throws IOException {        // TODO 自动生成的方法存根        String resource = "mybatis-config.xml";        InputStream inputStream = Resources.getResourceAsStream(resource);        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);        SqlSession sqlSession = sqlSessionFactory.openSession();        List&lt;Test&gt; list =  sqlSession.selectList("test.All");                System.out.println(list);    }}</code></pre><h1 id="配置mapper代理"><a href="#配置mapper代理" class="headerlink" title="配置mapper代理"></a>配置mapper代理</h1><p>在 MyBatis 中，你可以使用 Mapper 代理开发方式来访问数据库而不需要编写实现类，代理会根据你的映射文件执行相应的 SQL。以下是设置 Mapper 代理开发的步骤：</p><ol><li><p><strong>创建映射文件</strong>：首先，你需要创建一个 XML 映射文件，它描述了 SQL 查询、插入、更新或删除操作。这个映射文件通常包含在 MyBatis 配置文件中。</p><p>例如，这是一个简单的映射文件示例：==名称空间是包的名称中接口==</p><pre><code class="xml">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"  "https://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.example.mapper.MyMapper"&gt;  &lt;select id="selectUser" resultType="com.example.User"&gt;    SELECT * FROM users WHERE id = #{id}  &lt;/select&gt;&lt;/mapper&gt;</code></pre></li><li><p><strong>创建 Java 接口</strong>：接下来，你需要创建一个 Java 接口，该接口定义了与映射文件相对应的方法。这些方法的名称和参数应该与映射文件中的 SQL 查询操作相匹配。==方法对应的是xml中的id==</p><pre><code class="java">package com.example.mapper;import com.example.User;public interface MyMapper {    User selectUser(int id);}</code></pre></li><li><p><strong>配置 MyBatis</strong>：在 MyBatis 配置文件（通常是 <code>mybatis-config.xml</code>）中，确保已包含了映射文件的引用，如下所示：==通常使用包名==</p><pre><code class="xml">&lt;mappers&gt;  &lt;mapper resource="com/example/mapper/MyMapper.xml" /&gt;&lt;/mappers&gt;</code></pre></li><li><p><strong>使用 Mapper 代理</strong>：在你的应用程序中，你可以通过创建 <code>SqlSession</code> 并获取 Mapper 接口的代理对象来使用 Mapper 代理。然后，你可以使用该代理对象来执行映射文件中定义的方法。</p><pre><code class="java">SqlSession sqlSession = sessionFactory.openSession();MyMapper myMapper = sqlSession.getMapper(MyMapper.class);User user = myMapper.selectUser(123);</code></pre></li><li><p><strong>关闭 SqlSession</strong>：在完成操作后，不要忘记关闭 <code>SqlSession</code> 以释放资源。</p><pre><code class="java">sqlSession.close();</code></pre></li></ol><p>这样，你就可以使用 Mapper 代理开发方式与数据库交互，而无需显式实现每个 SQL 操作。Mapper 代理会根据你的接口定义和映射文件执行相应的 SQL 操作。</p><p>目录结构如下</p><p><img src="/../images/image-20231106093649924.png" alt="image-20231106093649924"></p><h1 id="结果映射"><a href="#结果映射" class="headerlink" title="结果映射"></a>结果映射</h1><p>在 XML 中使用 <code>&lt;resultMap&gt;</code> 元素是为了定制查询结果映射到对象的方式。 <code>&lt;resultMap&gt;</code> 元素通常用于 MyBatis（一个流行的 Java 持久层框架）的配置文件中，用于定义如何将查询结果映射到 Java 对象。以下是如何使用 <code>&lt;resultMap&gt;</code> 元素的示例：</p><pre><code class="xml">&lt;resultMap id="userResultMap" type="com.example.User"&gt;  &lt;!-- 指定结果集中的列到 Java 对象的属性的映射 --&gt;  &lt;result property="id" column="user_id"/&gt;  &lt;result property="username" column="username"/&gt;  &lt;result property="email" column="user_email"/&gt;&lt;/resultMap&gt;</code></pre><p>上面的示例中，<code>&lt;resultMap&gt;</code> 元素定义了一个名为 <code>userResultMap</code> 的映射，将查询结果映射到 <code>com.example.User</code> 类型的对象。它使用 <code>&lt;result&gt;</code> 元素指定了查询结果中的列与 Java 对象的属性之间的映射关系。</p><p>接下来，你可以在 SQL 查询语句中引用这个 <code>&lt;resultMap&gt;</code>，如下所示：</p><pre><code class="xml">&lt;select id="getUserById" resultMap="userResultMap"&gt;  SELECT user_id, username, user_email  FROM users  WHERE user_id = #{id}&lt;/select&gt;</code></pre><p>在上面的 <code>&lt;select&gt;</code> 元素中，通过 <code>resultMap</code> 属性指定了要使用的 <code>&lt;resultMap&gt;</code>，这将告诉 MyBatis 如何将查询结果映射到 <code>com.example.User</code> 对象。</p><p>使用 <code>&lt;resultMap&gt;</code> 元素的主要目的是为了灵活地映射查询结果，允许你将查询结果中的列映射到不同的 Java 对象属性，以及支持高级的映射配置，如复杂的嵌套对象映射等。这对于定制数据映射非常有用。</p><h1 id="引用参数"><a href="#引用参数" class="headerlink" title="引用参数"></a>引用参数</h1><p>在 MyBatis 的 XML 配置文件中，你可以定义带有参数的 SQL 语句，并在需要时引用这些参数。以下是一个示例，演示了如何在 MyBatis XML 中使用带有参数的 SQL 语句：</p><p>首先，在 MyBatis XML 配置文件中定义带有参数的 SQL 语句，你可以使用 <code>${paramName}</code> 来引用参数：</p><pre><code class="xml">&lt;mapper namespace="com.example.MyMapper"&gt;  &lt;!-- 定义带有参数的 SQL 语句 --&gt;  &lt;select id="getUserById" resultType="com.example.User"&gt;    SELECT * FROM users WHERE id = ${id}  &lt;/select&gt;&lt;/mapper&gt;</code></pre><p>在上面的示例中，<code>getUserById</code> 查询使用 <code>${id}</code> 来引用一个参数，它会匹配方法参数的名称。</p><p>接下来，你可以在 Java 代码中调用这个 SQL 语句，将参数传递给它：</p><pre><code class="java">import com.example.User;import org.apache.ibatis.annotations.Param;public interface MyMapper {    User getUserById(@Param("id") int id);}</code></pre><p>在上面的 Java 代码中，<code>@Param("id")</code> 注解指定了参数的名称，这个名称应该与 SQL 语句中的 <code>${id}</code> 匹配。</p><p>然后，你可以在应用中调用这个方法，并传递参数：</p><pre><code class="java">public class MyApp {    public static void main(String[] args) {        SqlSessionFactory sqlSessionFactory = MyBatisUtil.getSqlSessionFactory();        SqlSession session = sqlSessionFactory.openSession();        MyMapper myMapper = session.getMapper(MyMapper.class);        User user = myMapper.getUserById(1);        System.out.println(user);                session.close();    }}</code></pre><p>在上面的示例中，<code>getUserById</code> 方法接收一个参数，该参数与 SQL 语句中的 <code>${id}</code> 匹配，MyBatis 将执行 SQL 查询并将结果映射到 <code>User</code> 对象中。</p><p>这是一个简单的示例，演示了如何在 MyBatis XML 配置文件中定义带有参数的 SQL 语句，并在 Java 代码中使用它。你可以根据你的需要定义更复杂的 SQL 语句，引用多个参数，并执行各种查询和操作。</p><h1 id="下述基本使用"><a href="#下述基本使用" class="headerlink" title="下述基本使用"></a>下述基本使用</h1><p>1.首先来准备一个数据库。</p><p>2.接下来创建一个普通的 Maven 工程，不用创建 Web 工程，JavaSE 工程即可。项目创建完成后，添加 MyBatis 依赖。</p><pre><code class="xml"></code></pre><p>3.接下来，准备一个 Mapper 文件，Mapper 是用来在 MyBatis 中定义 SQL 的 XML 配置文件。</p><p>4.在 Mapper 中，定义一个简单的查询方法，根据 id 查询一个Book。</p><p>5.定义Book实现类。</p><p>6.创建 MyBatis 配置文件。</p><p><img src="/../images/image-20240128212333046.png" alt="image-20240128212333046"></p><h1 id="快速使用"><a href="#快速使用" class="headerlink" title="快速使用"></a>快速使用</h1><h2 id="maven依赖"><a href="#maven依赖" class="headerlink" title="maven依赖"></a>maven依赖</h2><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;mysql&lt;/groupId&gt;    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;    &lt;version&gt;8.0.27&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;    &lt;version&gt;3.5.7&lt;/version&gt; &lt;!-- 使用适当的版本号 --&gt;&lt;/dependency&gt;</code></pre><h2 id="mybatis配置"><a href="#mybatis配置" class="headerlink" title="mybatis配置"></a>mybatis配置</h2><pre><code class="xml">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"        "https://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt;    &lt;environments default="development"&gt;        &lt;environment id="development"&gt;&lt;!--配置信息--&gt;            &lt;transactionManager type="JDBC"/&gt;            &lt;dataSource type="POOLED"&gt;                &lt;property name="driver" value="com.mysql.cj.jdbc.Driver"/&gt;                &lt;property name="url" value="jdbc:mysql://localhost:3306/db_book"/&gt;                &lt;property name="username" value="root"/&gt;                &lt;property name="password" value="666"/&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;&lt;!-- 这里是所有的mapper写全限定名--&gt;    &lt;mappers&gt;        &lt;mapper resource="mappers/myMapper.xml"/&gt;    &lt;/mappers&gt;&lt;/configuration&gt;</code></pre><h2 id="编写相应实现类"><a href="#编写相应实现类" class="headerlink" title="编写相应实现类"></a>编写相应实现类</h2><pre><code class="java">package models;public class Bookm {    public int bookId;    public String bookName;    public String bookAuthor;    public double bookPrice;    public int bookStock;    public String bookDesc;    public int getBookId() {        return bookId;    }    public void setBookId(int bookId) {        this.bookId = bookId;    }    public String getBookName() {        return bookName;    }    public void setBookName(String bookName) {        this.bookName = bookName;    }    public String getBookAuthor() {        return bookAuthor;    }    public void setBookAuthor(String bookAuthor) {        this.bookAuthor = bookAuthor;    }    public double getBookPrice() {        return bookPrice;    }    public void setBookPrice(double bookPrice) {        this.bookPrice = bookPrice;    }    public int getBookStock() {        return bookStock;    }    public void setBookStock(int bookStock) {        this.bookStock = bookStock;    }    public String getBookDesc() {        return bookDesc;    }    public void setBookDesc(String bookDesc) {        this.bookDesc = bookDesc;    }    public Bookm(int bookId, String bookName, String bookAuthor, double bookPrice, int bookStock, String bookDesc) {        this.bookId = bookId;        this.bookName = bookName;        this.bookAuthor = bookAuthor;        this.bookPrice = bookPrice;        this.bookStock = bookStock;        this.bookDesc = bookDesc;    }    @Override    public String toString() {        return "Bookm{" +                "bookId=" + bookId +                ", bookName='" + bookName + '\'' +                ", bookAuthor='" + bookAuthor + '\'' +                ", bookPrice=" + bookPrice +                ", bookStock=" + bookStock +                ", bookDesc='" + bookDesc + '\'' +                '}' + '\n';    }}</code></pre><p>设置mapper接口供调用</p><pre><code class="java">package mapper;import models.Bookm;import java.util.List;public interface MyMapper {    List&lt;Bookm&gt; selectAllBook();    Bookm selectBook(int id);    void insertBook(Bookm bookm);}</code></pre><h2 id="设置mapper-xml实现对应"><a href="#设置mapper-xml实现对应" class="headerlink" title="设置mapper.xml实现对应"></a>设置mapper.xml实现对应</h2><pre><code class="xml">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"        "https://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="mapper.MyMapper"&gt;    &lt;resultMap id="bookResultMap" type="models.Bookm"&gt;        &lt;id property="bookId" column="book_id"/&gt;        &lt;result property="bookName" column="book_name"/&gt;        &lt;result property="bookAuthor" column="book_author"/&gt;        &lt;result property="bookPrice" column="book_price"/&gt;        &lt;result property="bookStock" column="book_stock"/&gt;        &lt;result property="bookDesc" column="book_desc"/&gt;    &lt;/resultMap&gt;        &lt;select id="selectAllBook" resultType="models.Bookm"&gt;&lt;!--        select * from books where book_id = #{id}--&gt;        select * from books    &lt;/select&gt;        &lt;select id="selectBook" resultType="models.Bookm"&gt;        select * from books where book_id = #{id}    &lt;/select&gt;        &lt;insert id="insertBook" parameterType="models.Bookm"&gt;        insert into books (book_name, book_author, book_price, book_stock, book_desc)        values(#{bookName}, #{bookAuthor},#{bookPrice},#{bookStock},#{bookDesc})    &lt;/insert&gt;    &lt;/mapper&gt;</code></pre><p>调用类</p><pre><code class="java">import config.SpringConfig;import dao.BookDao;import mapper.MyMapper;import models.Bookm;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import util.MybatisUtil;import java.io.IOException;import java.io.InputStream;import java.util.List;public class Application {    public static void main(String[] args) throws IOException {//        ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class);//        BookDao bookDao = (BookDao) ctx.getBean("bookDao");//        bookDao.func1();//        bookDao.func2();//        bookDao.func3();        //指定了 MyBatis 的配置文件的路径        String resource = "mybatis-config.xml";        //这一行通过 MyBatis 提供的 Resources 工具类，根据配置文件的路径获取对应的输入流        InputStream inputStream = Resources.getResourceAsStream(resource);        //这一行使用 SqlSessionFactoryBuilder 构建器创建了 SqlSessionFactory 对象。        //SqlSessionFactory 是 MyBatis 中的核心接口，它负责创建 SqlSession 对象，而 SqlSession 是执行 SQL 语句的关键对象。        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);        //通过 SqlSessionFactory 打开了一个 SqlSession 对象。        //SqlSession 提供了执行 SQL 语句的方法，可以进行数据库操作，包括查询、插入、更新、删除等。        SqlSession sqlSession = sqlSessionFactory.openSession();        MyMapper mapper = sqlSession.getMapper(MyMapper.class);        List&lt;Bookm&gt; bookms = mapper.selectAllBook();        if(bookms == null){            System.out.println("is null") ;        }        else{            System.out.println(bookms);        }        Bookm bookm = mapper.selectBook(1);        if(bookm == null){            System.out.println("is null");        }else{            System.out.println(bookm);        }//        bookm = new Bookm(3, "新的书", "iphan", 25.0, 10, "是个测试");//        mapper.insertBook(bookm);//        sqlSession.commit();    }}</code></pre><h1 id="CURD"><a href="#CURD" class="headerlink" title="CURD"></a>CURD</h1><h2 id="增"><a href="#增" class="headerlink" title="增"></a>增</h2><pre><code class="xml">&lt;insert id="insertBook" parameterType="models.Bookm"&gt;    insert into books (book_name, book_author, book_price, book_stock, book_desc)    values(#{bookName}, #{bookAuthor},#{bookPrice},#{bookStock},#{bookDesc})&lt;/insert&gt;</code></pre><pre><code class="java">void insertBook(Bookm bookm);</code></pre><h2 id="删"><a href="#删" class="headerlink" title="删"></a>删</h2><pre><code class="xml">&lt;delete id="deleteBookById" parameterType="int"&gt;    delete from books where book_id = #{id}&lt;/delete&gt;</code></pre><pre><code class="java">void deleteBookById(int id);</code></pre><h2 id="改"><a href="#改" class="headerlink" title="改"></a>改</h2><pre><code class="xml">&lt;update id="updateBook" parameterType="models.Bookm"&gt;    update books set book_price = #{bookPrice} where book_id = #{bookId}&lt;/update&gt;</code></pre><pre><code class="java">void updateBook(Bookm bookm);</code></pre><h2 id="查"><a href="#查" class="headerlink" title="查"></a>查</h2><pre><code class="xml">&lt;select id="selectAllBook" resultType="models.Bookm"&gt;&lt;!--        select * from books where book_id = #{id}--&gt;        select * from books    &lt;/select&gt;    &lt;select id="selectBook" resultType="models.Bookm"&gt;        select * from books where book_id = #{id}    &lt;/select&gt;</code></pre><pre><code class="java">List&lt;Bookm&gt; selectAllBook();Bookm selectBook(int id);</code></pre><h1 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h1><h2 id="1-properties"><a href="#1-properties" class="headerlink" title="1 properties"></a>1 properties</h2><p>properties 可以连接一个外部配置，比如一些配置文件在 resources 目录下添加一个 db.properties 文件作为数据库的配置文件，文件内容如下：</p><pre><code class="properties">db.username=rootdb.password=66db.driver=com.mysql.cj.jdbc.Driverdb.url=jdbc:mysql://localhost:3306/db_book</code></pre><p>然后，利用 mybatis-config.xml 配置文件中的 properties 属性，引入这个配置文件，然后在 DataSource 中使用这个配置文件，最终配置如下：</p><pre><code class="xml">&lt;configuration&gt;    &lt;properties resource="db.properties"&gt;&lt;/properties&gt;    &lt;environments default="development"&gt;        &lt;environment id="development"&gt;            &lt;transactionManager type="JDBC"/&gt;            &lt;dataSource type="POOLED"&gt;                &lt;property name="driver" value="${db.driver}"/&gt;                &lt;property name="url" value="${db.url}"/&gt;                &lt;property name="username" value="${db.username}"/&gt;                &lt;property name="password" value="${db.password}"/&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;    &lt;mappers&gt;        &lt;package name="org.javaboy.mybatis.mapper"/&gt;    &lt;/mappers&gt;&lt;/configuration&gt;</code></pre><h2 id="2-parameterType"><a href="#2-parameterType" class="headerlink" title="2 parameterType"></a>2 parameterType</h2><p>表示输入的参数类型。</p><p>在 MyBatis 中，<code>#{}</code> 和 <code>${}</code> 是两种不同的占位符语法，它们在 SQL 语句中的使用有一些区别：</p><ol><li><p><strong><code>#{}</code> 占位符：</strong></p><ul><li>使用 <code>#{}</code> 时，MyBatis 会使用预编译的方式处理参数，它会将参数值以及相应的 JDBC 类型信息传递给 JDBC 驱动，以防止 SQL 注入攻击。</li><li><code>#{}</code> 可以在 SQL 语句中插入参数值，MyBatis 会自动为参数添加适当的引号和转义特殊字符。</li></ul><p>示例：</p><pre><code class="xml">&lt;!-- 使用 #{userId} 占位符 --&gt;SELECT * FROM users WHERE user_id = #{userId}</code></pre></li><li><p><strong><code>${}</code> 占位符：</strong></p><ul><li>使用 <code>${}</code> 时，MyBatis 会直接将参数值插入 SQL 语句，不进行预编译处理。这可能导致潜在的 SQL 注入风险，因此要特别注意不要直接从用户输入中使用 <code>${}</code>。</li><li><code>${}</code> 主要用于动态拼接 SQL 片段，例如表名、列名等，而不是用于传递参数值。</li></ul><p>示例：</p><pre><code class="xml">&lt;!-- 使用 ${tableName} 占位符 --&gt;SELECT * FROM ${tableName}</code></pre></li></ol><p><strong>使用建议：</strong></p><ul><li>一般来说，推荐使用 <code>#{}</code> 占位符，特别是在涉及用户输入的情况下，以避免 SQL 注入风险。</li><li>在需要动态拼接表名、列名等情况下，可以使用 <code>${}</code>，但要确保输入是可信任的，以防止潜在的安全问题。</li></ul><p>综合来说，<code>#{}</code> 更适合用于传递参数值，而 <code>${}</code> 更适合用于动态拼接 SQL 片段。</p><h2 id="3-resultType"><a href="#3-resultType" class="headerlink" title="3 resultType"></a>3 resultType</h2><p>resultType 是返回类型，在实际开发中，如果返回的数据类型比较复杂，一般我们使用 resultMap，但是，对于一些简单的返回，使用 resultType 就够用了。</p><h2 id="4-resultMap"><a href="#4-resultMap" class="headerlink" title="4 resultMap"></a>4 resultMap</h2><p>是一种映射方式，比如java并没有User类型，但是我可以映射一个。</p><p><code>resultMap</code> 是 MyBatis 中用于映射查询结果到实体类的一种配置方式。通过 <code>resultMap</code> 可以定义如何将数据库查询的列映射到 Java 对象的属性上。通常，<code>resultMap</code> 的配置会在 XML 文件中，用于更灵活地处理复杂的映射关系。</p><p>以下是一个简单的 <code>resultMap</code> 的示例：</p><pre><code class="xml">&lt;!-- 在 XML 文件中定义 resultMap --&gt;&lt;resultMap id="userResultMap" type="User"&gt;    &lt;!-- id描述主键 --&gt;    &lt;id property="id" column="user_id"/&gt;    &lt;result property="name" column="user_name"/&gt;    &lt;result property="age" column="user_age"/&gt;    &lt;!-- 其他属性映射... --&gt;&lt;/resultMap&gt;</code></pre><p>在这个例子中，<code>userResultMap</code> 定义了如何将查询结果映射到 <code>User</code> 类型的对象。具体的映射规则包括：</p><ul><li><code>&lt;id&gt;</code>：定义主键的映射关系，其中 <code>property</code> 是 Java 对象的属性名，<code>column</code> 是数据库列名。</li><li><code>&lt;result&gt;</code>：定义普通属性的映射关系，同样包括 <code>property</code> 和 <code>column</code>。</li></ul><p>接下来，可以在 SQL 查询语句中引用这个 <code>resultMap</code>：</p><pre><code class="xml">&lt;!-- 在查询语句中引用 resultMap --&gt;&lt;select id="getUserById" resultMap="userResultMap"&gt;    SELECT * FROM users WHERE user_id = #{userId}&lt;/select&gt;</code></pre><p>在上述查询语句中，通过 <code>resultMap="userResultMap"</code> 将查询结果映射到 <code>User</code> 对象上。MyBatis 将根据 <code>resultMap</code> 中的配置，将查询结果的列值赋给相应的 Java 对象属性。</p><p><code>resultMap</code> 的使用可以提供更灵活和可读性更好的映射配置，尤其是当数据库表和 Java 对象之间存在一些不同的命名规范时。此外，<code>resultMap</code> 还支持一些高级的映射配置，例如继承、关联查询等。</p><h1 id="注解开发"><a href="#注解开发" class="headerlink" title="注解开发"></a>注解开发</h1><ol><li><p><strong><code>@Select</code>：</strong> 用于配置查询操作的 SQL 语句。</p><pre><code class="java">@Select("SELECT * FROM users WHERE id = #{userId}")User getUserById(@Param("userId") Long userId);</code></pre></li><li><p><strong><code>@Insert</code>：</strong> 用于配置插入操作的 SQL 语句。</p><pre><code class="java">@Insert("INSERT INTO users (name, age) VALUES (#{name}, #{age})")@Options(useGeneratedKeys = true, keyProperty = "id")int insertUser(User user);</code></pre></li><li><p><strong><code>@Update</code>：</strong> 用于配置更新操作的 SQL 语句。</p><pre><code class="java">@Update("UPDATE users SET name = #{name} WHERE id = #{id}")int updateUser(User user);</code></pre></li><li><p><strong><code>@Delete</code>：</strong> 用于配置删除操作的 SQL 语句。</p><pre><code class="java">@Delete("DELETE FROM users WHERE id = #{userId}")int deleteUserById(@Param("userId") Long userId);</code></pre></li><li><p><strong><code>@ResultMap</code>：</strong> 用于映射查询结果到实体类的注解，通常与 XML 中的 <code>&lt;resultMap&gt;</code> 配合使用。</p><pre><code class="java">@Select("SELECT * FROM users")@ResultMap("userResultMap")List&lt;User&gt; getAllUsers();</code></pre></li><li><p><strong><code>@Result</code>：</strong> 用于配置查询结果到实体类属性的映射关系，通常与 <code>@ResultMap</code> 配合使用。</p><pre><code class="java">@ResultMap("userResultMap")@Results({    @Result(property = "id", column = "user_id"),    @Result(property = "name", column = "user_name"),    // ...})User getUserById(@Param("userId") Long userId);</code></pre></li><li><p><strong><code>@Param</code>：</strong> 用于传递参数的注解，主要用于在 SQL 语句中引用参数。</p><pre><code class="java">@Select("SELECT * FROM users WHERE id = #{userId} AND name = #{userName}")User getUserByIdAndName(@Param("userId") Long userId, @Param("userName") String userName);</code></pre></li><li><p><strong><code>@Options</code>：</strong> 用于配置一些特定的选项，比如生成主键值。</p><pre><code class="java">@Insert("INSERT INTO users (name, age) VALUES (#{name}, #{age})")@Options(useGeneratedKeys = true, keyProperty = "id")int insertUser(User user);</code></pre></li></ol><p>这些注解用于在接口方法上配置 SQL 语句，通过 MyBatis 提供的动态 SQL 和注解，可以更灵活地进行数据库操作。同时，也可以与 XML 文件结合使用，以更好地组织和维护 SQL 语句。</p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>maven</title>
      <link href="/2023/11/04/maven/"/>
      <url>/2023/11/04/maven/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Apache Maven（通常简称为 Maven）是一个开源的项目管理和构建工具，用于构建、管理和部署Java应用程序。它提供了一种结构化的方式来管理项目的构建过程、依赖管理、文档生成和发布过程。Maven 的主要目标是提供一种一致的构建方法，减少开发人员的配置工作，以及提供自动化构建的能力。</p><p>Maven 提供了以下主要功能和特点：</p><ol><li><strong>项目结构和约定</strong>：Maven 鼓励开发者遵循一组约定，以简化项目的组织和结构。这些约定包括源代码目录、资源目录、测试目录等。</li><li><strong>依赖管理</strong>：Maven 支持管理项目的依赖关系。你可以定义项目依赖，Maven 会自动下载和管理这些依赖的库文件。这减轻了手动管理JAR文件的负担。</li><li><strong>生命周期和构建阶段</strong>：Maven 定义了一组生命周期和构建阶段，包括编译、测试、打包、部署等。开发者可以配置和执行这些构建阶段，以满足项目的需求。</li><li><strong>插件体系</strong>：Maven 使用插件来扩展其功能。它有丰富的插件生态系统，允许开发者使用现有的插件或编写自定义插件以满足特定需求。</li><li><strong>POM 文件</strong>：Maven 使用项目对象模型（Project Object Model，POM）文件来描述项目的配置信息、依赖关系和构建过程。POM 文件以 XML 格式编写。</li><li><strong>自动化构建</strong>：Maven 提供了一种自动化构建过程，可以生成项目的可执行文件、文档、测试报告等。</li><li><strong>集成测试和部署</strong>：Maven 支持集成测试和部署到不同环境的过程，有助于构建和交付可靠的应用程序。</li></ol><p>Maven 的强大功能和生态系统使其成为 Java 开发社区中最受欢迎的项目管理和构建工具之一。它有助于简化项目的构建和管理，并提高开发效率。</p><h1 id="eclipse中使用maven"><a href="#eclipse中使用maven" class="headerlink" title="eclipse中使用maven"></a>eclipse中使用maven</h1><p>新建maven项目</p><p><img src="/../images/image-20231104135249214.png" alt="image-20231104135249214"></p><ol><li><strong>maven-archetype-quickstart</strong>：<ul><li>这是一个基本的 Maven 项目模板，用于创建简单的 Java 项目。</li><li>包括了一个示例的 Java 类和一个简单的 <code>pom.xml</code> 配置文件。</li><li>适用于快速创建基本的 Java 项目。</li></ul></li><li><strong>maven-archetype-webapp</strong>：<ul><li>用于创建基本的 Web 应用程序项目，包括了一个简单的 Java Servlet 和 Web 目录结构。</li><li>适用于开发简单的 Web 应用程序。</li></ul></li><li><strong>maven-archetype-j2ee-simple</strong>：<ul><li>创建了一个简单的 Java EE 项目，包括了一个 EJB 模块和一个 WAR 模块。</li><li>适用于创建较复杂的 Java EE 项目。</li></ul></li><li><strong>maven-archetype-quickstart-jdk8</strong>：<ul><li>类似于 “maven-archetype-quickstart”，但是使用 Java 8 作为目标 JDK 版本。</li><li>适用于在 Java 8 环境下开发的项目。</li></ul></li><li><strong>maven-archetype-archetype</strong>：<ul><li>用于创建自定义 Maven “archetype” 的模板。</li><li>适用于开发自定义项目模板的高级用户。</li></ul></li></ol><p><img src="/../images/image-20231104135514615.png" alt="image-20231104135514615"></p><ol><li>**Group ID (groupId)**：Group ID 是你的项目的组织或包的唯一标识符。通常，它使用逆域名（reverse domain name）的方式来定义，例如 <code>com.example</code>。这个标识符用于区分不同的项目和组织。你可以根据你的组织或项目的实际情况来定义 Group ID。</li><li>**Artifact ID (artifactId)**：Artifact ID 是你的项目的名称标识符。它代表项目本身的名称。例如，如果你的项目是一个名为 “myapp” 的应用程序，那么 Artifact ID 可以设置为 <code>myapp</code>。</li><li>**Package (package)**：Package 是你的 Java 类的默认包名。通常，它是根据 Group ID 和 Artifact ID 自动生成的，形式为 <code>groupId.artifactId</code>。例如，如果 Group ID 是 <code>com.example</code>，Artifact ID 是 <code>myapp</code>，那么默认的包名将是 <code>com.example.myapp</code>。</li></ol><p>下面是一个示例：</p><ul><li>Group ID: <code>com.example</code></li><li>Artifact ID: <code>myapp</code></li><li>Package: <code>com.example.myapp</code></li></ul><h1 id="添加后产生错误"><a href="#添加后产生错误" class="headerlink" title="添加后产生错误"></a>添加后产生错误</h1><p><img src="/../images/image-20231104140409713.png" alt="image-20231104140409713"></p><p>这个错误是由于 Maven 无法从默认的中央仓库（<a href="https://repo.maven.apache.org/maven2%EF%BC%89%E4%B8%8B%E8%BD%BD%E6%89%80%E9%9C%80%E7%9A%84%E4%BE%9D%E8%B5%96%E9%A1%B9%EF%BC%8C%E7%89%B9%E5%88%AB%E6%98%AF%E4%B8%8E">https://repo.maven.apache.org/maven2）下载所需的依赖项，特别是与</a> Maven 插件和工具有关的依赖项。通常，这种问题可能是网络连接问题或中央仓库服务器问题导致的。</p><p>解决方法：</p><ol><li><p>打开 Eclipse。</p></li><li><p>转到 “Window” 菜单，选择 “Preferences”。</p></li><li><p>在 Preferences 窗口中，展开 “Maven” 部分，然后选择 “User Settings”。</p></li><li><p>在 “User Settings” 下，你会看到 “User Settings” 文件的路径。通常情况下，这是 <code>$USER_HOME/.m2/settings.xml</code>，其中 <code>$USER_HOME</code> 表示你的用户主目录。</p></li><li><p>打开这个文件以编辑 Maven 的设置。</p></li><li><p>在 <code>settings.xml</code> 文件中，你可以添加镜像源配置，如以下示例所示：</p><pre><code class="xml">&lt;mirrors&gt;  &lt;mirror&gt;    &lt;id&gt;aliyun-maven&lt;/id&gt;    &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;    &lt;url&gt;https://maven.aliyun.com/repository/central&lt;/url&gt;  &lt;/mirror&gt;&lt;/mirrors&gt;</code></pre><p>你可以根据你的需求添加镜像源，确保镜像源的 URL 和 <code>&lt;mirrorOf&gt;</code> 标签中的值正确。</p></li><li><p>保存 <code>settings.xml</code> 文件。</p></li></ol><p>然后，尝试重新构建你的项目，Maven 应该会使用你配置的镜像源来下载依赖项。如果 <code>settings.xml</code> 文件不存在，你可以创建一个并添加所需的配置。确保 Eclipse 中的 Maven 插件能够正确找到这个文件。</p><pre><code class="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;metadata&gt;  &lt;groupId&gt;org.jetbrains.externalAnnotations.junit&lt;/groupId&gt;  &lt;artifactId&gt;junit&lt;/artifactId&gt;  &lt;versioning&gt;    &lt;latest&gt;4.12-an1&lt;/latest&gt;    &lt;release&gt;4.12-an1&lt;/release&gt;    &lt;versions&gt;      &lt;version&gt;4.12-an1&lt;/version&gt;    &lt;/versions&gt;    &lt;lastUpdated&gt;20210416102806&lt;/lastUpdated&gt;  &lt;/versioning&gt;    &lt;mirrors&gt;  &lt;mirror&gt;    &lt;id&gt;aliyun-maven&lt;/id&gt;    &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;    &lt;url&gt;https://maven.aliyun.com/repository/central&lt;/url&gt;  &lt;/mirror&gt;  &lt;/mirrors&gt;&lt;/metadata&gt;</code></pre><p><img src="/../images/image-20231104141116493.png" alt="image-20231104141116493"></p><p>最后update本地文件</p><p><img src="/../images/image-20231104141357297.png" alt="image-20231104141357297"></p><p>测试输出helloworld</p><p><img src="/../images/image-20231104141823736.png" alt="image-20231104141823736"></p><h1 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h1><pre><code class="xml">&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;  &lt;groupId&gt;com.example&lt;/groupId&gt;  &lt;artifactId&gt;myapp&lt;/artifactId&gt;  &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;  &lt;packaging&gt;jar&lt;/packaging&gt;      &lt;name&gt;myapp&lt;/name&gt;  &lt;url&gt;http://maven.apache.org&lt;/url&gt;  &lt;properties&gt;    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;  &lt;/properties&gt;  &lt;dependencies&gt;    &lt;dependency&gt;      &lt;groupId&gt;junit&lt;/groupId&gt;      &lt;artifactId&gt;junit&lt;/artifactId&gt;      &lt;version&gt;3.8.1&lt;/version&gt;      &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt;        &lt;!-- MySQL Connector/J 8.0.27 的依赖 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;version&gt;8.0.27&lt;/version&gt;        &lt;/dependency&gt;  &lt;/dependencies&gt;&lt;/project&gt;</code></pre><p><img src="/../images/image-20231104142540115.png" alt="image-20231104142540115"></p><p>update可以看到增加了jar包</p><p>进行测试成功</p><p><img src="/../images/image-20231104144200991.png" alt="image-20231104144200991"></p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo无法显示图片的问题解决</title>
      <link href="/2023/11/04/hexo%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87%E7%9A%84%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
      <url>/2023/11/04/hexo%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87%E7%9A%84%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<p>最近发现在上传一些包含图片的md文件时不能正常的显示，于是去寻找解决办法。</p><p>md文件中插入图片的语法为<code>![]()</code></p><p>总体来说就是路径不对，无法找到正确的路径，于是更改默认的路径例如</p><p><img src="/../images/image-20231104133817100.png" alt="image-20231104133817100"></p><p>我在source文件夹下建立了images的文件夹来存储图片，但是每次都要这样写一下路径不，不是嘞。</p><p>按照typora的偏好设置，可以让他为我们自己配置这样的路径。</p><p><img src="/../images/image-20231104133941585.png" alt="image-20231104133941585"></p><p>如此一来在执行</p><pre><code>hexo generatehexo deploy</code></pre><p>即可发现成功显示图片</p><p><img src="/../images/image-20231104134052640.png" alt="image-20231104134052640"></p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MATLABQ关于灰度直方图以及一些线性非线性变换？</title>
      <link href="/2023/11/01/MATLABQ%E5%85%B3%E4%BA%8E%E7%81%B0%E5%BA%A6%E7%9B%B4%E6%96%B9%E5%9B%BE%E4%BB%A5%E5%8F%8A%E4%B8%80%E4%BA%9B%E7%BA%BF%E6%80%A7%E9%9D%9E%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2%EF%BC%9F/"/>
      <url>/2023/11/01/MATLABQ%E5%85%B3%E4%BA%8E%E7%81%B0%E5%BA%A6%E7%9B%B4%E6%96%B9%E5%9B%BE%E4%BB%A5%E5%8F%8A%E4%B8%80%E4%BA%9B%E7%BA%BF%E6%80%A7%E9%9D%9E%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>风和日丽，Q艮又来点任务，这次是让看一看图片（灰度图）的直方分布，加上来然后让这个灰度图像进行一些变换，反正今天讲的叫什么前映射后映射变换是迷迷糊糊的。</p><p>这个是编写的康可：</p><pre><code class="matlab">img = imread('C:\Users\7878\Desktop\my_image.png');img1 = imresize(img, 0.3);img1 = rgb2gray(img1);subplot(2, 2, 1);imshow(img1);subplot(2, 2, 2);imhist(img1);img2 = imadjust(img1,[0.5, 0.6], [0, 1]);subplot(2, 2, 3);imshow(img2);subplot(2, 2, 4);imhist(img2);</code></pre><p>当使用 <code>imadjust</code> 函数时，你可以指定输入图像中要拉伸到特定亮度范围的百分比，并且你可以指定输出图像中的目标亮度范围。这允许你控制亮度值的映射方式，以改变图像的对比度和亮度。</p><p>具体来说，这些参数的含义如下：</p><ol><li><code>low_in</code>：这是输入图像中要拉伸到的亮度范围的下限。它表示输入图像中亮度较低的像素值的百分比。例如，如果 <code>low_in</code> 设置为 0.2，表示将输入图像中最暗的 20% 像素值拉伸到目标范围。</li><li><code>high_in</code>：这是输入图像中要拉伸到的亮度范围的上限。它表示输入图像中亮度较高的像素值的百分比。例如，如果 <code>high_in</code> 设置为 0.8，表示将输入图像中最亮的 80% 像素值拉伸到目标范围。</li><li><code>low_out</code>：这是输出图像中的目标亮度范围的下限。它表示输出图像中最暗的像素值应该对应的亮度值。通常，它是 0，表示黑色。</li><li><code>high_out</code>：这是输出图像中的目标亮度范围的上限。它表示输出图像中最亮的像素值应该对应的亮度值。通常，它是 1，表示白色。</li></ol><p>通过调整这些参数，你可以控制输入图像中不同亮度级别的像素如何映射到输出图像中的亮度范围，从而增强或调整图像的对比度和亮度。这些参数的选择取决于你希望达到的图像效果。</p><p><img src="/../images/qg-1699076069906-1.jpg"></p>]]></content>
      
      
      
        <tags>
            
            <tag> MATLAB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于git上传文件的.gitignore</title>
      <link href="/2023/10/27/%E5%85%B3%E4%BA%8Egit%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E7%9A%84-gitignore/"/>
      <url>/2023/10/27/%E5%85%B3%E4%BA%8Egit%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E7%9A%84-gitignore/</url>
      
        <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>产生问题：由于我想上传一个Unity的项目到github，但是里面包含有大于50MB的文件，github规定了上传的文件大小，因此是不可以传上去的。</p><h1 id="方案1"><a href="#方案1" class="headerlink" title="方案1"></a>方案1</h1><p>需要git-lfs工具支持</p><h1 id="方案2"><a href="#方案2" class="headerlink" title="方案2"></a>方案2</h1><p>将大文件加入.gitignore名单</p><p>由于我在操作时已经push出现了问题，所以需要先进行</p><pre><code class="shell">git reset</code></pre><p>我在创建了该文件之后，并没有删除之前的暂存区的内容，所以每一次commit和push都有之前的大文件，最终是折腾好。</p><p>==步骤如下==</p><p>创建 <code>.gitignore</code> 文件：在你的 Git 仓库根目录下，创建一个名为 <code>.gitignore</code> 的文件。可以使用文本编辑器来创建它。</p><p>编辑 <code>.gitignore</code> 文件：在 <code>.gitignore</code> 文件中，你可以列出你希望忽略的文件、目录或模式。每一行代表一个要忽略的项。可以使用通配符来匹配多个文件或目录，如 <code>*</code> 表示任意字符，<code>/</code> 表示目录分隔符，<code>#</code> 表示注释等。</p><p>   例如，以下是一个简单的 <code>.gitignore</code> 文件的示例：</p><pre><code>gitignoreCopy code# 忽略所有 .log 文件*.log# 忽略 temp 目录/temp/# 忽略 .DS_Store 文件（通常在 macOS 系统中生成）.DS_Store</code></pre><p>保存并提交 <code>.gitignore</code> 文件：保存 <code>.gitignore</code> 文件后，将其提交到 Git 仓库中。你可以使用以下命令：</p><pre><code class="shell">git add .gitignoregit commit -m "Add .gitignore file"</code></pre><p>一旦设置了 <code>.gitignore</code> 文件，Git 将会忽略在文件中列出的文件和目录，不会将它们包括在版本历史中。</p>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MATLABQ入门关于图像的平移旋转镜像与分析</title>
      <link href="/2023/10/25/MATLABQ%E5%85%A5%E9%97%A8%E5%85%B3%E4%BA%8E%E5%9B%BE%E5%83%8F%E7%9A%84%E5%B9%B3%E7%A7%BB%E6%97%8B%E8%BD%AC%E9%95%9C%E5%83%8F%E4%B8%8E%E5%88%86%E6%9E%90/"/>
      <url>/2023/10/25/MATLABQ%E5%85%A5%E9%97%A8%E5%85%B3%E4%BA%8E%E5%9B%BE%E5%83%8F%E7%9A%84%E5%B9%B3%E7%A7%BB%E6%97%8B%E8%BD%AC%E9%95%9C%E5%83%8F%E4%B8%8E%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="MATLAB-Q根作业"><a href="#MATLAB-Q根作业" class="headerlink" title="MATLAB Q根作业"></a>MATLAB Q根作业</h1><p>今天Q根说要我完成一些作业，他还会检查其中一部分。这让我感到非常紧张和着急，我开始焦虑地写作业。</p><p>在心慌意乱的状态下，我努力扩写了每个问题，并尽量给出详细的答案。我不断提醒自己要保持专注和冷静，尽力完成作业。</p><p>时间一分一秒地过去，我试图将注意力集中在任务上，忽略掉内心的不安和压力。我意识到，即使紧张也无法改变现实，唯一的解决办法就是面对并尽力去完成作业。</p><p>逐渐地，我发现自己进入了一种工作的节奏。通过不断努力，我开始逐渐克服恐惧和焦虑，专注于解决问题和完成任务。</p><p>最终，我完成了作业，并在一半检查时交给了Q根。我深呼吸一口气，希望我的努力能够得到认可。无论结果如何，我知道我已经尽力了，并从中学到了如何应对压力和困难。</p><p>这次经历让我明白，当面临紧张和压力时，保持冷静和专注非常重要。虽然一开始感到慌乱，但通过努力和积极思考，我能够克服困难，完成任务并成长。</p><h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><p>编程：图像的平移，水平，垂直，镜像（对比你自己的和自带的），验证：旋转（调用），imageresize实现图像缩放（很多算法不同），对比两幅图像是否相同的标准psnr</p><h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><pre><code class="matlab">img = imread('C:\Users\7878\Desktop\my_image.png');img1 = imresize(img, 0.2);% 旋转angle = 45;img_rotate = imrotate(img1, angle);subplot(2,3,1);imshow(img1);% title('before rotate');subplot(2,3,2);imshow(img_rotate);% title('旋转后');img_gray = rgb2gray(img1);subplot(2,3,3);imshow(img_gray);% title('灰色');[r,c] = size(img_gray);img_dst = zeros(r,c);dx = 50;dy = 50;tras=[1 0 dx;0 1 dy;0 0 1];for i=1:r    for j=1:c        %         temp = [i;j;1];        %         temp = tras*temp;        %         x=temp(1,1);        %         y=temp(2,1);        x = i + dx;        y = j + dy;        if(x&gt;=1 &amp;&amp; x&lt;=r) &amp;&amp; (y&gt;=1 &amp;&amp; y&lt;=c)            img_dst(x,y) = img_gray(i,j);        end    endendimg_mirror = zeros(r,c);for i=1:r    for j=1:c        x = abs(r - i);        y = j;        if(x&gt;=1 &amp;&amp; x&lt;=r) &amp;&amp; (y&gt;=1 &amp;&amp; y&lt;=c)            img_mirror(x,y) = img_gray(i,j);        end    endendsubplot(2,3,4);imshow(uint8(img_mirror));% title('镜像的');subplot(2,3,5);imshow(uint8(img_dst));% title('平移后');% 水平镜像horizontal_flip = flip(img_gray, 2);% 垂直镜像vertical_flip = flip(img_gray, 1);subplot(2,3,6);imshow(vertical_flip);% 峰值信噪比% mse = sum((double(img_mirror) - double(vertical_flip)).^2, [], 'all') / numel(img_mirror);% psnr = 10 * log10((255^2) / mse);% disp(psnr);% result = psnr(img_mirror, vertical_flip);[peaksnr, snr] = psnr(uint8(img_mirror), uint8(vertical_flip));  fprintf('\n The Peak-SNR value is %0.4f', peaksnr);</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> MATLAB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git学习下的一些基本操作</title>
      <link href="/2023/10/18/git/"/>
      <url>/2023/10/18/git/</url>
      
        <content type="html"><![CDATA[<h1 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h1><pre><code class="shell">git clone [ssh]</code></pre><blockquote><p><img src="C:\Users\7878\AppData\Roaming\Typora\typora-user-images\image-20231017162915772.png" alt="image-20231017162915772"></p></blockquote><pre><code class="shell"># 执行 git status 查看整个仓库的状态git status# 使用 git add [文件名] 命令跟踪此新建文件，即把新增文件添加到暂存区，以备提交git add one.txt# 如果要撤销暂存区的修改怎么办？# 根据上图的提示，执行 git reset -- [文件名] 或者 git rm --cached [文件名] 命令即可git reset -- one.txt# 用于查看 Git 仓库中所有分支（包括本地和远程分支）详细信息的命令。git branch -avv# 执行 git commit 命令生成一个新的提交，一个必须的选项 -m 用来提供该提交的备注git commit -m 'commit one'# 执行 git log 查看提交记录，紫色框中的十六进制序列号就是提交版本号git log#  git reset --soft HEAD^ 撤销最近的一次提交，将修改还原到暂存区git reset --soft HEAD^# 因为刚才的提交操作不是基于远程仓库 origin/master 分支的最新提交版本，而是撤回了一个版本。这种情况下也是可以将本地 master 分支推送到远程仓库的，需要加一个选项 -f ，它是 --force 的简写，这就是强制推送# push 是需要联网执行的，它对远程仓库进行了修改git push -f# git reflog 命令，它会记录本地仓库所有分支的每一次版本变化git reflog# 怎么回退到 5c04 那个版本呢？可以直接执行命令 git reset --hard [版本号]# 如果记不清版本号，也可以根据上图第 3 行的信息，执行 git reset --hard HEAD@{2} 命令git reset --hard HEAD@{2}# 还想反悔，刚才还是改对了，怎么办？再执行一次即可，这次大括号里就是 1 了git reset --hard HEAD@{1}</code></pre><h1 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h1><p>有些命令的重复度极高，比如 <code>git status</code> 和 <code>git branch -avv</code> 等，Git 可以对这些命令设置别名，以便简化对它们的使用，设置别名的命令是 <code>git config --global alias.[别名] [原命令]</code>，如果原命令中有选项，需要加引号。别名是自定义的，可以随意命名，设置后，原命令和别名具有同等作用。</p><blockquote><p><img src="https://doc.shiyanlou.com/courses/uid310176-20190514-1557819719173" alt="图片描述"></p></blockquote><p>自己设置的别名要记住，也可以使用 <code>git config -l</code> 命令查看配置文件。</p><ol><li><p><strong>git fetch</strong>：</p><ul><li><code>git fetch</code> 仅仅是将远程仓库的更新下载到本地，但它不会自动合并或更新你的当前工作分支。</li><li>它会下载远程分支的最新状态，但不会影响你的本地分支，你需要手动将这些更新合并到你的分支中。</li></ul><p>使用示例：</p><pre><code class="shell">git fetch origin</code></pre></li><li><p><strong>git pull</strong>：</p><ul><li><code>git pull</code> 也从远程仓库获取更新，但它会自动将远程分支的更新合并到你的当前分支。</li><li>通常，<code>git pull</code> 相当于运行 <code>git fetch</code> 后再运行 <code>git merge</code> 来合并远程分支的更新。</li></ul><p>使用示例：</p><pre><code class="shell">git pull origin master</code></pre></li></ol><p>总之，主要区别在于自动合并。<code>git fetch</code> 用于获取远程更新，但不自动合并，而 <code>git pull</code> 用于获取远程更新并自动合并到当前分支。选择使用哪一个取决于你的工作流程和需求。如果你想手动审查和控制合并过程，可以首先运行 <code>git fetch</code>，然后手动合并。如果你想快速将远程更新合并到当前分支，可以使用 <code>git pull</code>。</p><h2 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h2><p>要查看分支信息，只需在终端中输入以下命令：</p><pre><code class="shell">git branch</code></pre><p>这将列出本地分支，当前分支将以星号标记。如果要查看远程分支，可以使用以下命令：</p><pre><code class="shell">git branch -r</code></pre><pre><code class="shell"># 执行 git branch [分支名] 可以创建新的分支git branch dev# 执行 git checkout [分支名] 切换分支git checkout dev</code></pre><p>在新的分支中创建文件然后进行提交到暂存区和版本库</p><img src="C:\Users\7878\AppData\Roaming\Typora\typora-user-images\image-20231018144722734.png" alt="image-20231018144722734" style="zoom:50%;"><p>好，新功能已经写好并提交到了版本区，现在要推送了，推送到哪里呢？正常逻辑当然要推送到远程仓库的同名分支，不过现在远程仓库里只有一个分支：</p><pre><code class="shell"># 执行 git push [主机名] [本地分支名]:[远程分支名] 即可将本地分支推送到远程仓库的分支中，通常冒号前后的分支名是相同的，如果是相同的，可以省略 :[远程分支名]，如果远程分支不存在，会自动创建git push origin dev:dev</code></pre><img src="C:\Users\7878\AppData\Roaming\Typora\typora-user-images\image-20231018145103413.png" alt="image-20231018145103413" style="zoom:50%;"><img src="C:\Users\7878\AppData\Roaming\Typora\typora-user-images\image-20231018145147990.png" alt="image-20231018145147990" style="zoom: 50%;"><p>如果再次在dev上修改并提交每次仍要输入<code>git push origin dev:dev</code>,可以像main一样将本地branch与远程branch关联</p><pre><code class="shell"># 执行这个命令 git branch -u [主机名/远程分支名] [本地分支名] 将本地分支与远程分支关联git branch -u origin/dev</code></pre><h2 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h2><pre><code class="shell"># 删除远程分支的命令：git push [主机名] --delete [远程分支名]git push origin --delete dev# 使用 git branch -D [分支名] 删除本地分支git branch -D dev</code></pre><h1 id="多人操作"><a href="#多人操作" class="headerlink" title="多人操作"></a>多人操作</h1><p>建立新的仓库，邀请参与人员</p><p>组长可以发布issue</p><p>组员克隆仓库到本地 <code>git clone </code></p><p>解决issue 在提交时 <code>git commit - m 'fix #1 this is fix one'</code></p><p><code>pull requests</code></p><p><img src="https://doc.shiyanlou.com/document-uid310176labid9824timestamp1548757171365.png" alt="此处输入图片的描述"></p><p><img src="https://doc.shiyanlou.com/document-uid310176labid9824timestamp1548757180192.png" alt="此处输入图片的描述"></p><p><img src="https://doc.shiyanlou.com/document-uid310176labid9824timestamp1548757180192.png" alt="此处输入图片的描述"></p><p><img src="https://doc.shiyanlou.com/document-uid310176labid9824timestamp1548757219135.png" alt="此处输入图片的描述"></p><p>以上就是一次完整的修改、提交、推送、提 PR、合并 PR 的过程。</p><p><strong>需要注意的一点：从 A 向 B 提 PR 后，在 PR 合并或关闭前，A 上所有新增的提交都会出现在 PR 里。</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/10/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C/"/>
      <url>/2023/10/11/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="实验四"><a href="#实验四" class="headerlink" title="实验四"></a>实验四</h1><p><strong>(1) 创建一个目录，目录名用学号命名：</strong></p><pre><code class="bash">hdfs dfs -mkdir /201612345</code></pre><p><strong>(2) 查看该目录是否成功创建：</strong></p><pre><code class="bash">hdfs dfs -ls /</code></pre><p><strong>(3) 创建一个文本文件并上传到HDFS：</strong></p><pre><code class="bash">echo "hello hdfs" &gt; /usr/local/hadoop/zhangsan.txthdfs dfs -put /usr/local/hadoop/zhangsan.txt /201612345/</code></pre><p><strong>(4) 将该文件上传到HDFS的学号目录中：</strong></p><p>这已经在第三步中完成。</p><p><strong>(5) 查看该文件是否成功上传到HDFS中：</strong></p><pre><code class="bash">hdfs dfs -ls /201612345</code></pre><p><strong>(6) 将该文件从HDFS下载到本地目录：</strong></p><pre><code class="bash">hdfs dfs -get /201612345/zhangsan.txt /home/hadoop/downloads/</code></pre><p><strong>(7) 将该文件从学号目录中拷贝到input目录中，并查看是否拷贝成功：</strong></p><pre><code class="bash">hdfs dfs -cp /201612345/zhangsan.txt /input/</code></pre><p><strong>(8) 在HDFS中将该文件从学号目录中删除：</strong></p><pre><code class="bash">hdfs dfs -rm /201612345/zhangsan.txt</code></pre><p><strong>(9) 在HDFS中将学号目录删除：</strong></p><pre><code class="bash">hdfs dfs -rmdir /201612345</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>yhcsb</title>
      <link href="/2023/10/10/yhcsb/"/>
      <url>/2023/10/10/yhcsb/</url>
      
        <content type="html"><![CDATA[<p><img src="E:\hexo\1PHAN-7878.github.io\source\images\fengjing.jpg" alt="fengjing"></p>]]></content>
      
      
      
        <tags>
            
            <tag> yu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/09/22/java/"/>
      <url>/2023/09/22/java/</url>
      
        <content type="html"><![CDATA[<h1 id="1-基本语法"><a href="#1-基本语法" class="headerlink" title="1 基本语法"></a>1 基本语法</h1><h2 id="1-1-String"><a href="#1-1-String" class="headerlink" title="1.1 String"></a>1.1 String</h2><p>在Java中，<code>String</code> 类是用于表示字符串的类，它提供了丰富的方法和功能来操作字符串。字符串是一组字符的序列，而在Java中，字符串是不可变的，这意味着一旦创建了字符串，就不能更改其内容。</p><p>以下是一些常用的 <code>String</code> 类的用法和示例：</p><h3 id="1-创建字符串"><a href="#1-创建字符串" class="headerlink" title="1. 创建字符串"></a>1. 创建字符串</h3><p>可以通过直接赋值或使用构造函数创建字符串对象：</p><pre><code class="java">String str1 = "Hello, World!";  // 使用直接赋值创建字符串String str2 = new String("Hello, World!");  // 使用构造函数创建字符串</code></pre><h3 id="2-获取字符串长度"><a href="#2-获取字符串长度" class="headerlink" title="2. 获取字符串长度"></a>2. 获取字符串长度</h3><p>可以使用 <code>length()</code> 方法获取字符串的长度：</p><pre><code class="java">String str = "Hello, World!";int length = str.length();  // 获取字符串长度System.out.println("Length of the string: " + length);</code></pre><h3 id="3-拼接字符串"><a href="#3-拼接字符串" class="headerlink" title="3. 拼接字符串"></a>3. 拼接字符串</h3><p>可以使用 <code>+</code> 运算符或 <code>concat()</code> 方法将多个字符串拼接在一起：</p><pre><code class="java">String str1 = "Hello, ";String str2 = "World!";String result = str1 + str2;  // 使用 + 运算符拼接字符串// 或者使用 concat() 方法String result = str1.concat(str2);System.out.println("Concatenated string: " + result);</code></pre><h3 id="4-字符串比较"><a href="#4-字符串比较" class="headerlink" title="4. 字符串比较"></a>4. 字符串比较</h3><p>可以使用 <code>equals()</code> 方法或 <code>compareTo()</code> 方法比较字符串：</p><pre><code class="java">String str1 = "hello";String str2 = "Hello";boolean isEqual = str1.equals(str2);  // 使用 equals() 比较字符串int comparison = str1.compareTo(str2);  // 使用 compareTo() 比较字符串</code></pre><h3 id="5-提取子字符串"><a href="#5-提取子字符串" class="headerlink" title="5. 提取子字符串"></a>5. 提取子字符串</h3><p>可以使用 <code>substring()</code> 方法从字符串中提取子串：</p><pre><code class="java">String str = "Hello, World!";String subStr = str.substring(7);  // 提取从位置7开始的子串System.out.println("Substring: " + subStr);</code></pre><h3 id="6-查找子字符串"><a href="#6-查找子字符串" class="headerlink" title="6. 查找子字符串"></a>6. 查找子字符串</h3><p>可以使用 <code>indexOf()</code> 方法或 <code>contains()</code> 方法查找子字符串是否存在：</p><pre><code class="java">String str = "Hello, World!";int index = str.indexOf("World");  // 查找子串的位置boolean contains = str.contains("Hello");  // 检查是否包含子串</code></pre><h2 id="1-2-StringBuilder"><a href="#1-2-StringBuilder" class="headerlink" title="1.2 StringBuilder"></a>1.2 StringBuilder</h2><p>在Java中，<code>StringBuilder</code> 是一个用于处理可变字符串的类。与 <code>String</code> 不同，<code>StringBuilder</code> 允许你在不创建新对象的情况下修改字符串的内容，这对于频繁的字符串拼接操作非常高效。以下是一些使用 <code>StringBuilder</code> 的常见方法和示例：</p><h3 id="1-创建-StringBuilder-对象"><a href="#1-创建-StringBuilder-对象" class="headerlink" title="1. 创建 StringBuilder 对象"></a>1. 创建 <code>StringBuilder</code> 对象</h3><p>可以使用构造函数创建一个 <code>StringBuilder</code> 对象：</p><pre><code class="java">StringBuilder sb = new StringBuilder(); // 创建一个空的 StringBuilder 对象</code></pre><p>你也可以在构造函数中传入一个初始字符串：</p><pre><code class="java">StringBuilder sb = new StringBuilder("Hello"); // 创建包含初始字符串 "Hello" 的 StringBuilder 对象</code></pre><h3 id="2-追加字符串"><a href="#2-追加字符串" class="headerlink" title="2. 追加字符串"></a>2. 追加字符串</h3><p>可以使用 <code>append()</code> 方法来追加字符串到 <code>StringBuilder</code> 对象：</p><pre><code class="java">StringBuilder sb = new StringBuilder("Hello");sb.append(", World!"); // 追加字符串</code></pre><h3 id="3-插入字符串"><a href="#3-插入字符串" class="headerlink" title="3. 插入字符串"></a>3. 插入字符串</h3><p>使用 <code>insert()</code> 方法可以在指定位置插入字符串：</p><pre><code class="java">StringBuilder sb = new StringBuilder("Hello");sb.insert(5, " Java"); // 在位置5插入字符串</code></pre><h3 id="4-删除字符"><a href="#4-删除字符" class="headerlink" title="4. 删除字符"></a>4. 删除字符</h3><p>使用 <code>delete()</code> 方法可以删除指定范围内的字符：</p><pre><code class="java">StringBuilder sb = new StringBuilder("Hello, World!");sb.delete(7, 13); // 删除位置7到13之间的字符</code></pre><h3 id="5-替换字符"><a href="#5-替换字符" class="headerlink" title="5. 替换字符"></a>5. 替换字符</h3><p>使用 <code>replace()</code> 方法可以替换指定范围内的字符：</p><pre><code class="java">StringBuilder sb = new StringBuilder("Hello, World!");sb.replace(7, 13, "Java"); // 将位置7到13之间的字符替换为 "Java"</code></pre><h3 id="6-获取字符串"><a href="#6-获取字符串" class="headerlink" title="6. 获取字符串"></a>6. 获取字符串</h3><p>使用 <code>toString()</code> 方法可以将 <code>StringBuilder</code> 对象转换为 <code>String</code>：</p><pre><code class="java">StringBuilder sb = new StringBuilder("Hello, World!");String result = sb.toString(); // 转换为 String</code></pre><h3 id="7-获取长度"><a href="#7-获取长度" class="headerlink" title="7. 获取长度"></a>7. 获取长度</h3><p>可以使用 <code>length()</code> 方法获取 <code>StringBuilder</code> 中字符的数量：</p><pre><code class="java">StringBuilder sb = new StringBuilder("Hello, World!");int length = sb.length(); // 获取长度</code></pre><p><code>StringBuilder</code> 的方法允许你执行许多字符串操作，而不需要创建多个不必要的字符串对象，这在性能上通常更高效。因此，当需要频繁修改字符串时，建议使用 <code>StringBuilder</code>。</p><h2 id="1-3-final关键字"><a href="#1-3-final关键字" class="headerlink" title="1.3 final关键字"></a>1.3 final关键字</h2><p><code>final</code> 是 Java 编程语言中的一个关键字，用于表示不可变性和不可继承性，它可以用于不同的上下文中，具体作用如下：</p><ol><li><p><strong>不可变变量</strong>：当你将 <code>final</code> 关键字应用于一个变量时，它表示该变量的值不能被修改，即它是一个不可变变量（immutable）。通常用于声明常量，这意味着一旦分配了值，就不能再更改。例如：</p><pre><code class="java">final int x = 10;// x = 20;  // 这将导致编译错误，因为 x 是不可变的</code></pre></li><li><p><strong>不可变类</strong>：当你将 <code>final</code> 关键字应用于一个类时，它表示该类不能被继承，即它是一个不可继承的类。这通常用于防止其他类继承或修改基类的行为，以确保类的稳定性和安全性。</p><pre><code class="java">final class MyFinalClass {    // 类的成员和方法}// 下面的代码将导致编译错误，因为无法继承 MyFinalClass// class AnotherClass extends MyFinalClass { ... }</code></pre></li><li><p><strong>不可变方法</strong>：当你将 <code>final</code> 关键字应用于一个方法时，它表示该方法不能被子类重写或覆盖。这通常用于确保某个方法的行为不会被修改。</p><pre><code class="java">class MyBaseClass {    final void myFinalMethod() {        // 这个方法不能被子类重写    }}</code></pre></li><li><p><strong>不可变参数</strong>：当你将 <code>final</code> 关键字应用于方法的参数时，它表示该参数的值在方法内部不能被修改。</p><pre><code class="java">void myMethod(final int param) {    // param 的值不能在方法内部被修改}</code></pre></li></ol><h2 id="1-4-super关键字"><a href="#1-4-super关键字" class="headerlink" title="1.4 super关键字"></a>1.4 super关键字</h2><p><code>super</code> 是 Java 中的一个关键字，用于引用父类（或超类）的成员变量、方法和构造函数。它可以在子类中使用，用于访问或调用父类的成员或构造函数。以下是关于 <code>super</code> 关键字的使用方法：</p><ol><li><p><strong>访问父类的成员变量</strong>：你可以使用 <code>super</code> 关键字来访问父类中的成员变量，特别是在子类中存在与父类同名的成员变量时。这样可以避免混淆。</p><pre><code class="java">class Parent {    int x = 10;}class Child extends Parent {    int x = 20;    void display() {        System.out.println("子类 x：" + x); // 访问子类的 x        System.out.println("父类 x：" + super.x); // 访问父类的 x    }}</code></pre></li><li><p><strong>调用父类的方法</strong>：你可以使用 <code>super</code> 关键字来调用父类中的方法，特别是在子类中存在与父类同名的方法时。</p><pre><code class="java">class Parent {    void showMessage() {        System.out.println("这是父类的消息");    }}class Child extends Parent {    void showMessage() {        System.out.println("这是子类的消息");        super.showMessage(); // 调用父类的 showMessage() 方法    }}</code></pre></li><li><p><strong>调用父类的构造函数</strong>：你可以使用 <code>super</code> 关键字来调用父类的构造函数。这通常用于子类的构造函数中，以确保父类的初始化工作得以执行。</p><pre><code class="java">class Parent {    Parent() {        System.out.println("父类的构造函数");    }}class Child extends Parent {    Child() {        super(); // 调用父类的构造函数        System.out.println("子类的构造函数");    }}</code></pre></li></ol><p>注意事项：</p><ul><li>在子类构造函数中，如果没有显式调用 <code>super()</code> 来调用父类的构造函数，Java 将自动调用父类的默认构造函数。</li><li><code>super()</code> 必须作为子类构造函数的第一行语句出现，因此它通常是构造函数的第一句。</li></ul><h2 id="1-5-abstract-关键字"><a href="#1-5-abstract-关键字" class="headerlink" title="1.5 abstract 关键字"></a>1.5 abstract 关键字</h2><p><code>abstract</code> 是 Java 中的一个关键字，用于声明抽象类和抽象方法。抽象类和抽象方法的目的是为了提供一种结构，以便其他类可以继承或实现它们，并根据需要进行定制化实现。以下是 <code>abstract</code> 关键字的主要作用：</p><ol><li><p><strong>抽象类</strong>：</p><ul><li>抽象类用 <code>abstract</code> 关键字声明，它不能被实例化（不能创建对象）。</li><li>抽象类可以包含抽象方法和非抽象方法。</li><li>抽象类的存在是为了被继承和拓展，提供通用的结构和行为。</li></ul><pre><code class="java">abstract class AbstractClass {    // 抽象方法    abstract void abstractMethod();    // 普通方法    void nonAbstractMethod() {        System.out.println("非抽象方法的实现");    }}</code></pre></li><li><p><strong>抽象方法</strong>：</p><ul><li>抽象方法用 <code>abstract</code> 关键字声明，但没有方法体。</li><li>抽象方法必须在抽象类中声明，不允许在普通类中声明。</li><li>抽象方法的具体实现由继承抽象类的子类完成。</li></ul><pre><code class="java">abstract class AbstractClass {    // 抽象方法    abstract void abstractMethod();}class ConcreteClass extends AbstractClass {    // 必须实现抽象方法    @Override    void abstractMethod() {        System.out.println("抽象方法的实现");    }}</code></pre></li></ol><p>抽象类和抽象方法的作用是为了促使子类实现特定的行为，同时确保了基类中的通用结构。这有助于提高代码的可维护性和扩展性，同时强调了面向对象设计的抽象思想。</p><h1 id="2-类"><a href="#2-类" class="headerlink" title="2 类"></a>2 类</h1><h2 id="2-1-接口"><a href="#2-1-接口" class="headerlink" title="2.1 接口"></a>2.1 接口</h2><p>在 Java 中，接口（Interface）是一种抽象类型，它定义了一组抽象方法，但没有具体的实现。接口通常用于描述对象应该具有的行为。以下是关于 Java 接口的主要特点：</p><ol><li><p><strong>接口定义</strong>：接口使用 <code>interface</code> 关键字定义。</p><pre><code class="java">interface MyInterface {    // 抽象方法的声明    void abstractMethod();}</code></pre></li><li><p><strong>抽象方法</strong>：接口中的方法都是抽象的，它们只有方法签名，没有方法体。</p></li><li><p><strong>接口实现</strong>：一个类可以实现一个或多个接口。使用关键字 <code>implements</code> 来表示类实现了一个接口。</p><pre><code class="java">class MyClass implements MyInterface {    // 必须实现接口中的抽象方法    @Override    public void abstractMethod() {        // 实现具体逻辑    }}</code></pre></li><li><p><strong>多继承</strong>：Java 中不支持多继承，但一个类可以实现多个接口，这使得 Java 中的多继承概念得以体现。</p><pre><code class="java">interface Interface1 {    void method1();}interface Interface2 {    void method2();}class MyClass implements Interface1, Interface2 {    @Override    public void method1() {        // 实现 method1    }    @Override    public void method2() {        // 实现 method2    }}</code></pre></li><li><p><strong>接口默认方法</strong>：从 Java 8 开始，接口可以包含具有默认实现的方法。</p><pre><code class="java">interface MyInterface {    void abstractMethod();    default void defaultMethod() {        System.out.println("默认方法的实现");    }}</code></pre></li><li><p><strong>接口静态方法</strong>：从 Java 8 开始，接口可以包含静态方法。</p><pre><code class="java">interface MyInterface {    void abstractMethod();    static void staticMethod() {        System.out.println("静态方法的实现");    }}</code></pre></li></ol><p>接口在 Java 中扮演着重要的角色，它提供了一种将抽象概念定义为一组行为的方式，从而实现了多态性和代码复用。接口也是 Java 中实现多继承的一种方式，使得类可以实现多个行为规范。</p><h2 id="2-2-Override"><a href="#2-2-Override" class="headerlink" title="2.2 @Override"></a>2.2 @Override</h2><p><code>@Override</code> 注解用于告诉编译器，被标注的方法是要重写（覆盖）父类或接口中的方法。通常情况下，你应该在以下情况下使用 <code>@Override</code> 注解：</p><ol><li><p><strong>重写父类方法</strong>：当你在子类中编写一个方法，其名称、参数列表和返回类型与父类中的方法完全一致时，应该使用 <code>@Override</code> 注解来明确指示你意图重写父类方法。</p><pre><code class="java">class Parent {    void myMethod() {        // 父类方法    }}class Child extends Parent {    @Override    void myMethod() {        // 子类重写的方法    }}</code></pre></li><li><p><strong>实现接口方法</strong>：当你在一个类中实现了一个接口中的方法时，也应该使用 <code>@Override</code> 注解。这有助于提醒你，你是在实现一个接口方法，而不是创建一个新的方法。</p><pre><code class="java">interface MyInterface {    void myMethod();}class MyClass implements MyInterface {    @Override    public void myMethod() {        // 实现接口方法    }}</code></pre></li><li><p><strong>编码规范</strong>：在许多编码规范中，推荐使用 <code>@Override</code> 注解，以提高代码的可读性和可维护性。这有助于其他开发人员理解你的代码意图，并防止意外的方法签名变更。</p></li></ol><p>虽然在上述情况下使用 <code>@Override</code> 注解是很好的实践，但并非所有情况下都需要使用它。在以下情况下，你通常不需要使用 <code>@Override</code> 注解：</p><ul><li>当你编写的方法不是为了重写父类或实现接口中的方法时。</li><li>当你在 Java 版本低于 5 的环境中编写代码，因为 <code>@Override</code> 注解是在 Java 5 中引入的。</li></ul><h1 id="3-常用类"><a href="#3-常用类" class="headerlink" title="3 常用类"></a>3 常用类</h1><h2 id="3-1-Arrays"><a href="#3-1-Arrays" class="headerlink" title="3.1 Arrays"></a>3.1 Arrays</h2><p>当使用 <code>Arrays</code> 类的方法时，通常需要导入 <code>java.util.Arrays</code> 包。以下是一些使用 <code>Arrays</code> 类方法的示例：</p><p><strong>1. 使用 <code>sort</code> 方法对数组进行排序：</strong></p><pre><code class="java">import java.util.Arrays;public class ArraySortingExample {    public static void main(String[] args) {        int[] numbers = {5, 2, 9, 1, 5, 6};                Arrays.sort(numbers);                System.out.println("Sorted Array: " + Arrays.toString(numbers));    }}</code></pre><p><strong>2. 使用 <code>binarySearch</code> 方法查找元素：</strong></p><pre><code class="java">import java.util.Arrays;public class BinarySearchExample {    public static void main(String[] args) {        int[] numbers = {1, 2, 3, 4, 5, 6};                int key = 3;        int index = Arrays.binarySearch(numbers, key);                if (index &gt;= 0) {            System.out.println("Element " + key + " found at index " + index);        } else {            System.out.println("Element " + key + " not found in the array");        }    }}</code></pre><p><strong>3. 使用 <code>equals</code> 方法比较数组：</strong></p><pre><code class="java">import java.util.Arrays;public class ArrayComparisonExample {    public static void main(String[] args) {        int[] array1 = {1, 2, 3};        int[] array2 = {1, 2, 3};                boolean isEqual = Arrays.equals(array1, array2);                if (isEqual) {            System.out.println("Arrays are equal.");        } else {            System.out.println("Arrays are not equal.");        }    }}</code></pre><p><strong>4. 使用 <code>fill</code> 方法填充数组：</strong></p><pre><code class="java">import java.util.Arrays;public class ArrayFillExample {    public static void main(String[] args) {        int[] numbers = new int[5];                Arrays.fill(numbers, 42);                System.out.println("Filled Array: " + Arrays.toString(numbers));    }}</code></pre><h2 id="3-2-time"><a href="#3-2-time" class="headerlink" title="3.2 time"></a>3.2 time</h2><p><code>java.time</code> 包是Java 8引入的现代日期和时间处理API，提供了一系列类来处理日期、时间和时区。以下是一些<code>java.time</code>包的主要类和用法示例：</p><ol><li><p><strong>LocalDate</strong>：用于表示日期，不包含时间和时区信息。</p><pre><code class="java">LocalDate today = LocalDate.now();LocalDate customDate = LocalDate.of(2023, 9, 25);int year = today.getYear();int month = today.getMonthValue();int day = today.getDayOfMonth();</code></pre></li><li><p><strong>LocalTime</strong>：用于表示时间，不包含日期和时区信息。</p><pre><code class="java">LocalTime currentTime = LocalTime.now();LocalTime customTime = LocalTime.of(14, 30, 0);int hour = currentTime.getHour();int minute = currentTime.getMinute();int second = currentTime.getSecond();</code></pre></li><li><p><strong>LocalDateTime</strong>：用于表示日期和时间的组合，不包含时区信息。</p><pre><code class="java">LocalDateTime currentDateTime = LocalDateTime.now();LocalDateTime customDateTime = LocalDateTime.of(2023, 9, 25, 14, 30, 0);int year = currentDateTime.getYear();int month = currentDateTime.getMonthValue();int hour = currentDateTime.getHour();</code></pre></li><li><p><strong>ZonedDateTime</strong>：用于表示带时区的日期和时间。</p><pre><code class="java">ZoneId newYorkZone = ZoneId.of("America/New_York");ZonedDateTime newYorkTime = ZonedDateTime.now(newYorkZone);ZoneId londonZone = ZoneId.of("Europe/London");ZonedDateTime londonTime = newYorkTime.withZoneSameInstant(londonZone);</code></pre></li><li><p><strong>Duration</strong>：用于表示时间段，可以用于计算时间间隔。</p><pre><code class="java">LocalDateTime start = LocalDateTime.of(2023, 9, 1, 8, 0);LocalDateTime end = LocalDateTime.of(2023, 9, 5, 17, 0);Duration duration = Duration.between(start, end);long hours = duration.toHours();long minutes = duration.toMinutes();</code></pre></li><li><p><strong>Period</strong>：用于表示日期段，可以用于计算日期间隔。</p><pre><code class="java">LocalDate startDate = LocalDate.of(2023, 9, 1);LocalDate endDate = LocalDate.of(2023, 9, 5);Period period = Period.between(startDate, endDate);int days = period.getDays();int months = period.getMonths();</code></pre></li><li><p><strong>DateTimeFormatter</strong>：用于日期和时间的格式化和解析。</p><pre><code class="java">DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");String formattedDateTime = LocalDateTime.now().format(formatter);LocalDateTime parsedDateTime = LocalDateTime.parse("2023-09-25 14:30:00", formatter);</code></pre></li><li><p><strong>TemporalAdjusters</strong>：提供了一些有用的日期调整器，例如获取某月的第一个周一。</p><pre><code class="java">LocalDate firstMondayOfSeptember = LocalDate.of(2023, 9, 1).with(TemporalAdjusters.firstInMonth(DayOfWeek.MONDAY));</code></pre></li></ol><h2 id="3-3-Math"><a href="#3-3-Math" class="headerlink" title="3.3 Math"></a>3.3 Math</h2><p><code>java.lang.Math</code> 类包含了一些常用的数学方法，用于执行各种数学运算。以下是一些常用的 <code>Math</code> 类方法：</p><ol><li><strong>绝对值相关方法：</strong><ul><li><code>abs(x)</code>：返回给定数的绝对值。</li><li><code>max(x, y)</code>：返回两个数中较大的那个。</li><li><code>min(x, y)</code>：返回两个数中较小的那个。</li></ul></li><li><strong>舍入相关方法：</strong><ul><li><code>ceil(x)</code>：将参数向正无穷方向舍入为最接近的整数。</li><li><code>floor(x)</code>：将参数向负无穷方向舍入为最接近的整数。</li><li><code>round(x)</code>：将参数四舍五入为最接近的整数。</li><li><code>rint(x)</code>：将参数四舍五入为最接近的整数，如果两个整数同样接近，则选择偶数。</li></ul></li><li><strong>指数和对数相关方法：</strong><ul><li><code>exp(x)</code>：返回指数函数 e^x 的值。</li><li><code>log(x)</code>：返回自然对数（以 e 为底）的值。</li><li><code>pow(x, y)</code>：返回 x 的 y 次方。</li><li><code>sqrt(x)</code>：返回给定数的平方根。</li></ul></li><li><strong>三角函数相关方法：</strong><ul><li><code>sin(x)</code>：返回给定角度的正弦值。</li><li><code>cos(x)</code>：返回给定角度的余弦值。</li><li><code>tan(x)</code>：返回给定角度的正切值。</li><li><code>asin(x)</code>：返回给定值的反正弦值。</li><li><code>acos(x)</code>：返回给定值的反余弦值。</li><li><code>atan(x)</code>：返回给定值的反正切值。</li><li><code>toRadians(x)</code>：将角度从度数转换为弧度。</li><li><code>toDegrees(x)</code>：将角度从弧度转换为度数。</li></ul></li><li><strong>随机数生成方法：</strong><ul><li><code>random()</code>：返回一个伪随机 double 值，范围在 [0.0, 1.0) 之间。</li></ul></li></ol><h2 id="3-4-System"><a href="#3-4-System" class="headerlink" title="3.4 System"></a>3.4 System</h2><p><code>java.lang.System</code> 类是Java标准库中的一个类，它提供了一系列用于与系统交互的方法，包括访问系统属性、标准输入输出、以及进行垃圾回收等。以下是一些常见的 <code>System</code> 类方法和用法：</p><ol><li><p><strong>标准输入输出（I/O）：</strong></p><p>-<br>  System.out</p><p>  标准输出流，通常用于向控制台打印信息。</p><pre><code class="java">System.out.println("Hello, world!"); // 打印文本到控制台</code></pre><p>-<br>  System.err</p><p>  标准错误流，用于输出错误信息。</p><pre><code class="java">System.err.println("An error occurred!"); // 打印错误信息到控制台</code></pre><p>-<br>  System.in</p><p>  标准输入流，通常用于从控制台读取用户输入。</p><pre><code class="java">Scanner scanner = new Scanner(System.in);System.out.print("Enter your name: ");String name = scanner.nextLine();</code></pre></li><li><p><strong>系统属性：</strong></p><p>-<br>  System.getProperty(String key)</p><p>  ：获取系统属性的值，可以用于获取系统信息，如操作系统类型、Java版本等。</p><pre><code class="java">String osName = System.getProperty("os.name");String javaVersion = System.getProperty("java.version");</code></pre></li><li><p><strong>垃圾回收：</strong></p><p>-<br>  System.gc()</p><p>  ：请求系统进行垃圾回收操作。注意，具体的垃圾回收时机和行为是由JVM决定的，所以不一定会立即执行垃圾回收。</p><pre><code class="java">System.gc(); // 请求进行垃圾回收</code></pre></li><li><p><strong>程序终止：</strong></p><ul><li><pre><code class="java">System.exit(int status)</code></pre><p>终止当前Java虚拟机的运行，参数通常用于指示程序的退出状态。0 表示正常退出，非零值通常用于表示异常退出。</p><pre><code class="java">System.exit(0); // 正常退出</code></pre></li></ul></li><li><p><strong>时间获取：</strong></p><ul><li><pre><code>System.currentTimeMillis()</code></pre><p>：返回当前时间的毫秒数，通常用于性能分析和计时。</p><pre><code class="java">long startTime = System.currentTimeMillis();// 执行一些代码long endTime = System.currentTimeMillis();long elapsedTime = endTime - startTime;</code></pre></li></ul></li><li><p><strong>数组拷贝：</strong></p><ul><li><pre><code class="java">System.arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</code></pre><p>：用于将源数组的一部分复制到目标数组的指定位置。</p><pre><code class="java">int[] sourceArray = {1, 2, 3, 4, 5};int[] destArray = new int[5];System.arraycopy(sourceArray, 0, destArray, 0, 5);</code></pre></li></ul></li></ol><p><code>System</code> 类提供了许多有用的方法，可以用于访问系统资源、执行一些底层操作，以及进行基本的输入输出。在实际编程中，它通常用于调试、性能分析、系统属性获取等操作。但要注意，在大多数情况下，直接与系统资源交互的需求不多，因为Java提供了更高级的库和API来完成常见的任务。</p><h2 id="3-5-Random"><a href="#3-5-Random" class="headerlink" title="3.5 Random"></a>3.5 Random</h2><p>在Java中，你可以使用 <code>java.util.Random</code> 类来生成随机数。以下是使用 <code>Random</code> 类的基本方法：</p><ol><li><p><strong>创建 Random 对象：</strong></p><p>首先，你需要创建一个 <code>Random</code> 对象，可以通过以下方式之一来实现：</p><pre><code class="java">// 使用默认种子创建 Random 对象Random random = new Random();// 使用指定种子创建 Random 对象long seed = 123456789L; // 可以是任何长整数Random seededRandom = new Random(seed);</code></pre><p>通常情况下，如果你不需要指定特定的种子，可以使用无参数的构造函数创建 <code>Random</code> 对象，它会使用系统时间作为默认种子。</p></li><li><p><strong>生成随机整数：</strong></p><p>使用 <code>nextInt()</code> 方法可以生成一个随机整数：</p><pre><code class="java">int randomNumber = random.nextInt(); // 生成任意范围的随机整数</code></pre><p>如果你希望生成在指定范围内的随机整数，可以使用 <code>nextInt(int bound)</code> 方法：</p><pre><code class="java">int min = 1;int max = 100;int randomInRange = random.nextInt(max - min + 1) + min; // 生成1到100之间的随机整数</code></pre></li><li><p><strong>生成随机浮点数：</strong></p><p>使用 <code>nextDouble()</code> 方法可以生成一个随机的 double 值，范围在 [0.0, 1.0) 之间：</p><pre><code class="java">double randomDouble = random.nextDouble(); // 生成0.0到1.0之间的随机浮点数</code></pre></li><li><p><strong>生成随机布尔值：</strong></p><p>使用 <code>nextBoolean()</code> 方法可以生成一个随机的布尔值（<code>true</code> 或 <code>false</code>）：</p><pre><code class="java">boolean randomBoolean = random.nextBoolean(); // 随机生成true或false</code></pre></li></ol><h1 id="4-泛型"><a href="#4-泛型" class="headerlink" title="4 泛型"></a>4 泛型</h1><h2 id="4-1-介绍"><a href="#4-1-介绍" class="headerlink" title="4.1 介绍"></a>4.1 介绍</h2><p>Java中的泛型是一种编程机制，它允许你在类、接口和方法中使用类型参数，以在不同情况下使用相同的代码来处理不同的数据类型。泛型的主要目的是提高代码的重用性、类型安全性和可读性。</p><p>使用泛型，你可以定义类、接口或方法，使其能够处理多种数据类型而不必在每次使用时进行强制类型转换。泛型类、泛型接口和泛型方法的定义都可以包含类型参数。类型参数可以在定义时指定，然后在实际使用时传入具体的类型。</p><p>以下是一个简单的泛型类的示例：</p><pre><code class="java">public class GenericBox&lt;T&gt; {    private T value;    public GenericBox(T value) {        this.value = value;    }    public T getValue() {        return value;    }}</code></pre><p>在这个示例中，<code>GenericBox</code> 是一个泛型类，它有一个类型参数 <code>T</code>。你可以创建 <code>GenericBox</code> 的实例，将不同类型的数据存储在其中，而无需进行显式的类型转换。</p><p>例如：</p><pre><code class="java">GenericBox&lt;Integer&gt; intBox = new GenericBox&lt;&gt;(42);Integer intValue = intBox.getValue(); // 不需要强制类型转换GenericBox&lt;String&gt; strBox = new GenericBox&lt;&gt;("Hello, Generics!");String strValue = strBox.getValue(); // 不需要强制类型转换</code></pre><p>这使得代码更灵活，可以在不同的情况下使用相同的泛型类，而不必为每种数据类型创建不同的类或方法。泛型还有助于在编译时检测类型错误，提高了代码的安全性。</p><p>在Java中，尖括号 <code>&lt;&gt;</code> 主要用于泛型（Generics）的定义和使用。泛型是Java中的一项重要特性，允许你编写通用的、类型安全的代码，以便在运行时处理不同类型的数据。</p><p>以下是 <code>&lt;&gt;</code> 的用法和相关概念：</p><ol><li><p><strong>泛型类 (Generic Class):</strong> 你可以创建一个类，其中包含一个或多个类型参数，用 <code>&lt;&gt;</code> 括起来，然后在类的定义中使用这些类型参数。这样的类被称为泛型类。</p><pre><code class="java">public class MyGenericClass&lt;T&gt; {    private T value;    public MyGenericClass(T value) {        this.value = value;    }    public T getValue() {        return value;    }}</code></pre></li><li><p><strong>泛型接口 (Generic Interface):</strong> 类似于泛型类，你可以创建泛型接口，使接口中的方法具有类型参数。</p><pre><code class="java">public interface MyGenericInterface&lt;T&gt; {    T getDefaultValue();}</code></pre></li><li><p><strong>泛型方法 (Generic Method):</strong> 你可以在普通类或非泛型类中定义泛型方法，使用 <code>&lt;&gt;</code> 括起来的类型参数，以便在方法级别处理不同类型的数据。</p><pre><code class="java">public &lt;T&gt; T getFirstElement(List&lt;T&gt; list) {    if (list.isEmpty()) {        return null;    }    return list.get(0);}</code></pre></li><li><p><strong>通配符 (Wildcard):</strong> <code>&lt;&gt;</code> 也用于通配符的定义，通常与泛型方法和泛型类一起使用，以表示某些不确定的类型。</p><ul><li><code>&lt;?&gt;</code> 表示无界通配符，用于表示可以接受任何类型的数据。</li><li><code>&lt;? extends T&gt;</code> 表示上界通配符，用于表示只能接受类型 <code>T</code> 或其子类型的数据。</li><li><code>&lt;? super T&gt;</code> 表示下界通配符，用于表示只能接受类型 <code>T</code> 或其父类型的数据。</li></ul><p>例如，<code>List&lt;?&gt;</code> 表示一个可以包含任何类型的元素的列表。</p></li><li><p><strong>类型参数的使用:</strong> 在使用泛型时，你可以将具体的类型传递给泛型类、泛型接口或泛型方法，以实例化它们。</p><pre><code class="java">MyGenericClass&lt;Integer&gt; intObject = new MyGenericClass&lt;&gt;(42);MyGenericInterface&lt;String&gt; stringObject = new MyGenericInterface&lt;String&gt;() {    @Override    public String getDefaultValue() {        return "Default";    }};</code></pre></li></ol><p>总之，尖括号 <code>&lt;&gt;</code> 在Java中用于定义和使用泛型，允许你编写更通用和类型安全的代码，以在不同类型的数据上执行操作。泛型提高了代码的重用性和可读性，同时提供了更强的类型检查。</p><h2 id="4-2-collection"><a href="#4-2-collection" class="headerlink" title="4.2 collection"></a>4.2 collection</h2><p><img src="C:\Users\7878\AppData\Roaming\Typora\typora-user-images\image-20230926142725652.png" alt="image-20230926142725652"></p><p>在Java中，<code>Collection</code> 是一个接口，它表示一组对象，通常用于存储和操作多个元素。<code>Collection</code> 接口是Java集合框架的一部分，它定义了一系列用于管理和操作元素集合的通用方法。</p><p><code>Collection</code> 接口是Java集合框架的根接口，它有许多子接口和实现类，包括<code>List</code>、<code>Set</code>、<code>Queue</code>等，每个子接口和实现类都提供了不同的数据结构和行为，以满足不同的需求。</p><p>下面是一些常用的<code>Collection</code>接口的子类：</p><ol><li><strong>List:</strong> <code>List</code> 接口表示有序的元素集合，允许重复元素。常见的实现类包括 <code>ArrayList</code>、<code>LinkedList</code> 和 <code>Vector</code>。你可以按索引访问元素，允许插入、删除和替换元素。</li><li><strong>Set:</strong> <code>Set</code> 接口表示无序的元素集合，不允许重复元素。常见的实现类包括 <code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code>。集合中的元素不按顺序存储，而且不允许重复。</li><li><strong>Queue:</strong> <code>Queue</code> 接口表示一个队列，通常按照先进先出（FIFO）的顺序处理元素。常见的实现类包括 <code>LinkedList</code> 和 <code>PriorityQueue</code>。它通常用于任务调度和处理等场景。</li></ol><p>使用<code>Collection</code>接口和其子接口的步骤如下：</p><ol><li><p><strong>导入必要的包：</strong> 你需要导入<code>java.util</code>包，因为集合框架的类和接口都在这个包中。</p></li><li><p><strong>创建集合对象：</strong> 选择适当的集合实现类，创建一个集合对象。</p><pre><code class="java">List&lt;String&gt; myList = new ArrayList&lt;&gt;(); // 创建一个ArrayList集合Set&lt;Integer&gt; mySet = new HashSet&lt;&gt;();   // 创建一个HashSet集合</code></pre></li><li><p><strong>操作集合：</strong> 使用集合对象的方法来添加、删除、查询和遍历元素。</p><pre><code class="java">// 向List中添加元素myList.add("Apple");myList.add("Banana");// 从Set中删除元素mySet.add(1);mySet.add(2);mySet.remove(1);// 遍历List中的元素for (String fruit : myList) {    System.out.println(fruit);}</code></pre></li><li><p><strong>其他操作：</strong> 根据需要，可以使用集合的其他方法来执行搜索、排序、过滤等操作。</p></li></ol><p><code>Collection</code> 接口和其子类提供了丰富的方法来处理不同类型的集合，根据具体需求选择合适的集合类型和方法来操作数据。它们是Java中常用的数据结构，用于处理和管理多个元素的集合。</p><h2 id="4-3-List"><a href="#4-3-List" class="headerlink" title="4.3 List"></a>4.3 List</h2><p>在Java中，<code>List</code> 是一个接口，表示有序的元素集合，允许重复元素。<code>List</code> 接口继承自 <code>Collection</code> 接口，并定义了一系列方法，用于操作和管理元素列表。你可以使用<code>List</code>来存储一组元素，并按照它们的插入顺序来访问、添加、删除和修改元素。</p><p>以下是使用 <code>List</code> 的基本步骤：</p><ol><li><p><strong>导入必要的包：</strong> 在使用 <code>List</code> 之前，首先需要导入 <code>java.util</code> 包，因为 <code>List</code> 接口和相关的类都在这个包中。</p><pre><code class="java">import java.util.List;import java.util.ArrayList; // 或其他List的实现类</code></pre></li><li><p><strong>创建 <code>List</code> 对象：</strong> 选择一个 <code>List</code> 接口的实现类（例如 <code>ArrayList</code>、<code>LinkedList</code> 等），创建一个 <code>List</code> 对象。</p><pre><code class="java">List&lt;String&gt; myList = new ArrayList&lt;&gt;(); // 创建一个ArrayList集合</code></pre></li><li><p><strong>操作 <code>List</code>：</strong> 使用 <code>List</code> 对象的方法来添加、删除、查询和遍历元素。</p><pre><code class="java">// 向List中添加元素myList.add("Apple");myList.add("Banana");myList.add("Cherry");// 获取List的大小int size = myList.size(); // 返回3，因为有3个元素// 获取指定位置的元素String fruit = myList.get(1); // 返回"Banana"// 修改元素myList.set(0, "Orange"); // 将第一个元素从"Apple"修改为"Orange"// 删除元素myList.remove(2); // 删除第三个元素"Cherry"// 遍历List中的元素for (String item : myList) {    System.out.println(item);}</code></pre></li><li><p><strong>其他操作：</strong> 根据需要，可以使用 <code>List</code> 的其他方法来执行搜索、排序、过滤等操作。例如，你可以使用 <code>contains</code> 方法检查元素是否存在于列表中，使用 <code>sort</code> 方法对列表进行排序等。</p><pre><code class="java">// 检查元素是否存在于List中boolean containsBanana = myList.contains("Banana"); // 返回true// 对List进行排序Collections.sort(myList); // 对列表元素按照自然顺序排序</code></pre></li><li><p><strong>注意事项：</strong></p><ul><li><code>List</code> 是有序的，允许元素重复。元素的顺序由插入顺序决定。</li><li><code>List</code> 的索引从0开始，你可以使用索引来访问元素。</li><li><code>List</code> 接口提供了丰富的方法来处理列表，包括添加、删除、修改、遍历等操作。</li></ul></li></ol><p>根据你的具体需求，选择适当的 <code>List</code> 实现类以及方法来操作元素列表。<code>ArrayList</code> 是一个常用的 <code>List</code> 实现类，通常在不需要频繁插入和删除元素的情况下使用，而 <code>LinkedList</code> 在需要频繁插入和删除元素的情况下可能更加高效。</p><p>对于一个使用迭代器（Iterator）来遍历集合的过程，初始时迭代器并不包含任何元素信息，而是通过 <code>.next()</code> 方法来获取元素的信息。这是因为迭代器是一种用于顺序访问集合中元素的对象，它的初始位置位于第一个元素之前（或集合的开头），只有调用 <code>.next()</code> 方法才会移动迭代器到下一个元素，同时返回当前元素的值。</p><p>以下是解释为什么需要使用 <code>.next()</code> 方法来获取元素信息的原因：</p><ol><li><strong>初始位置在第一个元素之前：</strong> 迭代器的初始位置通常是在集合的第一个元素之前（或集合的开头），这意味着在迭代器创建后，它并不指向任何元素。如果你直接尝试访问迭代器的当前元素，它将返回一个空值或抛出异常。</li><li><strong>控制迭代过程：</strong> 使用 <code>.next()</code> 方法可以精确控制迭代过程，让你决定何时移动到下一个元素。这允许你在处理完当前元素后决定是否继续迭代或停止迭代，从而更加灵活地操作集合中的元素。</li><li><strong>提供当前元素的值：</strong> <code>.next()</code> 方法返回迭代器当前位置的元素，并将迭代器移动到下一个位置。这样，你可以在每次调用 <code>.next()</code> 方法后获得当前元素的值，从而进行进一步的处理，比如打印、修改或使用这个元素。</li></ol><pre><code class="java">/** * 学生类 */public class Student {    public String id;    public String name;    public Student(String id, String name){        this.id = id;        this.name = name;    }    @Override    public String toString() {        return "Student{" +                "id='" + id + '\'' +                ", name='" + name + '\'' +                '}';    }}import java.util.*;public class ListTest {    //集合后面的&lt;&gt;代表泛型的意思    //泛型是规定了集合元素的类型    /**     * 用于存放学生的List     */    public List&lt;Student&gt; students;    public ListTest() {        this.students = new ArrayList&lt;Student&gt;();    }    /**     * 用于往students中添加学生     */    public void testAdd() {        // 创建一个学生对象，并通过调用add方法，添加到学生管理List中        Student st1 = new Student("1", "张三");        students.add(st1);        // 取出 List中的Student对象 索引为0 也就是第一个        Student temp = students.get(0);        System.out.println("添加了学生：" + temp.id + ":" + temp.name);        Student st2 = new Student("2", "李四");        //添加到list中，插入到索引为0的位置，也就是第一个        students.add(0, st2);        Student temp2 = students.get(0);        System.out.println("添加了学生：" + temp2.id + ":" + temp2.name);        // 对象数组的形式添加        Student[] student = {new Student("3", "王五"), new Student("4", "马六")};        // Arrays类包含用来操作数组（比如排序和搜索）的各种方法，asList() 方法用来返回一个受指定数组支持的固定大小的列表        students.addAll(Arrays.asList(student));        Student temp3 = students.get(2);        Student temp4 = students.get(3);        System.out.println("添加了学生：" + temp3.id + ":" + temp3.name);        System.out.println("添加了学生：" + temp4.id + ":" + temp4.name);        Student[] student2 = {new Student("5", "周七"), new Student("6", "赵八")};        students.addAll(2, Arrays.asList(student2));        Student temp5 = students.get(2);        Student temp6 = students.get(3);        System.out.println("添加了学生：" + temp5.id + ":" + temp5.name);        System.out.println("添加了学生：" + temp6.id + ":" + temp6.name);    }    /**     * 取得List中的元素的方法     */    public void testGet() {        int size = students.size();        for (int i = 0; i &lt; size; i++) {            Student st = students.get(i);            System.out.println("学生：" + st.id + ":" + st.name);        }    }    /**     * 通过迭代器来遍历     * 迭代器的工作是遍历并选择序列中的对象，Java 中 Iterator 只能单向移动     */    public void testIterator() {        // 通过集合的iterator方法，取得迭代器实例        Iterator&lt;Student&gt; it = students.iterator();        System.out.println("有如下学生（通过迭代器访问）：");        while (it.hasNext()) {            Student st = it.next();            System.out.println("学生" + st.id + ":" + st.name);        }    }    /**     * 通过for each 方法访问集合元素     *     */    public void testForEach() {        System.out.println("有如下学生（通过for each）：");        for (Student obj : students) {            Student st = obj;            System.out.println("学生：" + st.id + ":" + st.name);        }        //使用java8 Steam将学生排序后输出        students.stream()//创建Stream                //通过学生id排序                .sorted(Comparator.comparing(x -&gt; x.id))                //输出                .forEach(System.out::println);    }    /**     * 修改List中的元素     *     */    public void testModify() {        students.set(4, new Student("3", "吴酒"));    }    /**     * 删除List中的元素     *     */    public void testRemove() {        Student st = students.get(4);        System.out.println("我是学生：" + st.id + ":" + st.name + "，我即将被删除");        students.remove(st);        System.out.println("成功删除学生！");        testForEach();    }    public static void main(String[] args) {        ListTest lt = new ListTest();        lt.testAdd();        lt.testGet();        lt.testIterator();        lt.testModify();        lt.testForEach();        lt.testRemove();    }}</code></pre><blockquote><p><code>ArrayList</code> 和 <code>Vector</code> 都是 Java 集合框架中的实现了 <code>List</code> 接口的类，它们都用于存储有序的元素集合，允许元素重复，且按照插入顺序进行存储。然而，它们之间存在一些关键区别：</p><ol><li><strong>线程安全性：</strong><ul><li><code>ArrayList</code> 是非线程安全的：<code>ArrayList</code> 不是线程安全的，这意味着在多线程环境中使用 <code>ArrayList</code> 时，需要额外的同步措施，否则可能会导致不确定的行为或数据损坏。</li><li><code>Vector</code> 是线程安全的：<code>Vector</code> 在每个方法上都添加了同步关键字，因此可以在多线程环境中安全使用。然而，这也可能导致在高度并发的情况下性能略有下降。</li></ul></li><li><strong>性能：</strong><ul><li><code>ArrayList</code> 通常比 <code>Vector</code> 更快：由于 <code>Vector</code> 实现了线程同步，因此在单线程环境下，<code>ArrayList</code> 通常比 <code>Vector</code> 更快，因为它不需要额外的同步开销。</li><li><code>Vector</code> 在多线程环境中可能更适用：如果你需要在多线程环境中使用一个线程安全的动态数组，<code>Vector</code> 可能更适合，尽管性能方面可能会略有牺牲。</li></ul></li><li><strong>增长策略：</strong><ul><li><code>ArrayList</code> 的增长策略是增加一半的容量：当 <code>ArrayList</code> 的容量不足以容纳新元素时，它会自动增加其容量，通常是当前容量的一半。这可以减少内存浪费。</li><li><code>Vector</code> 的增长策略是增加一倍的容量：当 <code>Vector</code> 的容量不足时，它会将容量翻倍。这可能导致更多的内存浪费，尤其在容量较大时。</li></ul></li><li><strong>遗留特性：</strong><ul><li><code>Vector</code> 是一个古老的类：<code>Vector</code> 是在Java早期引入的，因此它具有一些遗留的特性，如不支持泛型。相比之下，<code>ArrayList</code> 是在Java 1.2引入的，并支持泛型。</li></ul></li></ol><p>总结：一般情况下，如果你在单线程环境中使用动态数组，<code>ArrayList</code> 是一个更好的选择，因为它具有较好的性能。如果你需要在线程安全的多线程环境中使用动态数组，可以考虑使用 <code>Vector</code>。然而，现代 Java 更倾向于使用 <code>ArrayList</code>，并使用 <code>Collections.synchronizedList</code> 方法来将其转换为线程安全的形式，以获得更好的性能。</p></blockquote><h2 id="4-4-Map"><a href="#4-4-Map" class="headerlink" title="4.4 Map"></a>4.4 Map</h2><p>在 Java 中，<code>Map</code> 是一种非常有用的数据结构，用于存储键值对（key-value pairs）。每个键都唯一，而与每个键关联的值可以重复。<code>Map</code> 提供了一种快速查找和检索值的方式，通常用于表示和管理数据的关联关系。</p><p>以下是 Java 中使用 <code>Map</code> 的基本操作和示例：</p><ol><li>创建一个 Map 对象：</li></ol><p>你可以使用 <code>HashMap</code>、<code>TreeMap</code>、<code>LinkedHashMap</code> 等 <code>Map</code> 的实现类来创建一个 <code>Map</code> 对象。例如：</p><pre><code class="java">import java.util.*;Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); // 创建一个 HashMap，键的类型是 String，值的类型是 Integer</code></pre><ol start="2"><li>添加键值对：</li></ol><p>使用 <code>put</code> 方法将键值对添加到 <code>Map</code> 中：</p><pre><code class="java">map.put("Alice", 25);map.put("Bob", 30);map.put("Charlie", 28);</code></pre><ol start="3"><li>获取值：</li></ol><p>使用 <code>get</code> 方法根据键获取对应的值：</p><pre><code class="java">int age = map.get("Alice"); // 获取键为 "Alice" 的值，age 等于 25</code></pre><ol start="4"><li>检查键是否存在：</li></ol><p>使用 <code>containsKey</code> 方法来检查某个键是否存在于 <code>Map</code> 中：</p><pre><code class="java">boolean containsAlice = map.containsKey("Alice"); // containsAlice 等于 trueboolean containsDavid = map.containsKey("David"); // containsDavid 等于 false</code></pre><ol start="5"><li>遍历 Map：</li></ol><p>你可以使用不同的方式来遍历 <code>Map</code>，例如使用 <code>keySet()</code>、<code>values()</code> 或 <code>entrySet()</code> 方法。以下是使用 <code>entrySet()</code> 的示例：</p><pre><code class="java">for (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) {    String key = entry.getKey();    int value = entry.getValue();    System.out.println(key + " -&gt; " + value);}</code></pre><ol start="6"><li>删除键值对：</li></ol><p>使用 <code>remove</code> 方法来删除指定键的键值对：</p><pre><code class="java">map.remove("Bob"); // 删除键为 "Bob" 的键值对</code></pre><ol start="7"><li>获取 Map 的大小：</li></ol><p>使用 <code>size</code> 方法获取 <code>Map</code> 中键值对的数量：</p><pre><code class="java">int size = map.size(); // 获取 Map 中键值对的数量</code></pre><p>这些是 <code>Map</code> 基本操作的示例。<code>Map</code> 提供了强大的功能，可以用于解决各种数据关联问题，如字典、缓存、计数器等。你可以根据具体的需求选择合适的 <code>Map</code> 实现类以及操作方法。</p><pre><code class="java">public class Course {    public String id;    public String name;    public Course(String id, String name){        this.id = id;        this.name = name;    }}</code></pre><pre><code class="java">// MapTest.javaimport java.util.HashMap;import java.util.Map;import java.util.Map.Entry;import java.util.Scanner;import java.util.Set;public class MapTest {    /**     * 用来承装课程类型对象     */    public Map&lt;String, Course&gt; courses;    /**     * 在构造器中初始化 courses 属性     * @param args     */    public MapTest() {        this.courses = new HashMap&lt;String, Course&gt;();    }    /**     * 测试添加：输入课程 ID，判断是否被占用     * 若未被占用，输入课程名称，创建新课程对象     * 并且添加到 courses 中     * @param args     */    public void testPut() {        //创建一个 Scanner 对象，用来获取输入的课程 ID 和名称        Scanner console = new Scanner(System.in);        for(int i = 0; i &lt; 3; i++) {            System.out.println("请输入课程 ID：");            String ID = console.next();            //判断该 ID 是否被占用            Course cr = courses.get(ID);            if(cr == null){                //提示输入课程名称                System.out.println("请输入课程名称：");                String name = console.next();                //创建新的课程对象                Course newCourse = new Course(ID,name);                //通过调用 courses 的 put 方法，添加 ID-课程映射                courses.put(ID, newCourse);                System.out.println("成功添加课程：" + courses.get(ID).name);            }            else {                System.out.println("该课程 ID 已被占用");                continue;            }        }    }    /**     * 测试 Map 的 keySet 方法     * @param args     */    public void testKeySet() {        //通过 keySet 方法，返回 Map 中的所有键的 Set 集合        Set&lt;String&gt; keySet = courses.keySet();        //遍历 keySet，取得每一个键，在调用 get 方法取得每个键对应的 value        for(String crID: keySet) {            Course cr = courses.get(crID);            if(cr != null){                System.out.println("课程：" + cr.name);            }        }    }    /**     * 测试删除 Map 中的映射     * @param args     */    public void testRemove() {        //获取从键盘输入的待删除课程 ID 字符串        Scanner console = new Scanner(System.in);        while(true){            //提示输出待删除的课程 ID            System.out.println("请输入要删除的课程 ID！");            String ID = console.next();            //判断该 ID 是否对应的课程对象            Course cr = courses.get(ID);            if(cr == null) {                //提示输入的 ID 并不存在                System.out.println("该 ID 不存在！");                continue;            }            courses.remove(ID);            System.out.println("成功删除课程" + cr.name);            break;        }    }    /**     * 通过 entrySet 方法来遍历 Map     * @param args     */    public void testEntrySet() {        //通过 entrySet 方法，返回 Map 中的所有键值对        Set&lt;Entry&lt;String,Course&gt;&gt; entrySet = courses.entrySet();        for(Entry&lt;String,Course&gt; entry: entrySet) {            System.out.println("取得键：" + entry.getKey());            System.out.println("对应的值为：" + entry.getValue().name);        }    }    /**     * 利用 put 方法修改Map 中的已有映射     * @param args     */    public void testModify(){        //提示输入要修改的课程 ID        System.out.println("请输入要修改的课程 ID：");        //创建一个 Scanner 对象，去获取从键盘上输入的课程 ID 字符串        Scanner console = new Scanner(System.in);        while(true) {            //取得从键盘输入的课程 ID            String crID = console.next();            //从 courses 中查找该课程 ID 对应的对象            Course course = courses.get(crID);            if(course == null) {                System.out.println("该 ID 不存在！请重新输入！");                continue;            }            //提示当前对应的课程对象的名称            System.out.println("当前该课程 ID，所对应的课程为：" + course.name);            //提示输入新的课程名称，来修改已有的映射            System.out.println("请输入新的课程名称：");            String name = console.next();            Course newCourse = new Course(crID,name);            courses.put(crID, newCourse);            System.out.println("修改成功！");            break;        }    }    public static void main(String[] args) {        MapTest mt = new MapTest();        mt.testPut();        mt.testKeySet();        mt.testRemove();        mt.testModify();        mt.testEntrySet();    }}</code></pre><h2 id="4-5-Collection"><a href="#4-5-Collection" class="headerlink" title="4.5 Collection"></a>4.5 Collection</h2><p><code>java.util.Collections</code> 类提供了许多实用的静态方法，用于对集合进行操作。以下是一些常见的用法示例：</p><ol><li><p><strong>排序列表</strong>：</p><pre><code class="java">List&lt;Integer&gt; numbers = new ArrayList&lt;&gt;();numbers.add(3);numbers.add(1);numbers.add(2);Collections.sort(numbers); // 对列表进行排序</code></pre></li><li><p><strong>反转列表</strong>：</p><pre><code class="java">List&lt;String&gt; names = new ArrayList&lt;&gt;();names.add("Alice");names.add("Bob");names.add("Charlie");Collections.reverse(names); // 反转列表中的元素顺序</code></pre></li><li><p><strong>查找元素</strong>：</p><pre><code class="java">List&lt;Integer&gt; numbers = new ArrayList&lt;&gt;();numbers.add(1);numbers.add(2);numbers.add(3);int index = Collections.binarySearch(numbers, 2); // 在有序列表中执行二分查找</code></pre></li><li><p><strong>随机打乱列表</strong>：</p><pre><code class="java">List&lt;String&gt; cards = new ArrayList&lt;&gt;();cards.add("Ace");cards.add("King");cards.add("Queen");Collections.shuffle(cards); // 随机打乱列表中的元素顺序</code></pre></li><li><p><strong>复制列表</strong>：</p><pre><code class="java">List&lt;String&gt; source = new ArrayList&lt;&gt;();source.add("A");source.add("B");List&lt;String&gt; destination = new ArrayList&lt;&gt;();Collections.copy(destination, source); // 将一个列表的元素复制到另一个列表中</code></pre></li><li><p><strong>填充列表</strong>：</p><pre><code class="java">List&lt;Integer&gt; numbers = new ArrayList&lt;&gt;(Collections.nCopies(5, 0)); // 使用指定元素填充列表</code></pre></li><li><p><strong>创建不可修改的集合</strong>：</p><pre><code class="java">List&lt;String&gt; immutableList = Collections.unmodifiableList(originalList); // 创建不可修改的列表</code></pre></li></ol><h1 id="5-异常"><a href="#5-异常" class="headerlink" title="5 异常"></a>5 异常</h1><h2 id="5-1-分类"><a href="#5-1-分类" class="headerlink" title="5.1 分类"></a>5.1 分类</h2><p>在Java中，异常分为三大类：</p><ol><li><p><strong>受检异常（Checked Exceptions）</strong>：</p><ul><li>受检异常是指在编译时必须处理的异常。这些异常通常是由外部因素引起的，比如文件不存在、网络连接问题等。如果一个方法可能会抛出受检异常，要么在方法内部使用<code>try-catch</code>块捕获异常，要么在方法签名中使用<code>throws</code>关键字声明该异常，通知调用者处理异常。</li></ul><pre><code class="java">try {    // 可能抛出受检异常的代码} catch (IOException e) {    // 处理受检异常}</code></pre></li><li><p><strong>未受检异常（Unchecked Exceptions，也称为运行时异常）</strong>：<code>RuntimeException</code></p><ul><li>未受检异常是指在运行时可能会发生的异常，通常由程序错误引起，比如空指针异常（<code>NullPointerException</code>）、数组越界异常（<code>ArrayIndexOutOfBoundsException</code>）等。这些异常是<code>RuntimeException</code>类及其子类的实例。在编程中，通常不需要显式地捕获这些异常，但最好是在代码中预防它们的发生。</li></ul><pre><code class="java">// 未受检异常的示例：空指针异常String str = null;int length = str.length(); // 这里会抛出空指针异常</code></pre></li><li><p><strong>错误（Errors）</strong>：</p><ul><li>错误是指虚拟机无法处理的严重问题，通常由系统故障引起，比如内存溢出错误（<code>OutOfMemoryError</code>）或虚拟机崩溃。与异常不同，错误通常是不可恢复的。在编写应用程序时，我们不需要关心错误，因为它们通常是由虚拟机或底层系统引起的问题。</li></ul><pre><code class="java">// 错误的示例：内存溢出错误public void recursiveMethod() {    recursiveMethod();}</code></pre></li></ol><h2 id="5-2-处理"><a href="#5-2-处理" class="headerlink" title="5.2 处理"></a>5.2 处理</h2><p>在Java中，你可以使用<code>throws</code>关键字来声明和抛出异常。异常的声明和抛出通常在方法的签名部分进行。以下是如何声明和抛出异常的一般步骤：</p><ol><li><p><strong>在方法签名中声明异常</strong>：</p><ul><li>在方法的参数列表之后，使用 <code>throws</code> 关键字声明可能会被抛出的异常。可以声明多个异常，用逗号分隔。</li></ul><pre><code class="java">public void someMethod() throws SomeException, AnotherException {    // 方法实现}</code></pre></li><li><p><strong>抛出异常</strong>：</p><ul><li>在方法内部，如果满足某个条件导致异常情况，可以使用 <code>throw</code> 关键字抛出异常对象。</li></ul><pre><code class="java">public void someMethod() throws SomeException {    if (/* 满足某个条件 */) {        throw new SomeException("发生了某种异常");    }    // 方法继续执行}</code></pre></li><li><p><strong>捕获异常</strong>：</p><ul><li>当调用抛出异常的方法时，你必须使用 <code>try-catch</code> 块捕获异常，或者将异常继续向上抛出（再次声明）。</li></ul><pre><code class="java">try {    someMethod();} catch (SomeException e) {    // 处理 SomeException 异常} catch (AnotherException e) {    // 处理 AnotherException 异常}</code></pre></li><li><p><strong>继续抛出异常</strong>：</p><ul><li>如果你不打算在当前方法中处理异常，而是希望将异常传递给调用者，可以在方法中继续使用 <code>throws</code> 关键字声明异常。</li></ul><pre><code class="java">public void someMethod() throws SomeException {    if (/* 满足某个条件 */) {        throw new SomeException("发生了某种异常");    }    // 方法继续执行}</code></pre></li></ol><p>通过这种方式，你可以在程序中声明和抛出异常，并根据需要进行适当的异常处理或传递。</p><h2 id="5-3-多异常处理"><a href="#5-3-多异常处理" class="headerlink" title="5.3 多异常处理"></a>5.3 多异常处理</h2><p>在Java中，你可以使用多个 <code>catch</code> 块来捕获多种异常。每个 <code>catch</code> 块用于捕获特定类型的异常，并提供相应的处理逻辑。下面是捕获多个异常的基本语法：</p><pre><code class="java">try {    // 一些可能抛出异常的代码} catch (ExceptionType1 e1) {    // 处理 ExceptionType1 类型的异常} catch (ExceptionType2 e2) {    // 处理 ExceptionType2 类型的异常} catch (ExceptionType3 e3) {    // 处理 ExceptionType3 类型的异常} // and so on for more catch blocks</code></pre><ul><li>在 <code>try</code> 块中，你编写可能抛出异常的代码。</li><li>对于每种可能抛出的异常类型，你可以使用一个 <code>catch</code> 块来捕获和处理该类型的异常。</li><li>按照需要，你可以定义多个 <code>catch</code> 块，每个 <code>catch</code> 块捕获不同类型的异常，并提供相应的处理逻辑。</li></ul><p>如果某个异常类型是另一个异常类型的子类，它应该在其父类之后捕获，因为Java编译器会按照从子类到父类的顺序进行匹配。</p><h2 id="5-4-自定义异常"><a href="#5-4-自定义异常" class="headerlink" title="5.4 自定义异常"></a>5.4 自定义异常</h2><p>在Java中，你可以通过创建一个继承自<code>Exception</code>或<code>RuntimeException</code>的类来自定义异常。这个自定义异常类应该提供自定义异常的特定行为和信息。</p><p>以下是创建自定义异常的基本步骤：</p><p>创建自定义异常类</p><ul><li>创建一个继承自 <code>Exception</code>（受检异常）或 <code>RuntimeException</code>（未受检异常）的类。</li></ul><pre><code class="java">// 自定义受检异常类public class CustomCheckedException extends Exception {    public CustomCheckedException(String message) {        super(message);    }}// 自定义未受检异常类public class CustomUncheckedException extends RuntimeException {    public CustomUncheckedException(String message) {        super(message);    }}</code></pre><p><strong>添加构造函数</strong>：</p><ul><li>在自定义异常类中，添加构造函数以接受异常消息并调用父类的构造函数。</li></ul><p><strong>使用自定义异常</strong>：</p><ul><li>在需要抛出自定义异常的代码中，创建自定义异常的对象并抛出。</li></ul><pre><code class="java">public class Example {    public void someMethod() throws CustomCheckedException {        // 某些情况下抛出自定义受检异常        throw new CustomCheckedException("这是自定义受检异常");    }    public void anotherMethod() {        // 某些情况下抛出自定义未受检异常        throw new CustomUncheckedException("这是自定义未受检异常");    }}</code></pre><p>捕获自定义异常</p><ul><li>在调用抛出自定义异常的方法时，你可以使用 <code>try-catch</code> 块捕获自定义异常并处理它。</li></ul><pre><code class="java">try {    Example example = new Example();    example.someMethod();} catch (CustomCheckedException e) {    // 处理自定义受检异常    e.printStackTrace();}</code></pre><h2 id="5-5-异常堆栈"><a href="#5-5-异常堆栈" class="headerlink" title="5.5 异常堆栈"></a>5.5 异常堆栈</h2><p>异常堆栈（也称为堆栈跟踪或调用堆栈）是在程序执行过程中发生异常时记录的一组调用方法的信息。它提供了一个关于异常发生位置和异常传播路径的详细视图。异常堆栈通常包括以下信息：</p><ol><li>方法调用顺序：异常堆栈列出了程序中从发生异常的地方开始到异常被捕获或程序终止的方法调用序列。这些方法调用以栈的形式排列，最上面的是最近调用的方法，最下面的是最初的调用。</li><li>类名和方法名：堆栈中的每个元素都包括了引发异常的方法的类名和方法名。这有助于确定异常发生的确切位置。</li><li>行号信息：通常，异常堆栈还包括了引发异常的方法中出现异常的代码行号。这使得程序员能够准确定位问题代码的位置。</li></ol><p>异常堆栈对于调试和诊断问题非常有用。当程序抛出异常时，异常堆栈可以帮助开发人员追踪异常的来源，找出问题的根本原因，并更轻松地修复代码中的错误。堆栈跟踪也可以用于记录异常，以便后续的故障排除或错误报告。</p><pre><code class="java">public class ExceptionStackTrace {    private static void method1() {        method2();    }    private static void method2() {        throw new NullPointerException();    }    public static void main(String[] args) {        try {            method1();        } catch (Exception e) {            //打印堆栈轨迹            e.printStackTrace();        }    }}</code></pre><pre><code class="java">java.lang.NullPointerException    at ExceptionStackTrace.method2(ExceptionStackTrace.java:7)    at ExceptionStackTrace.method1(ExceptionStackTrace.java:3)    at ExceptionStackTrace.main(ExceptionStackTrace.java:11)</code></pre><h1 id="6-Lambda"><a href="#6-Lambda" class="headerlink" title="6 Lambda"></a>6 Lambda</h1><h2 id="6-1-使用"><a href="#6-1-使用" class="headerlink" title="6.1 使用"></a>6.1 使用</h2><p>Lambda表达式是Java 8引入的一种函数式编程特性，用于简化匿名内部类的编写以及在函数式接口中定义行为。要实现Lambda表达式，你需要按照以下基本语法规则进行操作：</p><ol><li><strong>确定函数式接口</strong>：首先，你需要有一个函数式接口，它只包含一个抽象方法。函数式接口是一个具有单个抽象方法的接口。</li><li><strong>定义Lambda表达式</strong>：Lambda表达式的一般形式是 <code>(参数) -&gt; 表达式</code>。参数是方法的参数，表达式是方法的实现。可以使用箭头符号 <code>-&gt;</code> 分隔参数和表达式。</li><li><strong>调用Lambda表达式</strong>：将Lambda表达式分配给一个接口类型的变量，然后可以使用该变量来调用Lambda表达式。</li></ol><p>下面是一个简单示例，展示如何创建和使用Lambda表达式：</p><pre><code class="java">// 步骤 1：确定函数式接口@FunctionalInterfaceinterface MyFunction {    int apply(int a, int b);}public class LambdaExample {    public static void main(String[] args) {        // 步骤 2：定义Lambda表达式        MyFunction addition = (a, b) -&gt; a + b;        MyFunction subtraction = (a, b) -&gt; a - b;        // 步骤 3：调用Lambda表达式        int result1 = addition.apply(5, 3); // 调用Lambda表达式执行加法        int result2 = subtraction.apply(5, 3); // 调用Lambda表达式执行减法        System.out.println("Addition result: " + result1);        System.out.println("Subtraction result: " + result2);    }}</code></pre><p>在这个示例中，我们首先定义了一个函数式接口 <code>MyFunction</code>，它具有一个抽象方法 <code>apply</code>。然后，我们创建了两个Lambda表达式 <code>addition</code> 和 <code>subtraction</code>，并使用它们执行加法和减法操作。</p><p>Lambda表达式的强大之处在于可以将它们传递给方法、将它们作为参数传递给其他方法，并以一种简洁的方式表达行为。这在处理集合、多线程等场景中非常有用。</p><h2 id="6-2-作用域"><a href="#6-2-作用域" class="headerlink" title="6.2 作用域"></a>6.2 作用域</h2><p>Lambda表达式的作用域是指Lambda表达式可以访问哪些变量以及它们的生命周期。Lambda表达式的作用域是根据以下规则确定的：</p><ol><li><strong>局部变量</strong>：Lambda表达式可以访问外部方法中的局部变量，但这些局部变量必须满足以下条件：<ul><li>局部变量必须是隐式或显式地声明为 <code>final</code> 或 <code>effectively final</code>。这意味着一旦赋值后，不能再修改这些变量的值。从Java 8开始，如果变量在赋值后没有被再次赋值，它被认为是”effectively final”。</li><li>如果Lambda表达式在一个线程中使用了某个局部变量，那么这个变量必须是线程安全的。</li></ul></li><li><strong>成员变量和静态变量</strong>：Lambda表达式可以自由访问包含它的类的成员变量和静态变量，就像普通的类方法一样。</li><li><strong>方法参数</strong>：Lambda表达式可以访问外部方法的参数，但参数也必须是 <code>final</code> 或 <code>effectively final</code>。</li></ol><p>下面是一个示例，演示了Lambda表达式的作用域：</p><pre><code class="java">public class LambdaScopeExample {    private int instanceVar = 10;    private static int staticVar = 20;    public void lambdaInMethod() {        int localVar = 30; // 局部变量        // Lambda 表达式可以访问局部变量 localVar 和 instanceVar，以及静态变量 staticVar        MyFunctionalInterface myLambda = () -&gt; {            System.out.println("instanceVar: " + instanceVar);            System.out.println("staticVar: " + staticVar);            System.out.println("localVar: " + localVar);        };        myLambda.doSomething();    }    public static void main(String[] args) {        LambdaScopeExample example = new LambdaScopeExample();        example.lambdaInMethod();    }    @FunctionalInterface    interface MyFunctionalInterface {        void doSomething();    }}</code></pre><p>在这个示例中，Lambda表达式 <code>myLambda</code> 可以访问 <code>instanceVar</code>（成员变量）、<code>staticVar</code>（静态变量），以及 <code>localVar</code>（局部变量），因为它们都符合Lambda表达式的作用域规则。如果你尝试在Lambda表达式内部修改 <code>localVar</code> 的值，将会导致编译错误，因为它不是<code>final</code>或<code>effectively final</code>的。</p><blockquote><p>相对于普通的类方法，Lambda表达式的主要区别在于它们可以访问外部作用域的变量，这是通过闭包实现的。以下是Lambda表达式与普通类方法之间的主要区别：</p><ol><li><strong>变量访问</strong>：<ul><li><strong>Lambda表达式</strong>：Lambda表达式可以访问包含它们的方法的局部变量（必须是<code>final</code>或<code>effectively final</code>），成员变量，以及静态变量。</li><li><strong>普通类方法</strong>：普通类方法只能访问它们所属类的成员变量和静态变量，不能直接访问方法中的局部变量。</li></ul></li><li><strong>this关键字</strong>：<ul><li><strong>Lambda表达式</strong>：Lambda表达式中的<code>this</code>关键字指向它所在的外部类。</li><li><strong>普通类方法</strong>：普通类方法中的<code>this</code>关键字指向该类的实例。</li></ul></li><li><strong>对接口的依赖</strong>：<ul><li><strong>Lambda表达式</strong>：Lambda表达式依赖于函数式接口，即接口中只有一个抽象方法。它们可以实现该接口并提供方法实现。</li><li><strong>普通类方法</strong>：普通类方法可以属于任何类，无需依赖于特定的接口。</li></ul></li><li><strong>简洁性</strong>：<ul><li><strong>Lambda表达式</strong>：Lambda表达式通常比传统的匿名内部类更为简洁，可以在更少的代码行中表达相同的逻辑。</li></ul></li><li><strong>使用场景</strong>：<ul><li><strong>Lambda表达式</strong>：适用于简单的功能接口实现，尤其是在集合处理、线程处理等函数式编程场景中。</li><li><strong>普通类方法</strong>：适用于一般的方法实现，可能需要较多的代码和复杂的逻辑。</li></ul></li></ol><p>总的来说，Lambda表达式提供了一种更简洁、更函数式的方法来实现特定的功能接口，特别适用于对集合进行操作或实现简单功能的情况。它们使得代码更为紧凑，更容易理解和维护。然而，在某些情况下，传统的类方法可能更适合复杂的业务逻辑或需要多个方法的情况。</p></blockquote><h2 id="6-3-方法引用"><a href="#6-3-方法引用" class="headerlink" title="6.3 方法引用"></a>6.3 方法引用</h2><p>在Java中，方法引用是一种简化Lambda表达式的语法，用于调用已经存在的方法。它可以替代Lambda表达式，使代码更加简洁易读。</p><p>方法引用通常用于函数式接口的实例化，函数式接口是只包含一个抽象方法的接口。方法引用可以用来引用以下类型的方法：</p><ol><li>静态方法引用：引用静态方法。</li><li>对象方法引用：引用特定对象的实例方法。</li><li>类型方法引用：引用特定类型的任意对象的实例方法。</li></ol><p>以下是一些方法引用的示例：</p><ul><li><p>静态方法引用：</p><pre><code class="java">// 使用方法引用调用静态方法Function&lt;Integer, Integer&gt; square = Math::square;</code></pre></li><li><p>对象方法引用：</p><pre><code class="java">// 使用方法引用调用实例方法List&lt;String&gt; names = Arrays.asList("Alice", "Bob", "Charlie");names.forEach(System.out::println);</code></pre></li><li><p>类型方法引用：</p><pre><code class="java">// 使用方法引用调用类型方法Comparator&lt;String&gt; stringComparator = String::compareToIgnoreCase;</code></pre></li></ul><p>方法引用通过<code>::</code>符号后跟方法名来引用方法，而不需要提供方法的具体实现，编译器会根据上下文自动推断。</p><h2 id="6-4-函数式编程"><a href="#6-4-函数式编程" class="headerlink" title="6.4 函数式编程"></a>6.4 函数式编程</h2><p><code>java.util.Function</code> 是一个函数式接口，它接受一个输入参数并返回一个结果。它定义了一个名为 <code>apply</code> 的抽象方法，用于将输入转换为输出。</p><p>该接口通常用于将操作作为参数传递给其他方法，例如在 Stream API 中进行数据处理，或者在函数式编程中进行函数组合。</p><p>以下是一个简单的示例，演示了如何使用 <code>java.util.Function</code> 接口：</p><pre><code class="java">import java.util.function.Function;public class FunctionExample {    public static void main(String[] args) {        // 创建一个 Function，将输入值乘以2并返回        Function&lt;Integer, Integer&gt; multiplyBy2 = x -&gt; x * 2;        // 使用 apply 方法应用函数        int result = multiplyBy2.apply(5); // 结果为 10        System.out.println(result);    }}</code></pre><p>在这个例子中，我们首先创建了一个 <code>Function</code> 对象 <code>multiplyBy2</code>，它将输入值乘以2。然后，我们调用 <code>apply</code> 方法将输入值 <code>5</code> 应用到函数上，得到了结果 <code>10</code>。</p><ol><li><strong>Consumer (消费者)：</strong><ul><li><strong>描述：</strong> 表示接受单个输入参数并且不返回结果的操作。</li><li><strong>接口方法：</strong> <code>void accept(T t)</code></li></ul></li><li><strong>Function (函数)：</strong><ul><li><strong>描述：</strong> 表示接受一个输入参数并产生一个结果的函数。</li><li><strong>接口方法：</strong> <code>R apply(T t)</code></li></ul></li><li><strong>Supplier (供应商)：</strong><ul><li><strong>描述：</strong> 表示一个供应商，不接受任何参数，但返回一个结果。</li><li><strong>接口方法：</strong> <code>T get()</code></li></ul></li><li><strong>Predicate (断言)：</strong><ul><li><strong>描述：</strong> 表示一个断言（布尔值函数），接受一个参数并返回一个布尔值结果。</li><li><strong>接口方法：</strong> <code>boolean test(T t)</code></li></ul></li><li><strong>UnaryOperator (一元操作符)：</strong><ul><li><strong>描述：</strong> 表示一个一元操作符，接受一个参数并返回与该参数相同类型的结果。</li><li><strong>接口方法：</strong> <code>T apply(T t)</code></li></ul></li><li><strong>BinaryOperator (二元操作符)：</strong><ul><li><strong>描述：</strong> 表示一个二元操作符，接受两个参数并返回与参数相同类型的结果。</li><li><strong>接口方法：</strong> <code>T apply(T t1, T t2)</code></li></ul></li></ol><pre><code class="java">import java.util.Arrays;import java.util.List;import java.util.function.Predicate;public class FunctionTest {   public static void main(String args[]){      // 创建一个包含整数的列表      List&lt;Integer&gt; list = Arrays.asList(0, 1, 2, 3, 4, 5, 6, 7, 8, 9);      System.out.println("All of the numbers:");      // 使用 Predicate 过滤并打印所有数字      eval(list, n-&gt;true);      System.out.println("Even numbers:");      // 使用 Predicate 过滤并打印偶数      eval(list, n-&gt; n%2 == 0 );      System.out.println("Numbers that are greater than 5:");      // 使用 Predicate 过滤并打印大于5的数字      eval(list, n -&gt; n &gt; 5 );   }   // 通用的方法，接受列表和 Predicate，用于过滤和打印符合条件的元素   public static void eval(List&lt;Integer&gt; list, Predicate&lt;Integer&gt; predicate) {      for(Integer n: list) {         // 使用 Predicate 测试元素是否满足条件，然后打印符合条件的元素         if(predicate.test(n)) {            System.out.println(n);         }      }   }}</code></pre><h1 id="7-Stream"><a href="#7-Stream" class="headerlink" title="7 Stream"></a>7 Stream</h1><h2 id="7-1-创建流"><a href="#7-1-创建流" class="headerlink" title="7.1 创建流"></a>7.1 创建流</h2><p>要创建一个流（Stream）对象，你可以使用以下方式：</p><ol><li>从集合创建流：你可以从集合（如List、Set、Map等）创建一个流。Java中的集合提供了<code>stream()</code>方法来生成流。</li></ol><pre><code class="java">List&lt;String&gt; myList = Arrays.asList("apple", "banana", "cherry");Stream&lt;String&gt; stream = myList.stream();</code></pre><ol><li>从数组创建流：你也可以从数组创建流，使用<code>Arrays.stream()</code>方法。</li></ol><pre><code class="java">int[] numbers = {1, 2, 3, 4, 5};IntStream stream = Arrays.stream(numbers);</code></pre><ol><li>使用Stream.of()创建流：你可以使用<code>Stream.of()</code>方法创建一个包含指定元素的流。</li></ol><pre><code class="java">Stream&lt;String&gt; stream = Stream.of("apple", "banana", "cherry");</code></pre><ol><li>使用Stream.generate()创建无限流：如果需要创建一个无限流，可以使用<code>Stream.generate()</code>方法，并传入一个生成元素的Supplier。</li></ol><pre><code class="java">Stream&lt;Integer&gt; infiniteStream = Stream.generate(() -&gt; 1);</code></pre><ol><li>使用Stream.iterate()创建无限流：类似于<code>Stream.generate()</code>，你也可以使用<code>Stream.iterate()</code>创建一个无限流，但需要提供一个初始值和一个UnaryOperator来生成后续的值。</li></ol><pre><code class="java">Stream&lt;Integer&gt; infiniteStream = Stream.iterate(1, n -&gt; n + 1);</code></pre><h2 id="7-2-操作流"><a href="#7-2-操作流" class="headerlink" title="7.2 操作流"></a>7.2 操作流</h2><p>当使用Java中的<code>Stream</code>时，你可以执行各种操作，包括中间操作和终端操作。以下是一些<code>Stream</code>的常见用法，以及相应的示例：</p><p><strong>1. 过滤（Filter）：</strong> 使用<code>filter</code>中间操作来筛选出满足条件的元素。</p><pre><code class="java">List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);List&lt;Integer&gt; evenNumbers = numbers.stream()    .filter(n -&gt; n % 2 == 0)    .collect(Collectors.toList());// evenNumbers 现在包含 [2, 4, 6, 8, 10]</code></pre><p><strong>2. 映射（Map）：</strong> 使用<code>map</code>中间操作将元素映射成新的值。</p><pre><code class="java">List&lt;String&gt; names = Arrays.asList("Alice", "Bob", "Charlie");List&lt;Integer&gt; nameLengths = names.stream()    .map(String::length)    .collect(Collectors.toList());// nameLengths 现在包含 [5, 3, 7]</code></pre><p><strong>3. 排序（Sort）：</strong> 使用<code>sorted</code>中间操作对元素进行排序。</p><pre><code class="java">List&lt;Integer&gt; numbers = Arrays.asList(5, 2, 8, 1, 9);List&lt;Integer&gt; sortedNumbers = numbers.stream()    .sorted()    .collect(Collectors.toList());// sortedNumbers 现在包含 [1, 2, 5, 8, 9]</code></pre><p><strong>4. 聚合（Reduce）：</strong> 使用<code>reduce</code>终端操作对元素进行聚合操作，如求和、求最大值、求最小值等。</p><pre><code class="java">List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5);int sum = numbers.stream()    .reduce(0, (a, b) -&gt; a + b);// sum 现在等于 15</code></pre><p><strong>5. 收集（Collect）：</strong> 使用<code>collect</code>终端操作将流中的元素收集到一个集合中。</p><pre><code class="java">List&lt;String&gt; fruits = Arrays.asList("apple", "banana", "cherry");Set&lt;String&gt; fruitSet = fruits.stream()    .collect(Collectors.toSet());// fruitSet 现在包含 {"apple", "banana", "cherry"}</code></pre><p><strong>6. 遍历（ForEach）：</strong> 使用<code>forEach</code>终端操作对流中的每个元素执行指定操作。</p><pre><code class="java">List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5);numbers.stream()    .forEach(System.out::println);// 将每个数字打印到控制台</code></pre><p>在Java中，<code>peek()</code> 方法是Java流（Stream）类提供的一个中间操作方法之一。它允许你在流的每个元素被处理时执行一个操作，但不会改变流的内容，而是返回原始流。<code>peek()</code> 方法通常用于调试和观察流的操作，以便查看流的中间状态，而不会影响流的最终结果。</p><p>该方法的签名如下：</p><pre><code class="java">Stream&lt;T&gt; peek(Consumer&lt;? super T&gt; action)</code></pre><p>其中，<code>action</code> 是一个接受类型为 <code>T</code> 的元素的消费者函数，你可以在这个函数中执行任何你想要的操作。</p><p>例如，假设你有一个整数流，你可以使用 <code>peek()</code> 方法来打印每个元素，并查看它们的值，而不改变流的内容：</p><pre><code class="java">List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5);numbers.stream()       .peek(num -&gt; System.out.println("Processing: " + num))       .map(num -&gt; num * 2)       .forEach(System.out::println);</code></pre><p>在上面的示例中，<code>peek()</code> 方法用于输出每个元素的处理状态，但不会更改流的元素。然后，<code>map()</code> 方法将每个元素乘以2，最后使用 <code>forEach()</code> 方法打印结果。这个操作链允许你在流的处理过程中观察元素的中间状态。</p><h2 id="7-3-Collectors"><a href="#7-3-Collectors" class="headerlink" title="7.3 Collectors"></a>7.3 Collectors</h2><p><code>Collectors</code> 是 Java 中用于收集（或汇总）流中元素的工具类，它提供了各种用于收集数据的静态方法。<code>Collectors</code> 的主要用法包括：</p><p><strong>1. 收集到List、Set或其他集合类型：</strong></p><ul><li><code>Collectors.toList()</code>：将流中的元素收集到一个<code>List</code>中。</li><li><code>Collectors.toSet()</code>：将流中的元素收集到一个<code>Set</code>中。</li><li><code>Collectors.toCollection(collectionFactory)</code>：将流中的元素收集到指定类型的集合中。</li></ul><p>示例：</p><pre><code class="java">List&lt;String&gt; names = Stream.of("Alice", "Bob", "Charlie")    .collect(Collectors.toList());</code></pre><p><strong>2. 收集到Map：</strong></p><ul><li><code>Collectors.toMap(keyMapper, valueMapper)</code>：将流中的元素收集到一个<code>Map</code>中，可以指定如何映射键和值。</li><li><code>Collectors.toConcurrentMap(keyMapper, valueMapper)</code>：类似于<code>toMap</code>，但返回的是一个并发安全的<code>ConcurrentMap</code>。</li></ul><p>示例：</p><pre><code class="java">Map&lt;String, Integer&gt; nameLengthMap = Stream.of("Alice", "Bob", "Charlie")    .collect(Collectors.toMap(name -&gt; name, String::length));</code></pre><p><strong>3. 字符串连接：</strong></p><ul><li><code>Collectors.joining(delimiter)</code>：将流中的元素连接成一个字符串，可以指定连接符。</li></ul><p>示例：</p><pre><code class="java">String joinedNames = Stream.of("Alice", "Bob", "Charlie")    .collect(Collectors.joining(", "));// joinedNames 现在等于 "Alice, Bob, Charlie"</code></pre><p><strong>4. 统计汇总信息：</strong></p><ul><li><code>Collectors.summarizingInt(ToIntFunction)</code>：对<code>int</code>类型的元素进行汇总，包括计数、总和、最大值、最小值、平均值等信息。</li><li><code>Collectors.summarizingDouble(ToDoubleFunction)</code>：类似于<code>summarizingInt</code>，但适用于<code>double</code>类型的元素。</li></ul><p>示例：</p><pre><code class="java">IntSummaryStatistics stats = Stream.of(1, 2, 3, 4, 5)    .collect(Collectors.summarizingInt(Integer::intValue));</code></pre><p><strong>5. 分组和分区：</strong></p><ul><li><code>Collectors.groupingBy(classifier)</code>：根据指定条件对元素进行分组，返回一个<code>Map</code>，键是分组条件，值是分组的元素列表。</li><li><code>Collectors.partitioningBy(predicate)</code>：根据指定条件将元素分成两组（true和false），返回一个<code>Map</code>，键是true或false，值是符合条件的元素列表。</li></ul><p>示例：</p><pre><code class="java">Map&lt;Integer, List&lt;String&gt;&gt; groupByLength = Stream.of("Alice", "Bob", "Charlie")    .collect(Collectors.groupingBy(String::length));Map&lt;Boolean, List&lt;String&gt;&gt; partitionByLength = Stream.of("Alice", "Bob", "Charlie")    .collect(Collectors.partitioningBy(name -&gt; name.length() &gt; 4));</code></pre><h2 id="7-4-flatMap"><a href="#7-4-flatMap" class="headerlink" title="7.4 flatMap"></a>7.4 flatMap</h2><p>你可以使用Java中的Stream API中的<code>flatMap</code>方法来操作流并实现合并和转换的功能。下面是使用<code>flatMap</code>的一些常见示例和用法：</p><p><strong>示例1：合并多个流</strong></p><p>假设你有多个字符串流，想将它们合并成一个单一的字符串流：</p><pre><code class="java">Stream&lt;String&gt; stream1 = Stream.of("Hello", "World");Stream&lt;String&gt; stream2 = Stream.of("Java", "Programming");Stream&lt;String&gt; mergedStream = Stream.of(stream1, stream2)    .flatMap(Function.identity());mergedStream.forEach(System.out::println);</code></pre><p>这会输出：</p><pre><code class="java">HelloWorldJavaProgramming</code></pre><p>在这个示例中，我们使用<code>flatMap</code>合并了<code>stream1</code>和<code>stream2</code>，并通过<code>Function.identity()</code>函数将它们扁平化。</p><p><strong>示例2：元素转换</strong></p><p>假设你有一个字符串流，想将每个字符串拆分为单词并得到单词的流：</p><pre><code class="java">Stream&lt;String&gt; stringStream = Stream.of("Hello World", "Java Programming");Stream&lt;String&gt; wordStream = stringStream    .flatMap(str -&gt; Stream.of(str.split(" ")));wordStream.forEach(System.out::println);</code></pre><p>这会输出：</p><pre><code class="java">HelloWorldJavaProgramming</code></pre><p>在这个示例中，我们使用<code>flatMap</code>将每个字符串分割为单词，并将它们合并成一个单词流。</p><p><strong>示例3：扁平化嵌套集合</strong></p><p>假设你有一个包含多个子集合的集合，想将它们扁平化为单一流：</p><pre><code class="java">List&lt;List&lt;Integer&gt;&gt; nestedList = Arrays.asList(    Arrays.asList(1, 2, 3),    Arrays.asList(4, 5),    Arrays.asList(6, 7, 8));Stream&lt;Integer&gt; flattenedStream = nestedList    .stream()    .flatMap(List::stream);flattenedStream.forEach(System.out::println);</code></pre><p>这会输出：</p><pre><code class="java">12345678</code></pre><p>在这个示例中，我们使用<code>flatMap</code>将嵌套的列表转换为单一流，以便更容易处理其中的元素。</p><h2 id="7-5-实例"><a href="#7-5-实例" class="headerlink" title="7.5 实例"></a>7.5 实例</h2><pre><code class="java">import java.util.ArrayList;import java.util.Arrays;import java.util.IntSummaryStatistics;import java.util.List;import java.util.Random;import java.util.stream.Collectors;import java.util.Map;public class StreamTest {    public static void main(String args[]) {        System.out.println("Using Java 7: ");        // 统计空字符串的数量        List&lt;String&gt; strings = Arrays.asList("efg", "", "abc", "bc", "ghij", "", "lmn");        System.out.println("List: " + strings);        long count = getCountEmptyStringUsingJava7(strings);        System.out.println("Empty Strings: " + count);        count = getCountLength3UsingJava7(strings);        System.out.println("Strings of length 3: " + count);        // 消除空字符串        List&lt;String&gt; filtered = deleteEmptyStringsUsingJava7(strings);        System.out.println("Filtered List: " + filtered);        // 消除空字符串，同时使用逗号来连接        String mergedString = getMergedStringUsingJava7(strings, ", ");        System.out.println("Merged String: " + mergedString);        List&lt;Integer&gt; numbers = Arrays.asList(2, 3, 3, 2, 5, 2, 7);        // 获得不同数字的平方的列表        List&lt;Integer&gt; squaresList = getSquares(numbers);        System.out.println("Squares List: " + squaresList);        List&lt;Integer&gt; integers = Arrays.asList(1, 2, 13, 4, 15, 6, 17, 8, 19);        System.out.println("List: " + integers);        System.out.println("Highest number in List : " + getMax(integers));        System.out.println("Lowest number in List : " + getMin(integers));        System.out.println("Sum of all numbers : " + getSum(integers));        System.out.println("Average of all numbers : " + getAverage(integers));        // 输出10个随机数        System.out.println("Random Numbers: ");        Random random = new Random();        for (int i = 0; i &lt; 10; i++) {            System.out.println(random.nextInt());        }        // 使用Java 8的新特性        System.out.println("Using Java 8: ");        System.out.println("List: " + strings);        count = strings.stream().filter(string -&gt; string.isEmpty()).count();        System.out.println("Empty Strings: " + count);        count = strings.stream().filter(string -&gt; string.length() == 3).count();        System.out.println("Strings of length 3: " + count);        filtered = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.toList());        System.out.println("Filtered List: " + filtered);        mergedString = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.joining(", "));        System.out.println("Merged String: " + mergedString);        squaresList = numbers.stream().map(i -&gt; i * i).distinct().collect(Collectors.toList());        System.out.println("Squares List: " + squaresList);        System.out.println("List: " + integers);        IntSummaryStatistics stats = integers.stream().mapToInt((x) -&gt; x).summaryStatistics();        // 输出结果        System.out.println("Highest number in List : " + stats.getMax());        System.out.println("Lowest number in List : " + stats.getMin());        System.out.println("Sum of all numbers : " + stats.getSum());        System.out.println("Average of all numbers : " + stats.getAverage());        System.out.println("Random Numbers: ");        random.ints().limit(10).sorted().forEach(System.out::println);        // 并行处理        count = strings.parallelStream().filter(string -&gt; string.isEmpty()).count();        System.out.println("Empty Strings: " + count);    }    // 使用Java 7版本就提供的API来计算空串数量    private static int getCountEmptyStringUsingJava7(List&lt;String&gt; strings) {        int count = 0;        for (String string : strings) {            if (string.isEmpty()) {                count++;            }        }        return count;    }    // 使用Java 7版本就提供的API来计算长度为3字符的字符串数量    private static int getCountLength3UsingJava7(List&lt;String&gt; strings) {        int count = 0;        for (String string : strings) {            if (string.length() == 3) {                count++;            }        }        return count;    }    // 使用Java 7版本就提供的API来删除空串    private static List&lt;String&gt; deleteEmptyStringsUsingJava7(List&lt;String&gt; strings) {        List&lt;String&gt; filteredList = new ArrayList&lt;String&gt;();        for (String string : strings) {            if (!string.isEmpty()) {                filteredList.add(string);            }        }        return filteredList;    }    // 使用Java 7版本就提供的API来获取合并后的字符串    private static String getMergedStringUsingJava7(List&lt;String&gt; strings, String separator) {        StringBuilder stringBuilder = new StringBuilder();        for (String string : strings) {            if (!string.isEmpty()) {                stringBuilder.append(string);                stringBuilder.append(separator);            }        }        String mergedString = stringBuilder.toString();        return mergedString.substring(0, mergedString.length() - 2);    }    // 自定义的用于计算数字的平方的方法    private static List&lt;Integer&gt; getSquares(List&lt;Integer&gt; numbers) {        List&lt;Integer&gt; squaresList = new ArrayList&lt;Integer&gt;();        for (Integer number : numbers) {            Integer square = new Integer(number.intValue() * number.intValue());            if (!squaresList.contains(square)) {                squaresList.add(square);            }        }        return squaresList;    }    // 自定义的用于获得List中最大值的方法    private static int getMax(List&lt;Integer&gt; numbers) {        int max = numbers.get(0);        for (int i = 1; i &lt; numbers.size(); i++) {            Integer number = numbers.get(i);            if (number.intValue() &gt; max) {                max = number.intValue();            }        }        return max;    }    // 自定义的用于获得List中最小值的方法    private static int getMin(List&lt;Integer&gt; numbers) {        int min = numbers.get(0);        for (int i = 1; i &lt; numbers.size(); i++) {            Integer number = numbers.get(i);            if (number.intValue() &lt; min) {                min = number.intValue();            }        }        return min;    }    // 自定义的用于获得List中各个数字的和的方法    private static int getSum(List&lt;Integer&gt; numbers) {        int sum = (int) (numbers.get(0));        for (int i = 1; i &lt; numbers.size(); i++) {            sum += (int) numbers.get(i);        }        return sum;    }    // 自定义的用于获得List中各个数字的平均值的方法    private static int getAverage(List&lt;Integer&gt; numbers) {        return getSum(numbers) / numbers.size();    }}</code></pre><h1 id="8-IO"><a href="#8-IO" class="headerlink" title="8 IO"></a>8 IO</h1><h2 id="8-1-文件"><a href="#8-1-文件" class="headerlink" title="8.1 文件"></a>8.1 文件</h2><p><code>java.io.File</code> 类是 Java 中用于操作文件和目录的基本类之一。它允许你创建、删除、重命名、查询文件和目录的属性等操作。以下是一些常见的 <code>File</code> 类的用法和示例：</p><ol><li><p>创建 <code>File</code> 对象：</p><ul><li>通过指定文件或目录的路径来创建 <code>File</code> 对象。</li></ul><pre><code class="java">File file = new File("/path/to/file.txt");File directory = new File("/path/to/directory");</code></pre></li><li><p>检查文件或目录是否存在：</p><ul><li>使用 <code>exists()</code> 方法检查文件或目录是否存在。</li></ul><pre><code class="java">boolean exists = file.exists();</code></pre></li><li><p>创建文件或目录：</p><ul><li>使用 <code>createNewFile()</code> 方法创建文件。</li></ul><pre><code class="java">boolean created = file.createNewFile();</code></pre><ul><li>使用 <code>mkdir()</code> 方法创建目录。</li></ul><pre><code class="java">boolean created = directory.mkdir();</code></pre></li><li><p>删除文件或目录：</p><ul><li>使用 <code>delete()</code> 方法删除文件或目录。</li></ul><pre><code class="java">boolean deleted = file.delete();</code></pre></li><li><p>获取文件或目录的属性：</p><ul><li>使用 <code>getName()</code> 方法获取文件或目录的名称。</li></ul><pre><code class="java">String name = file.getName();</code></pre><ul><li>使用 <code>isFile()</code> 和 <code>isDirectory()</code> 方法检查文件或目录的类型。</li></ul><pre><code class="java">boolean isFile = file.isFile();boolean isDirectory = directory.isDirectory();</code></pre></li><li><p>获取文件大小和最后修改时间：</p><ul><li>使用 <code>length()</code> 方法获取文件大小（字节数）。</li></ul><pre><code class="java">long fileSize = file.length();</code></pre><ul><li>使用 <code>lastModified()</code> 方法获取文件的最后修改时间戳。</li></ul><pre><code class="java">long lastModifiedTime = file.lastModified();</code></pre></li><li><p>列出目录中的文件和子目录：</p><ul><li>使用 <code>list()</code> 方法获取目录中的所有文件和子目录的名称。</li></ul><pre><code class="java">String[] contents = directory.list();</code></pre><ul><li>使用 <code>listFiles()</code> 方法获取目录中的所有文件和子目录的 <code>File</code> 对象。</li></ul><pre><code class="java">File[] files = directory.listFiles();</code></pre></li><li><p>重命名文件或目录：</p><ul><li>使用 <code>renameTo()</code> 方法重命名文件或目录。</li></ul><pre><code class="java">File newFile = new File("/path/to/new_name.txt");boolean renamed = file.renameTo(newFile);</code></pre></li></ol><h2 id="8-2-文件流"><a href="#8-2-文件流" class="headerlink" title="8.2 文件流"></a>8.2 文件流</h2><p>文件输入流（FileInputStream）：</p><ol><li><p>导入必要的输入输出流类：</p><pre><code class="java">import java.io.FileInputStream;import java.io.IOException;</code></pre></li><li><p>创建 <code>FileInputStream</code> 对象并打开文件：</p><pre><code class="java">FileInputStream fileInputStream = new FileInputStream("path/to/your/file.txt");</code></pre></li><li><p>读取文件内容：</p><ul><li>使用 <code>read()</code> 方法逐个字节读取文件内容。</li></ul><pre><code class="java">int data;while ((data = fileInputStream.read()) != -1) {    // 处理读取到的字节数据，可以将其转换成字符或做其他处理    char character = (char) data;    System.out.print(character);}</code></pre></li><li><p>关闭文件输入流：</p><pre><code class="java">fileInputStream.close();</code></pre></li></ol><p>文件输出流（FileOutputStream）：</p><ol><li><p>导入必要的输入输出流类：</p><pre><code class="java">import java.io.FileOutputStream;import java.io.IOException;</code></pre></li><li><p>创建 <code>FileOutputStream</code> 对象并打开文件：</p><pre><code class="java">FileOutputStream fileOutputStream = new FileOutputStream("path/to/your/output/file.txt");</code></pre></li><li><p>写入数据到文件：</p><ul><li>使用 <code>write()</code> 方法写入字节数组到文件。</li></ul><pre><code class="java">String text = "Hello, world!";byte[] bytes = text.getBytes();fileOutputStream.write(bytes);</code></pre></li><li><p>关闭文件输出流：</p><pre><code class="java">fileOutputStream.close();</code></pre></li></ol><p>3.<code>BufferedReader</code> 是 Java 中的一个字符缓冲输入流类，它用于高效读取文本文件的内容。它通常与其他字符输入流一起使用，如 <code>FileReader</code> 或 <code>InputStreamReader</code>，以提高读取性能和效率。</p><p><code>BufferedReader</code> 具有以下主要特点和功能：</p><ol><li>缓冲机制：<code>BufferedReader</code> 在内部维护一个缓冲区，可以一次性读取多个字符，然后逐个提供给程序。这减少了频繁的磁盘或网络访问，从而提高了读取效率。</li><li>逐行读取：<code>BufferedReader</code> 提供了 <code>readLine()</code> 方法，允许你逐行读取文本文件的内容，这在处理文本文件时非常常见。</li><li>自动字符编码：<code>BufferedReader</code> 默认会根据系统的字符编码自动处理字符解码，这意味着它可以正确处理不同字符编码的文本文件。</li><li>提供字符数组读取：除了逐行读取外，你还可以使用 <code>read(char[] cbuf, int off, int len)</code> 方法来读取指定数量的字符到字符数组中。</li><li>支持跳过字符：它还提供了 <code>skip(long n)</code> 方法，允许你跳过指定数量的字符。</li></ol><p>以下是创建和使用 <code>BufferedReader</code> 的基本示例：</p><pre><code class="java">import java.io.BufferedReader;import java.io.FileReader;import java.io.IOException;public class BufferedReaderExample {    public static void main(String[] args) {        try {            FileReader fileReader = new FileReader("path/to/your/textfile.txt");            BufferedReader bufferedReader = new BufferedReader(fileReader);                        String line;            while ((line = bufferedReader.readLine()) != null) {                // 处理每一行文本数据                System.out.println(line);            }                        bufferedReader.close();            fileReader.close();        } catch (IOException e) {            e.printStackTrace();        }    }}</code></pre><p>在上面的示例中，我们使用了 <code>BufferedReader</code> 来逐行读取文本文件的内容，并确保在使用完毕后关闭流以释放资源。</p><h2 id="8-3-RandomAccessFile"><a href="#8-3-RandomAccessFile" class="headerlink" title="8. 3 RandomAccessFile"></a>8. 3 RandomAccessFile</h2><p><code>RandomAccessFile</code> 是 Java 中用于随机访问文件的类，它允许你在文件中定位特定的位置并读取或写入数据。你可以使用 <code>RandomAccessFile</code> 执行以下操作：</p><ol><li>打开文件：使用 <code>RandomAccessFile</code> 的构造函数来打开文件，并指定文件名和打开模式（只读、读写等）。</li><li>定位文件指针：使用 <code>seek()</code> 方法来定位文件中的指针位置，以便读取或写入数据。</li><li>读取数据：使用 <code>read()</code> 方法来从文件中读取数据。</li><li>写入数据：使用 <code>write()</code> 方法来向文件中写入数据。</li><li>关闭文件：在完成操作后，使用 <code>close()</code> 方法关闭文件。</li></ol><p>以下是一个示例，演示如何使用 <code>RandomAccessFile</code> 来读取和写入文件：</p><pre><code class="java">import java.io.RandomAccessFile;import java.io.IOException;public class RandomAccessFileExample {    public static void main(String[] args) {        try {            // 打开文件，使用 "rw" 表示读写模式            RandomAccessFile file = new RandomAccessFile("path/to/your/file.txt", "rw");            // 定位文件指针到特定位置            file.seek(10); // 将文件指针定位到第11个字节的位置            // 读取数据            byte[] data = new byte[20];            int bytesRead = file.read(data); // 从当前文件指针位置读取20个字节的数据            System.out.println(new String(data, 0, bytesRead)); // 将读取的数据转换为字符串并输出            // 写入数据            file.seek(30); // 将文件指针定位到第31个字节的位置            String newData = "New data to write.";            file.write(newData.getBytes());            // 关闭文件            file.close();        } catch (IOException e) {            e.printStackTrace();        }    }}</code></pre><p>在上面的示例中，我们使用 <code>RandomAccessFile</code> 打开文件，定位文件指针，读取数据，写入数据，然后关闭文件。请注意，在实际应用中，你需要处理可能抛出的 <code>IOException</code> 异常，并确保在不再需要访问文件时关闭文件，以释放资源。</p><pre><code class="java">import java.io.RandomAccessFile;public class FileDemo {    public static void main(String[] args) {        int[] data_arr = {12, 32, 43, 45, 1, 5};        try {            // 打开一个名为 "temp.txt" 的文件，以读写模式打开            RandomAccessFile randomAccessFile = new RandomAccessFile("temp.txt", "rw");            // 循环遍历整数数组并将每个整数写入文件            for(int i = 0; i &lt; data_arr.length; i++){                randomAccessFile.writeInt(data_arr[i]);            }            // 从文件中逆序读取整数并打印它们            for(int i = data_arr.length-1; i &gt;= 0; i--){                // 定位文件指针到正确的位置，每个整数占用 4 个字节                randomAccessFile.seek(i * 4L);                                // 读取整数并打印                System.out.println(randomAccessFile.readInt());            }            // 关闭文件            randomAccessFile.close();        } catch (Exception e) {            e.printStackTrace();        }    }}</code></pre><h2 id="8-4-Files工具类"><a href="#8-4-Files工具类" class="headerlink" title="8.4 Files工具类"></a>8.4 Files工具类</h2><p>以下是一些常见的 <code>Files</code> 工具类的用法：</p><ol><li><p>复制文件或目录：</p><pre><code class="java">Path source = Paths.get("source.txt");Path target = Paths.get("target.txt");Files.copy(source, target, StandardCopyOption.REPLACE_EXISTING);</code></pre></li><li><p>移动文件或目录：</p><pre><code class="java">Path source = Paths.get("source.txt");Path target = Paths.get("new_directory/target.txt");Files.move(source, target, StandardCopyOption.REPLACE_EXISTING);</code></pre></li><li><p>删除文件或目录：</p><pre><code class="java">Path path = Paths.get("file_or_directory_to_delete.txt");Files.delete(path);</code></pre></li><li><p>创建文件：</p><pre><code class="java">Path file = Paths.get("new_file.txt");Files.createFile(file);</code></pre></li><li><p>创建目录：</p><pre><code class="java">Path directory = Paths.get("new_directory");Files.createDirectory(directory);</code></pre></li><li><p>创建多层次目录：</p><pre><code class="java">Path directories = Paths.get("parent_directory/child_directory");Files.createDirectories(directories);</code></pre></li><li><p>读取文件内容：</p><pre><code class="java">Path file = Paths.get("file.txt");List&lt;String&gt; lines = Files.readAllLines(file, StandardCharsets.UTF_8);</code></pre></li><li><p>写入文件内容：</p><pre><code class="java">Path file = Paths.get("file.txt");List&lt;String&gt; lines = Arrays.asList("Line 1", "Line 2", "Line 3");Files.write(file, lines, StandardCharsets.UTF_8);</code></pre></li><li><p>检查文件或目录是否存在：</p><pre><code class="java">Path path = Paths.get("file_or_directory.txt");boolean exists = Files.exists(path);</code></pre></li><li><p>获取文件属性：</p><pre><code class="java">Path file = Paths.get("file.txt");BasicFileAttributes attributes = Files.readAttributes(file, BasicFileAttributes.class);</code></pre></li></ol><h2 id="8-5-file"><a href="#8-5-file" class="headerlink" title="8.5 file"></a>8.5 file</h2><pre><code class="java">import java.io.IOException;import java.nio.file.Files;import java.nio.file.Paths;import java.nio.file.StandardCopyOption;public class CopyDemo {    public static void main(String[] args) {        try {            //被拷贝的文件一定要存在 否则会抛出异常  这里的1.txt一定要存在            Files.copy(Paths.get("/home/project/1.txt"), Paths.get("/home/project/2.txt"), StandardCopyOption.REPLACE_EXISTING);        } catch (IOException e) {            e.printStackTrace();        }    }}</code></pre><pre><code class="java">import java.io.IOException;import java.nio.file.Files;import java.nio.file.Paths;import java.nio.file.StandardCopyOption;public class MoveDemo {    public static void main(String[] args) {        try {            //将1.txt 重命名为3.txt 如果只需要移动到不同的目录，文件名不变即可            Files.move(Paths.get("/home/project/1.txt"), Paths.get("/home/project/3.txt"), StandardCopyOption.REPLACE_EXISTING);        //将2.txt 重命名为4.txt 如果只需要移动到不同的目录，文件名不变即可        Files.move(Paths.get("/home/project/2.txt"), Paths.get("/home/project/4.txt"), StandardCopyOption.REPLACE_EXISTING);        } catch (IOException e) {            e.printStackTrace();        }    }}</code></pre><pre><code class="java">import java.io.File;import java.io.IOException;import java.nio.file.Files;import java.nio.file.Paths;public class DeleteDemo {    public static void main(String[] args) {        try {            //删除文件，文件必须存在，否则抛出异常            Files.delete(Paths.get("/home/project/3.txt"));            //删除文件，返回是否删除成功 即使文件不存在，也不会保存，直接返回false            System.out.println(Files.deleteIfExists(Paths.get("/home/project/3.txt")));            //或者使用File类的delete方法            File file = new File("/home/project/4.txt");            System.out.println(file.delete());        } catch (IOException e) {            e.printStackTrace();        }    }}</code></pre><pre><code class="java">import java.io.File;import java.util.Arrays;public class FileInfo {    public static void main(String[] args) {        File file = new File("/home/project");        System.out.println("文件或者目录名：" + file.getName());        System.out.println("绝对路径：" + file.getAbsolutePath());        System.out.println("父目录：" + file.getParent());        System.out.println("文件路径：" + file.getPath());        //判断文件是否是目录        if (file.isDirectory()) {            //打印目录中的文件            Arrays.stream(file.list()).forEach(System.out::println);        }        System.out.println("是否隐藏：" + file.isHidden());        System.out.println("是否存在：" + file.exists());    }}</code></pre><pre><code class="java">import java.io.File;public class ReadDir {    public static void main(String[] args) {        // 调用readDir方法，传入指定目录的File对象        readDir(new File("/home"));    }    /**     * 递归地读取目录和文件，并输出它们的类型和名称     *     * @param file 要处理的File对象     */    public static void readDir(File file) {        // 如果传入的File对象为null，则直接返回        if (file == null) return;                // 如果File对象表示一个目录        if (file.isDirectory()) {            // 输出目录的信息（名称）            System.out.println("目录" + file.getName());                        // 获取目录下的所有文件和子目录            File[] files = file.listFiles();                        // 遍历每一个文件或子目录并递归调用readDir方法            for (File file2 : files) {                readDir(file2);            }        } else {            // 如果File对象表示一个文件，输出文件的信息（名称）            System.out.println("文件" + file.getName());        }    }}</code></pre><h2 id="8-6-分类"><a href="#8-6-分类" class="headerlink" title="8.6 分类"></a>8.6 分类</h2><p>IO流分为字节流和字符流的分类是基于处理数据的单位和性质来划分的。</p><ol><li><strong>字节流 (Byte Stream)</strong>:<ul><li><strong>处理单位</strong>: 以字节（8位）为单位进行数据处理，适用于处理二进制数据或者文本文件。</li><li><strong>性质</strong>: 字节流是原始的、底层的输入输出，直接操作字节数据。</li><li><strong>InputStream和OutputStream</strong>: 主要使用<code>InputStream</code>和<code>OutputStream</code>类及其子类来实现字节流。例如，<code>FileInputStream</code>用于从文件读取字节，<code>FileOutputStream</code>用于写入字节到文件。</li></ul></li><li><strong>字符流 (Character Stream)</strong>:<ul><li><strong>处理单位</strong>: 以字符为单位进行数据处理，适用于处理文本数据。</li><li><strong>性质</strong>: 字符流是高级的，能够按照字符编码方式处理数据，适合文本数据处理。</li><li><strong>Reader和Writer</strong>: 主要使用<code>Reader</code>和<code>Writer</code>类及其子类来实现字符流。例如，<code>FileReader</code>用于从文件读取字符，<code>FileWriter</code>用于写入字符到文件。</li></ul></li></ol><p>字符流的存在是为了解决字节流在处理文本数据时可能会遇到字符编码的问题。字符流能够根据指定的字符编码（如UTF-8、ASCII等）将字符转换为字节，并且能够以字符为单位更好地处理文本数据，避免乱码等问题。</p><blockquote><p><img src="C:\Users\7878\AppData\Roaming\Typora\typora-user-images\image-20231009190751075.png" alt="image-20231009190751075"></p></blockquote><h2 id="8-7-缓冲流"><a href="#8-7-缓冲流" class="headerlink" title="8.7 缓冲流"></a>8.7 缓冲流</h2><p>在Java中，缓冲流用于提高读取和写入性能，通过将数据缓存到内存中来减少与磁盘或网络的交互次数。主要有<code>BufferedReader</code>和<code>BufferedWriter</code>用于字符流的缓冲，以及<code>BufferedInputStream</code>和<code>BufferedOutputStream</code>用于字节流的缓冲。以下是如何使用Java缓冲流的基本步骤：</p><ol><li><p><strong>导入必要的类</strong>： 首先，确保导入Java IO包中的相关类。根据您的需求，您需要导入以下类之一：</p><ul><li><p>对于字符流的缓冲：</p><pre><code class="java">import java.io.BufferedReader;import java.io.BufferedWriter;</code></pre></li><li><p>对于字节流的缓冲：</p><pre><code class="java">import java.io.BufferedInputStream;import java.io.BufferedOutputStream;</code></pre></li></ul></li><li><p><strong>创建底层流</strong>： 首先，创建底层的输入流（如<code>FileInputStream</code>或<code>FileReader</code>）或输出流（如<code>FileOutputStream</code>或<code>FileWriter</code>），这些流将连接到缓冲流。</p></li><li><p><strong>创建缓冲流</strong>： 使用底层流来创建缓冲流。例如，对于字符输入流：</p><pre><code class="java">BufferedReader bufferedReader = new BufferedReader(new FileReader("文件路径"));</code></pre><p>对于字符输出流：</p><pre><code class="java">BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter("文件路径"));</code></pre><p>对于字节输入流：</p><pre><code class="java">BufferedInputStream bufferedInputStream = new BufferedInputStream(new FileInputStream("文件路径"));</code></pre><p>对于字节输出流：</p><pre><code class="java">BufferedOutputStream bufferedOutputStream = new BufferedOutputStream(new FileOutputStream("文件路径"));</code></pre></li><li><p><strong>使用缓冲流</strong>： 现在，您可以使用缓冲流来读取或写入数据，它们提供了一些方便的方法。例如，使用<code>readLine()</code>来逐行读取文本文件，或使用<code>write()</code>来写入数据。</p><p>示例：</p><pre><code class="java">String line;while ((line = bufferedReader.readLine()) != null) {    // 处理读取的行数据    bufferedWriter.write(line);    bufferedWriter.newLine(); // 写入换行符}</code></pre></li><li><p><strong>关闭流</strong>： 使用完缓冲流后，务必关闭它们以释放资源。可以使用<code>close()</code>方法来关闭流，它也会自动关闭底层的基本流。</p><pre><code class="java">bufferedReader.close();bufferedWriter.close();</code></pre></li><li><p><strong>刷新流</strong>（可选）： 如果您在写入数据后需要立即将数据刷新到磁盘或网络，请调用<code>flush()</code>方法。</p><pre><code class="java">bufferedWriter.flush();</code></pre></li></ol><h2 id="8-8-ObjectStream"><a href="#8-8-ObjectStream" class="headerlink" title="8.8 ObjectStream"></a>8.8 ObjectStream</h2><p><code>ObjectInputStream</code> 和 <code>ObjectOutputStream</code> 是 Java 中用于序列化和反序列化对象的类。它们可以将对象转换为字节流以便于存储和传输，并在需要时将字节流还原为对象。以下是如何使用这两个类的基本示例：</p><p><strong>对象的序列化（写入）：</strong></p><pre><code class="java">import java.io.*;public class ObjectSerialization {    public static void main(String[] args) {        try (FileOutputStream fileOutputStream = new FileOutputStream("object.ser");             ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream)) {            // 创建一个对象            Person person = new Person("Alice", 30);            // 将对象序列化并写入文件            objectOutputStream.writeObject(person);            System.out.println("对象已成功序列化");        } catch (IOException e) {            e.printStackTrace();        }    }}</code></pre><p><strong>对象的反序列化（读取）：</strong></p><pre><code class="java">import java.io.*;public class ObjectDeserialization {    public static void main(String[] args) {        try (FileInputStream fileInputStream = new FileInputStream("object.ser");             ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream)) {            // 从文件中读取序列化的对象            Person person = (Person) objectInputStream.readObject();            System.out.println("对象已成功反序列化");            System.out.println("Name: " + person.getName());            System.out.println("Age: " + person.getAge());        } catch (IOException | ClassNotFoundException e) {            e.printStackTrace();        }    }}</code></pre><p>上述示例中，<code>Person</code> 类是一个简单的自定义类，用于演示对象的序列化和反序列化。在实际应用中，您可以替换成您需要序列化的自定义对象。</p><p>要成功序列化对象，确保被序列化的对象及其成员都是可序列化的。为此，您可以实现 <code>Serializable</code> 接口，并在需要的情况下自定义 <code>serialVersionUID</code> 字段以控制版本兼容性。</p><pre><code class="java">public static class User implements Serializable {        private String name;        private String id;        public User(String name, String id){            this.id = id;            this.name = name;        }        @Override         public String toString(){            return "User =" + name + "\nid = " + id + "\n";        }    }</code></pre><h1 id="9-网络"><a href="#9-网络" class="headerlink" title="9 网络"></a>9 网络</h1><h2 id="9-1-HttpURLConnection"><a href="#9-1-HttpURLConnection" class="headerlink" title="9.1 HttpURLConnection"></a>9.1 HttpURLConnection</h2><pre><code class="java">import java.io.BufferedReader;import java.io.InputStreamReader;import java.net.HttpURLConnection;import java.net.URL;public class HttpClientExample {    public static void main(String[] args) {        try {            // 创建一个URL对象，指定要发送HTTP GET请求的目标地址            URL url = new URL("https://example.com");            // 打开HTTP连接            HttpURLConnection connection = (HttpURLConnection) url.openConnection();            // 设置HTTP请求方法为GET            connection.setRequestMethod("GET");            // 获取HTTP响应码            int responseCode = connection.getResponseCode();            if (responseCode == HttpURLConnection.HTTP_OK) {                // 如果响应码为200，表示请求成功                // 创建一个BufferedReader对象来读取响应内容                BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));                String inputLine;                StringBuilder content = new StringBuilder();                // 逐行读取响应内容并存储在StringBuilder中                while ((inputLine = in.readLine()) != null) {                    content.append(inputLine);                }                in.close();                // 打印响应内容                System.out.println(content.toString());            } else {                // 如果响应码不为200，打印HTTP请求失败信息                System.out.println("HTTP request failed with response code: " + responseCode);            }        } catch (Exception e) {            // 捕获并打印任何异常            e.printStackTrace();        }    }}</code></pre><h2 id="9-2-InetAddress"><a href="#9-2-InetAddress" class="headerlink" title="9.2 InetAddress"></a>9.2 InetAddress</h2><p><code>InetAddress</code> 是 Java 中用于表示 IP 地址的类。它提供了一种在网络应用程序中操作 IP 地址的方式。你可以使用 <code>InetAddress</code> 来获取主机名和 IP 地址之间的映射，以及执行网络通信时需要的地址解析。</p><p>以下是一些常见的 <code>InetAddress</code> 类的用法示例：</p><p><strong>获取本地主机的 InetAddress 对象</strong>：</p><pre><code class="java">InetAddress localHost = InetAddress.getLocalHost();System.out.println("本地主机的主机名：" + localHost.getHostName());System.out.println("本地主机的IP地址：" + localHost.getHostAddress());</code></pre><p><strong>通过主机名获取 InetAddress 对象</strong>：</p><pre><code class="java">String hostname = "www.example.com";InetAddress address = InetAddress.getByName(hostname);System.out.println("主机名：" + address.getHostName());System.out.println("IP地址：" + address.getHostAddress());</code></pre><p><strong>获取主机的所有 IP 地址</strong>：</p><pre><code class="java">String hostname = "www.example.com";InetAddress[] addresses = InetAddress.getAllByName(hostname);for (InetAddress addr : addresses) {    System.out.println("主机名：" + addr.getHostName());    System.out.println("IP地址：" + addr.getHostAddress());}</code></pre><p><strong>检查主机是否可达</strong>：</p><pre><code class="java">String hostname = "www.example.com";InetAddress address = InetAddress.getByName(hostname);if (address.isReachable(5000)) {    System.out.println("主机可达");} else {    System.out.println("主机不可达");}</code></pre><h2 id="9-3-Socket"><a href="#9-3-Socket" class="headerlink" title="9.3 Socket"></a>9.3 Socket</h2><p>使用 Java 中的 <code>Socket</code> 进行网络编程涉及以下步骤：</p><ol><li><p><strong>创建客户端套接字</strong>：如果你要编写客户端应用程序，首先需要创建一个 <code>Socket</code> 对象，以便连接到远程服务器。使用以下代码创建客户端套接字：</p><pre><code class="java">String serverHost = "example.com";int serverPort = 8080;try {    Socket socket = new Socket(serverHost, serverPort);    // 现在你可以使用 socket 进行数据发送和接收} catch (IOException e) {    e.printStackTrace();}</code></pre></li><li><p><strong>创建服务器套接字</strong>：如果你要编写服务器应用程序，首先需要创建一个 <code>ServerSocket</code> 对象，以便侦听客户端的连接请求。使用以下代码创建服务器套接字：</p><pre><code class="java">int serverPort = 8080;try {    ServerSocket serverSocket = new ServerSocket(serverPort);    // 服务器套接字现在正在侦听客户端的连接请求} catch (IOException e) {    e.printStackTrace();}</code></pre></li><li><p><strong>与套接字进行数据通信</strong>：一旦套接字建立连接，你可以使用 <code>InputStream</code> 和 <code>OutputStream</code> 来在客户端和服务器之间进行数据传输。例如，客户端可以使用 <code>socket.getOutputStream()</code> 发送数据，服务器可以使用 <code>socket.getInputStream()</code> 接收数据。</p><pre><code class="java">// 客户端发送数据示例OutputStream outputStream = socket.getOutputStream();PrintWriter writer = new PrintWriter(outputStream);writer.println("Hello, Server!");writer.flush();// 服务器接收数据示例InputStream inputStream = socket.getInputStream();BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));String clientMessage = reader.readLine();</code></pre></li><li><p><strong>关闭套接字</strong>：在通信完成后，务必关闭套接字以释放资源。通常在 <code>try-catch-finally</code> 块中进行套接字关闭操作。</p><pre><code class="java">try {    // 关闭套接字    socket.close();} catch (IOException e) {    e.printStackTrace();}</code></pre></li></ol><h2 id="9-4-ServerSocket"><a href="#9-4-ServerSocket" class="headerlink" title="9.4 ServerSocket"></a>9.4 ServerSocket</h2><p>在 Java 中，<code>ServerSocket</code> 类用于创建服务器套接字，以侦听客户端的连接请求。一旦建立连接，就可以创建与客户端的通信套接字，允许数据交换。以下是使用 <code>ServerSocket</code> 的基本步骤：</p><ol><li><p><strong>创建 ServerSocket 实例</strong>：首先，实例化 <code>ServerSocket</code> 并指定服务器将侦听的端口号。</p><pre><code class="java">int serverPort = 8080;ServerSocket serverSocket = new ServerSocket(serverPort);</code></pre></li><li><p><strong>等待客户端连接</strong>：使用 <code>accept()</code> 方法等待客户端连接请求。此方法会阻塞，直到有客户端连接到服务器。</p><pre><code class="java">Socket clientSocket = serverSocket.accept();</code></pre></li><li><p><strong>与客户端进行通信</strong>：一旦客户端连接成功，就可以使用 <code>InputStream</code> 和 <code>OutputStream</code> 与客户端进行数据交换。</p><pre><code class="java">InputStream inputStream = clientSocket.getInputStream();OutputStream outputStream = clientSocket.getOutputStream();</code></pre></li><li><p><strong>接收和发送数据</strong>：使用 <code>InputStream</code> 从客户端接收数据，并使用 <code>OutputStream</code> 向客户端发送数据。</p><pre><code class="java">// 从客户端接收数据BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));String clientMessage = reader.readLine();// 向客户端发送数据PrintWriter writer = new PrintWriter(outputStream);writer.println("Hello, Client!");writer.flush();</code></pre></li><li><p><strong>关闭连接</strong>：在通信完成后，关闭客户端套接字和服务器套接字。</p><pre><code class="java">clientSocket.close();serverSocket.close();</code></pre></li></ol><p>完整示例代码如下所示：</p><pre><code class="java">import java.io.*;import java.net.*;public class ServerExample {    public static void main(String[] args) {        int serverPort = 8080;        try {            ServerSocket serverSocket = new ServerSocket(serverPort);            System.out.println("Server listening on port " + serverPort);            // 等待客户端连接            Socket clientSocket = serverSocket.accept();            System.out.println("Client connected: " + clientSocket.getInetAddress());            // 获取输入流和输出流            InputStream inputStream = clientSocket.getInputStream();            OutputStream outputStream = clientSocket.getOutputStream();            // 从客户端接收数据            BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));            String clientMessage = reader.readLine();            System.out.println("Received from client: " + clientMessage);            // 向客户端发送数据            PrintWriter writer = new PrintWriter(outputStream);            writer.println("Hello, Client!");            writer.flush();            // 关闭套接字            clientSocket.close();            serverSocket.close();        } catch (IOException e) {            e.printStackTrace();        }    }}</code></pre><p>服务端和客户端信息发送</p><pre><code class="java">import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.PrintWriter;import java.net.ServerSocket;import java.net.Socket;public class EchoServer {    public static void main(String[] args) {        try {            // 创建服务器套接字并指定端口号 1080            ServerSocket serverSocket = new ServerSocket(1080);            // 等待客户端连接            Socket client = serverSocket.accept();            // 创建用于向客户端发送数据的 PrintWriter            PrintWriter out = new PrintWriter(client.getOutputStream(), true);            // 创建用于从客户端接收数据的 BufferedReader            BufferedReader in = new BufferedReader(new InputStreamReader(client.getInputStream()));            String userIn;            // 循环读取客户端发送的数据            while ((userIn = in.readLine()) != null) {                System.out.println("收到客户端消息：" + userIn);                // 发回客户端相同的消息                out.println(userIn);            }            // 关闭套接字            client.close();            serverSocket.close();        } catch (IOException e) {            e.printStackTrace();        }    }}</code></pre><pre><code class="java">import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.PrintWriter;import java.net.Socket;import java.util.Scanner;public class EchoClient {    public static void main(String[] args) {        // 服务器主机名        String hostname = "127.0.0.1";        // 服务器端口        int port = 1080;        // 用于从用户获取输入的 Scanner 对象        Scanner userIn = new Scanner(System.in);        try {            // 建立与服务器的 socket 连接            Socket socket = new Socket(hostname, port);            // 获取 socket 输出流，用于向服务器发送数据            PrintWriter out = new PrintWriter(socket.getOutputStream(), true);            // 获取 socket 输入流，用于接收服务器返回的数据            BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));            String userInput;            System.out.println("请输入信息：");            // 当用户输入 "exit" 时退出循环            while (!"exit".equals(userInput = userIn.nextLine())) {                // 将用户输入发送到服务器                out.println(userInput);                // 从服务器接收并打印回应                System.out.println("收到服务端回应:" + in.readLine());            }            // 关闭 socket 连接            socket.close();        } catch (IOException e) {            e.printStackTrace();        }    }}</code></pre><h1 id="10-多线程"><a href="#10-多线程" class="headerlink" title="10 多线程"></a>10 多线程</h1><h2 id="10-1-实现"><a href="#10-1-实现" class="headerlink" title="10.1 实现"></a>10.1 实现</h2><ol><li><strong>继承Thread类</strong>（<code>Thread1</code>类）：<ul><li>当一个类继承自<code>Thread</code>类时，它成为一个线程类，可以直接通过创建该类的对象并调用<code>start()</code>方法来启动线程。这是一种较为简单的方式，但有一个缺点，即Java不支持多重继承，因此如果一个类已经继承了其他类，就不能再继承<code>Thread</code>类。</li></ul></li><li><strong>实现Runnable接口</strong>（<code>Thread2</code>类）：<ul><li>如果一个类已经有了一个父类或者你想要更好地分离线程的行为和类本身的行为，那么你可以选择实现<code>Runnable</code>接口。这允许你将线程的任务独立出来，以实现更灵活的多线程编程。你需要创建一个实现<code>Runnable</code>接口的类，然后将该类的实例传递给一个<code>Thread</code>对象来启动线程。这种方式避免了单一继承的限制。</li></ul></li></ol><pre><code class="java">public class CreateThread {    public static void main(String[] args) {        Thread1 thread1 = new Thread1();        //声明一个Thread1对象，这个Thread1类继承自Thread类的        Thread thread2 = new Thread(new Thread2());        //传递一个匿名对象作为参数        thread1.start();        thread2.start();        //启动线程    }}class Thread1 extends Thread {    @Override    public void run() {        //在run()方法中放入线程要完成的工作        //这里我们把两个线程各自的工作设置为打印100次信息        for (int i = 0; i &lt; 100; ++i) {            System.out.println("Hello! This is " + i);        }        //在这个循环结束后，线程便会自动结束    }}class Thread2 implements Runnable {    //与Thread1不同，如果当一个线程已经继承了另一个类时，就建议你通过实现Runnable接口来构造    @Override    public void run() {        for (int i = 0; i &lt; 100; ++i) {            System.out.println("Thanks. There is " + i);        }    }}</code></pre><h2 id="10-2-线程变量"><a href="#10-2-线程变量" class="headerlink" title="10.2 线程变量"></a>10.2 线程变量</h2><p>线程变量（Thread-local variables）是一种在多线程编程中用于在不同线程之间存储独立数据的机制。每个线程都有自己独立的变量副本，而不会相互干扰。这对于需要在线程间隔离数据的场景非常有用。</p><p>在Java中，你可以使用<code>ThreadLocal</code>类来创建线程变量。以下是使用<code>ThreadLocal</code>的基本步骤以及如何使用线程变量：</p><ol><li><p><strong>创建 ThreadLocal 对象</strong>： 首先，你需要创建一个<code>ThreadLocal</code>对象，用于存储线程本地变量。</p><pre><code class="java">ThreadLocal&lt;String&gt; threadLocalVariable = new ThreadLocal&lt;&gt;();</code></pre></li><li><p><strong>设置线程变量的值</strong>： 使用<code>ThreadLocal</code>对象的<code>set()</code>方法可以设置当前线程的变量值。</p><pre><code class="java">threadLocalVariable.set("This is thread-local data.");</code></pre></li><li><p><strong>获取线程变量的值</strong>： 使用<code>ThreadLocal</code>对象的<code>get()</code>方法可以获取当前线程的变量值。</p><pre><code class="java">String data = threadLocalVariable.get();</code></pre></li><li><p><strong>移除线程变量的值</strong>（可选）： 你也可以使用<code>ThreadLocal</code>对象的<code>remove()</code>方法来移除当前线程的变量值。</p><pre><code class="java">threadLocalVariable.remove();</code></pre></li><li><p><strong>示例代码</strong>： 下面是一个示例，演示如何在多线程环境中使用<code>ThreadLocal</code>来存储线程本地数据：</p><pre><code class="java">public class ThreadLocalExample {    private static ThreadLocal&lt;String&gt; threadLocalVariable = ThreadLocal.withInitial(() -&gt; "Default Value");    public static void main(String[] args) {        // 设置线程1的变量值        threadLocalVariable.set("Thread 1 Data");        // 启动线程2并获取其变量值        Thread thread2 = new Thread(() -&gt; {            String data = threadLocalVariable.get();            System.out.println("Thread 2 Data: " + data);        });        thread2.start();    }}</code></pre></li></ol><p>在这个示例中，线程1设置了线程变量的值，然后线程2在不影响线程1的情况下获取了自己的线程变量值。这样，每个线程都有自己独立的线程变量，互不干扰。线程变量通常用于保存线程特定的上下文信息或状态。</p><h2 id="10-3-线程同步"><a href="#10-3-线程同步" class="headerlink" title="10.3 线程同步"></a>10.3 线程同步</h2><p>线程同步是一种用于控制多个线程在共享资源上的访问以防止竞争条件和数据不一致性的机制。在Java中，你可以使用以下方式来实现线程同步：</p><p><strong>使用synchronized关键字</strong>：</p><ul><li>在方法上使用<code>synchronized</code>关键字，或者在代码块内使用<code>synchronized</code>关键字，可以确保只有一个线程可以访问被标记为<code>synchronized</code>的方法或代码块。这种方式常用于同步对象的访问。</li></ul><pre><code class="java">public synchronized void synchronizedMethod() {    // 同步的方法内容}</code></pre><pre><code class="java">synchronized (lockObject) {    // 同步的代码块}</code></pre><pre><code class="java">public class SynchronizedExample {    private int counter = 0;    public synchronized void increment() {        counter++;    }    public synchronized int getCounter() {        return counter;    }    public static void main(String[] args) {        SynchronizedExample example = new SynchronizedExample();        // 创建多个线程并启动它们        Thread thread1 = new Thread(() -&gt; {            for (int i = 0; i &lt; 1000; i++) {                example.increment();            }        });        Thread thread2 = new Thread(() -&gt; {            for (int i = 0; i &lt; 1000; i++) {                example.increment();            }        });        thread1.start();        thread2.start();        try {            // 等待两个线程执行完毕            thread1.join();            thread2.join();        } catch (InterruptedException e) {            e.printStackTrace();        }        // 输出最终计数器的值        System.out.println("Final Counter Value: " + example.getCounter());    }}</code></pre><p><strong>使用ReentrantLock</strong>：</p><ul><li><code>java.util.concurrent.locks.ReentrantLock</code>是一个更灵活的同步机制，可以用于替代<code>synchronized</code>关键字。它提供了更多的控制选项，如尝试获取锁、设置锁超时等。</li></ul><pre><code class="java">private final ReentrantLock lock = new ReentrantLock();public void synchronizedMethod() {    lock.lock();    try {        // 同步的方法内容    } finally {        lock.unlock();    }}</code></pre><pre><code class="java">import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;public class ReentrantLockExample {    private int counter = 0;    private Lock lock = new ReentrantLock(); // 创建一个ReentrantLock对象    public void increment() {        lock.lock(); // 获取锁        try {            counter++;        } finally {            lock.unlock(); // 释放锁        }    }    public int getCounter() {        lock.lock(); // 获取锁        try {            return counter;        } finally {            lock.unlock(); // 释放锁        }    }    public static void main(String[] args) {        ReentrantLockExample example = new ReentrantLockExample();        // 创建多个线程并启动它们        Thread thread1 = new Thread(() -&gt; {            for (int i = 0; i &lt; 1000; i++) {                example.increment();            }        });        Thread thread2 = new Thread(() -&gt; {            for (int i = 0; i &lt; 1000; i++) {                example.increment();            }        });        thread1.start();        thread2.start();        try {            // 等待两个线程执行完毕            thread1.join();            thread2.join();        } catch (InterruptedException e) {            e.printStackTrace();        }        // 输出最终计数器的值        System.out.println("Final Counter Value: " + example.getCounter());    }}</code></pre><p>在多线程编程中，<code>thread.join()</code> 是一个用于等待线程完成的方法。当一个线程调用另一个线程的 <code>join()</code> 方法时，它会被阻塞，直到被调用的线程执行完毕。这意味着程序会等待被调用的线程完成它的任务，然后再继续执行接下来的代码。</p><p>通常情况下，<code>thread.join()</code> 用于确保主线程等待所有其他线程完成之后再继续执行，这对于需要协调多个线程之间的操作非常有用。例如，如果你有一个主线程和多个工作线程，你可以使用 <code>join()</code> 来等待所有工作线程完成它们的任务，然后再进行结果的汇总或其他操作。</p><p>在Java中，<code>Condition</code> 是在多线程编程中用于控制线程之间协作和同步的一种机制。<code>Condition</code> 通常与 <code>ReentrantLock</code> 结合使用，以替代传统的 <code>synchronized</code> 块来实现更灵活的线程同步。</p><p><code>Condition</code> 提供了类似于 <code>wait()</code> 和 <code>notify()</code> 方法的功能，但比它们更灵活。下面是一些关于 <code>Condition</code> 的基本用法：</p><ol><li><p>创建 <code>Condition</code>： 通常，你需要与一个 <code>ReentrantLock</code> 关联来创建一个 <code>Condition</code>。这可以通过调用 <code>ReentrantLock</code> 的 <code>newCondition()</code> 方法来实现。例如：</p><pre><code class="java">ReentrantLock lock = new ReentrantLock();Condition condition = lock.newCondition();</code></pre></li><li><p>等待条件： 你可以使用 <code>await()</code> 方法来让线程等待某个条件变为真。线程将被阻塞，直到其他线程调用 <code>signal()</code> 或 <code>signalAll()</code> 来通知等待的线程条件已满足。例如：</p><pre><code class="java">lock.lock();try {    while (conditionNotMet) {        condition.await();    }    // 执行条件已满足时的操作} finally {    lock.unlock();}</code></pre></li><li><p>通知条件： 当某个条件发生变化时，可以使用 <code>signal()</code> 或 <code>signalAll()</code> 方法来通知等待的线程。<code>signal()</code> 通知一个等待线程，而 <code>signalAll()</code> 通知所有等待线程。例如：</p><pre><code class="java">lock.lock();try {    // 更新条件    conditionNotMet = false;    // 通知等待的线程条件已满足    condition.signal();} finally {    lock.unlock();}</code></pre></li></ol><p><code>Condition</code> 的使用允许更细粒度的线程同步，因为你可以选择哪个条件需要等待或被通知，而不是像传统的 <code>wait()</code> 和 <code>notify()</code> 那样只能等待或通知一个条件。这使得线程的管理和同步更加灵活和精确。</p><p>需要注意的是，<code>Condition</code> 通常与 <code>ReentrantLock</code> 配合使用，而不是与传统的 <code>synchronized</code> 关键字。这是因为 <code>Condition</code> 提供了更多的控制权和灵活性，适用于更复杂的多线程场景。</p><pre><code class="java">import java.util.LinkedList;import java.util.Queue;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.ReentrantLock;public class ProducerConsumerExample {    private static final int CAPACITY = 5;  // 缓冲区容量    private final Queue&lt;Integer&gt; buffer = new LinkedList&lt;&gt;();  // 缓冲区队列    private final ReentrantLock lock = new ReentrantLock();  // 重入锁    private final Condition notFull = lock.newCondition();  // 缓冲区不满的条件    private final Condition notEmpty = lock.newCondition();  // 缓冲区不空的条件    // 生产者方法：往缓冲区中添加数据    public void produce(int item) throws InterruptedException {        lock.lock();  // 获取锁        try {            while (buffer.size() == CAPACITY) {                System.out.println("Buffer is full. Producer is waiting.");                notFull.await();  // 缓冲区已满，生产者等待            }            buffer.offer(item);            System.out.println("Produced: " + item);            notEmpty.signal();  // 通知等待的消费者        } finally {            lock.unlock();  // 释放锁        }    }    // 消费者方法：从缓冲区中取出数据    public int consume() throws InterruptedException {        lock.lock();  // 获取锁        try {            while (buffer.isEmpty()) {                System.out.println("Buffer is empty. Consumer is waiting.");                notEmpty.await();  // 缓冲区为空，消费者等待            }            int item = buffer.poll();            System.out.println("Consumed: " + item);            notFull.signal();  // 通知等待的生产者            return item;        } finally {            lock.unlock();  // 释放锁        }    }    public static void main(String[] args) {        ProducerConsumerExample example = new ProducerConsumerExample();        // 创建生产者线程        Thread producerThread = new Thread(() -&gt; {            try {                for (int i = 1; i &lt;= 10; i++) {                    example.produce(i);                    Thread.sleep(1000);                }            } catch (InterruptedException e) {                e.printStackTrace();            }        });        // 创建消费者线程        Thread consumerThread = new Thread(() -&gt; {            try {                for (int i = 1; i &lt;= 10; i++) {                    int item = example.consume();                    Thread.sleep(1000);                }            } catch (InterruptedException e) {                e.printStackTrace();            }        });        producerThread.start();  // 启动生产者线程        consumerThread.start();  // 启动消费者线程        try {            producerThread.join();  // 等待生产者线程结束            consumerThread.join();  // 等待消费者线程结束        } catch (InterruptedException e) {            e.printStackTrace();        }    }}</code></pre><h2 id="10-4-死锁"><a href="#10-4-死锁" class="headerlink" title="10.4 死锁"></a>10.4 死锁</h2><pre><code class="java">public class DeadlockExample {    public static void main(String[] args) {        // 创建两个资源        Object resource1 = new Object();        Object resource2 = new Object();        // 线程1尝试获取资源1，然后资源2        Thread thread1 = new Thread(() -&gt; {            synchronized (resource1) {                System.out.println("Thread 1: Holding resource 1...");                try {                    Thread.sleep(100); // 为了增加死锁发生的机会                } catch (InterruptedException e) {                    e.printStackTrace();                }                System.out.println("Thread 1: Waiting for resource 2...");                synchronized (resource2) {                    System.out.println("Thread 1: Acquired resource 2.");                }            }        });        // 线程2尝试获取资源2，然后资源1        Thread thread2 = new Thread(() -&gt; {            synchronized (resource2) {                System.out.println("Thread 2: Holding resource 2...");                try {                    Thread.sleep(100); // 为了增加死锁发生的机会                } catch (InterruptedException e) {                    e.printStackTrace();                }                System.out.println("Thread 2: Waiting for resource 1...");                synchronized (resource1) {                    System.out.println("Thread 2: Acquired resource 1.");                }            }        });        // 启动两个线程        thread1.start();        thread2.start();        // 等待两个线程完成        try {            thread1.join();            thread2.join();        } catch (InterruptedException e) {            e.printStackTrace();        }        System.out.println("Both threads have finished.");    }}</code></pre><h2 id="10-5-ArrayBlockingQueue"><a href="#10-5-ArrayBlockingQueue" class="headerlink" title="10.5  ArrayBlockingQueue"></a>10.5  ArrayBlockingQueue</h2><p><code>ArrayBlockingQueue</code> 是 Java 标准库中的一个有界阻塞队列，用于多线程编程中的生产者-消费者问题或其他线程协作场景。它基于数组实现，具有固定的容量，并且当队列已满时，生产者将被阻塞，当队列为空时，消费者将被阻塞。这种队列的特性使得它适用于限制资源的共享。</p><p>以下是如何创建和使用 <code>ArrayBlockingQueue</code> 的基本示例：</p><p>导入 <code>java.util.concurrent</code> 包：</p><pre><code class="java">import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.BlockingQueue;</code></pre><p>创建 <code>ArrayBlockingQueue</code> 对象，并指定队列容量：</p><pre><code class="java">BlockingQueue&lt;Integer&gt; queue = new ArrayBlockingQueue&lt;&gt;(10); // 创建容量为10的队列</code></pre><p>在生产者线程中往队列中添加元素，可以使用 <code>put()</code> 方法来添加，如果队列已满，它将等待：</p><pre><code class="java">try {    queue.put(1); // 将元素1放入队列} catch (InterruptedException e) {    // 处理异常}</code></pre><p>在消费者线程中从队列中取出元素，可以使用 <code>take()</code> 方法来取出，如果队列为空，它将等待：</p><pre><code class="java">try {    int item = queue.take(); // 从队列中取出元素    // 处理取出的元素} catch (InterruptedException e) {    // 处理异常}</code></pre><p>你还可以使用 <code>offer()</code> 方法尝试往队列中添加元素，如果队列已满，它会立即返回 <code>false</code>，或者使用 <code>poll()</code> 方法尝试取出元素，如果队列为空，它会立即返回 <code>null</code>。</p><pre><code class="java">boolean added = queue.offer(2); // 尝试将元素2放入队列，如果队列已满返回falseInteger item = queue.poll(); // 尝试从队列中取出元素，如果队列为空返回null</code></pre><p><code>ArrayBlockingQueue</code> 还提供了其他一些方法，如 <code>offer(E e, long timeout, TimeUnit unit)</code> 和 <code>poll(long timeout, TimeUnit unit)</code>，它们允许你在超时时间内尝试添加或取出元素。此外，你还可以使用 <code>remainingCapacity()</code> 方法来获取队列中剩余可用空间的数量。</p><h2 id="10-6-生产消费者"><a href="#10-6-生产消费者" class="headerlink" title="10.6 生产消费者"></a>10.6 生产消费者</h2><pre><code class="java">import java.util.Random;import java.util.concurrent.LinkedBlockingQueue;public class PCModel {    private static LinkedBlockingQueue&lt;Integer&gt; queue = new LinkedBlockingQueue&lt;&gt;();    String[] arr = {"生产一", "生产二", "消费一", "消费二"};    public static void main(String[] args) {        PCModel pcModel = new PCModel();        Provider provider1 = pcModel.new Provider();        Thread threadProvider1 = new Thread(provider1);                Consumer consumer1 = pcModel.new Consumer();        Thread threadConsumer1 = new Thread(consumer1);                Provider provider2 = pcModel.new Provider();        Thread threadProvider2 = new Thread(provider2);                Consumer consumer2 = pcModel.new Consumer();        Thread threadConsumer2 = new Thread(consumer2);                provider1.setS1("生产一");        consumer1.setS1("消费一");        provider2.setS1("生产二");        consumer2.setS1("消费二");        try {            Thread.sleep(500);        } catch (InterruptedException e) {                        e.printStackTrace();        }        threadProvider1.start();        threadConsumer1.start();        threadProvider2.start();        threadConsumer2.start();    }    class Provider  implements Runnable {        ThreadLocal&lt;String&gt; s = new ThreadLocal&lt;&gt;();        private String s1;        public void setS(String str) {            s.set(str);        }        public void setS1(String str){            this.s1 = str;        }        @Override        public void run() {            for(int i = 1; i &lt;= 5; i++) {                Integer integer = new Random().nextInt(100);                queue.add(integer);                System.out.println(s1 + "制做了" + integer);                try {                    Thread.sleep(1000);                } catch (InterruptedException e) {                    e.printStackTrace();                }            }        }    }    class Consumer implements Runnable {        ThreadLocal&lt;String&gt; s = new ThreadLocal&lt;&gt;();        private String s2;        public void setS(String str) {            s.set(str);        }        public void setS1(String str){            this.s2 = str;        }        @Override        public void run() {                        for(int i = 1; i &lt;= 5; i++) {                while(queue.size() == 0) {                    System.out.println(s2 + "正在等待");                    try {                        Thread.sleep(500);                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                }                Integer integer;                try {                    integer = queue.take();                    System.out.println(s2 + "获取了" + integer);                } catch (InterruptedException e) {                    e.printStackTrace();                }            }        }    }}</code></pre><h2 id="10-7-线程池"><a href="#10-7-线程池" class="headerlink" title="10.7 线程池"></a>10.7 线程池</h2><p>线程池是一种用于管理和重用线程的机制，它可以帮助你更有效地管理多线程任务，减少线程的创建和销毁开销。Java 提供了 <code>java.util.concurrent</code> 包，其中包含了线程池的实现，使其在多线程应用程序中更容易使用。</p><p>下面是如何在Java中使用线程池的一般步骤：</p><ol><li>创建线程池：你可以使用 <code>ExecutorService</code> 接口的工厂方法来创建线程池，通常有以下几种类型：<ul><li><code>Executors.newFixedThreadPool(int nThreads)</code>: 创建一个具有固定线程数的线程池，线程数不会变化。</li><li><code>Executors.newCachedThreadPool()</code>: 创建一个具有可根据需要创建新线程的线程池，适用于短期异步任务。</li><li><code>Executors.newSingleThreadExecutor()</code>: 创建一个仅包含一个线程的线程池，用于按顺序执行任务。</li><li><code>Executors.newScheduledThreadPool(int corePoolSize)</code>: 创建一个固定大小的线程池，用于调度定时任务。</li></ul></li><li>提交任务：使用线程池的 <code>submit</code> 或 <code>execute</code> 方法提交需要执行的任务。</li><li>关闭线程池：当不再需要线程池时，应该调用线程池的 <code>shutdown</code> 或 <code>shutdownNow</code> 方法来关闭线程池。这将停止线程池中的所有线程并释放资源。</li></ol><p>以下是一个简单示例：</p><pre><code class="java">import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class ThreadPoolExample {    public static void main(String[] args) {        // 创建一个固定大小为3的线程池        ExecutorService threadPool = Executors.newFixedThreadPool(3);        // 提交任务给线程池        for (int i = 1; i &lt;= 5; i++) {            final int task = i;            threadPool.submit(() -&gt; {                System.out.println("Task " + task + " is executing by thread " + Thread.currentThread().getId());            });        }        // 关闭线程池        threadPool.shutdown();    }}</code></pre><p>在这个示例中，我们创建了一个固定大小为3的线程池，然后提交了5个任务。线程池会自动分配任务给可用的线程，执行完任务后关闭线程池。</p><p>使用线程池可以提高多线程应用程序的性能和可维护性，因为它可以避免频繁创建和销毁线程，以及管理线程的生命周期。</p><h1 id="11-JDBC"><a href="#11-JDBC" class="headerlink" title="11 JDBC"></a>11 JDBC</h1><h2 id="11-1-JDBC"><a href="#11-1-JDBC" class="headerlink" title="11.1 JDBC"></a>11.1 JDBC</h2><p>JDBC 是 Java Database Connectivity 的缩写，是 Java 编程语言用于与关系型数据库进行连接和交互的标准 API（应用程序接口）。JDBC 允许 Java 应用程序通过标准接口访问和操作数据库，而不依赖于特定数据库系统。</p><p>JDBC 提供了一组类和接口，使开发人员能够执行以下任务：</p><ol><li>建立数据库连接：通过 JDBC，你可以创建与数据库的连接，这通常涉及到提供数据库的连接 URL、用户名和密码。</li><li>执行 SQL 查询：你可以使用 JDBC 来执行 SQL 查询，包括 SELECT 查询用于检索数据和 INSERT、UPDATE、DELETE 查询用于修改数据。</li><li>处理结果集：JDBC 允许你从数据库中检索查询结果，并将结果封装为 Java 对象，以便在应用程序中处理。</li><li>处理事务：JDBC 支持事务处理，你可以使用它来控制多个 SQL 操作的原子性和一致性。</li><li>处理异常：JDBC 引发异常来处理各种数据库操作可能遇到的问题，开发人员可以捕获和处理这些异常以实现错误处理和故障恢复。</li></ol><p>JDBC 是一种非常强大和灵活的工具，它允许 Java 应用程序与各种关系型数据库（如Oracle、MySQL、SQL Server、PostgreSQL等）进行集成。使用 JDBC，开发人员可以编写数据库无关的代码，从而能够轻松切换和连接到不同的数据库系统，而不必修改应用程序的大部分代码。</p><p>JDBC 驱动程序是用于不同数据库系统的具体实现，它们充当 JDBC API 和数据库之间的桥梁，允许 Java 应用程序与特定数据库进行通信。常见的 JDBC 驱动程序包括MySQL Connector/J、Oracle JDBC 驱动程序等。开发人员需要根据使用的数据库系统选择合适的 JDBC 驱动程序来建立连接。</p><h2 id="11-2-连接"><a href="#11-2-连接" class="headerlink" title="11.2 连接"></a>11.2 连接</h2><p>使用Java中的JDBC（Java Database Connectivity）来连接和操作数据库通常需要以下步骤：</p><ol><li><p><strong>导入JDBC库</strong>：首先，你需要导入JDBC库，通常包括Java的<code>java.sql</code>包和特定数据库的JDBC驱动程序库。你可以通过在Java项目中添加JAR文件或使用Maven等构建工具来引入所需的JDBC库。</p></li><li><p><strong>加载数据库驱动程序</strong>：在你的Java应用程序中，使用<code>Class.forName()</code>方法来加载特定数据库的JDBC驱动程序。不同的数据库有不同的驱动程序类名。例如，对于MySQL数据库，你可以加载MySQL的JDBC驱动程序如下：</p><pre><code class="java">Class.forName("com.mysql.cj.jdbc.Driver");</code></pre></li><li><p><strong>建立数据库连接</strong>：使用<code>DriverManager.getConnection()</code>方法来建立与数据库的连接。你需要提供数据库的连接字符串、用户名和密码。连接字符串的格式会根据使用的数据库类型而有所不同。例如，连接到MySQL数据库可以如下所示：</p><pre><code class="java">String url = "jdbc:mysql://localhost:3306/your_database";String username = "your_username";String password = "your_password";Connection connection = DriverManager.getConnection(url, username, password);</code></pre></li><li><p><strong>创建和执行SQL语句</strong>：使用<code>Connection</code>对象来创建<code>Statement</code>、<code>PreparedStatement</code>或<code>CallableStatement</code>对象，然后使用它们来执行SQL查询或更新操作。例如，执行一个简单的查询：</p><pre><code class="java">Statement statement = connection.createStatement();ResultSet resultSet = statement.executeQuery("SELECT * FROM your_table");while (resultSet.next()) {    // 处理查询结果}</code></pre></li><li><p><strong>处理结果</strong>：如果你执行的是查询操作，你可以使用<code>ResultSet</code>对象来获取查询结果。如果执行的是更新操作，你可以检查受影响的行数。</p></li><li><p><strong>关闭连接和资源</strong>：使用完数据库连接和其他资源后，记得关闭它们，以释放资源并确保安全关闭。通常，你需要在<code>finally</code>块中关闭连接、语句和结果集。</p><pre><code class="java">if (resultSet != null) {    resultSet.close();}if (statement != null) {    statement.close();}if (connection != null) {    connection.close();}</code></pre></li><li><p><strong>异常处理</strong>：务必处理可能抛出的异常，以确保程序的健壮性。你可以使用<code>try-catch</code>块来捕获异常。</p></li></ol><h2 id="11-3-Statement"><a href="#11-3-Statement" class="headerlink" title="11.3 Statement"></a>11.3 Statement</h2><ol><li><p><strong>execute(String sql)</strong> 示例：</p><pre><code class="java">Statement statement = connection.createStatement();boolean isResultSet = statement.execute("SELECT * FROM your_table");if (isResultSet) {    ResultSet resultSet = statement.getResultSet();    // 处理查询结果...} else {    int rowsAffected = statement.getUpdateCount();    System.out.println(rowsAffected + " rows updated.");}statement.close();</code></pre></li><li><p><strong>executeQuery(String sql)</strong> 示例：</p><pre><code class="java">Statement statement = connection.createStatement();ResultSet resultSet = statement.executeQuery("SELECT * FROM your_table");while (resultSet.next()) {    int id = resultSet.getInt("id");    String name = resultSet.getString("name");    // 处理查询结果...}statement.close();</code></pre></li><li><p><strong>executeUpdate(String sql)</strong> 示例：</p><pre><code class="java">Statement statement = connection.createStatement();int rowsAffected = statement.executeUpdate("UPDATE your_table SET column1 = 'value' WHERE column2 = 'criteria'");System.out.println(rowsAffected + " rows updated.");statement.close();</code></pre></li><li><p><strong>addBatch(String sql) 和 executeBatch() 示例</strong>：</p><pre><code class="java">Statement statement = connection.createStatement();statement.addBatch("INSERT INTO your_table (column1, column2) VALUES ('value1', 'value2')");statement.addBatch("UPDATE your_table SET column1 = 'new_value' WHERE column2 = 'criteria'");int[] batchResults = statement.executeBatch();// 处理批处理结果...statement.close();</code></pre></li><li><p><strong>setMaxRows(int max)</strong> 示例：</p><pre><code class="java">Statement statement = connection.createStatement();statement.setMaxRows(10); // 限制结果集最多返回 10 行ResultSet resultSet = statement.executeQuery("SELECT * FROM your_table");while (resultSet.next()) {    int id = resultSet.getInt("id");    String name = resultSet.getString("name");    // 处理查询结果...}statement.close();</code></pre></li></ol><h2 id="11-4-PreparedStatement"><a href="#11-4-PreparedStatement" class="headerlink" title="11.4 PreparedStatement"></a>11.4 PreparedStatement</h2><blockquote><ol><li><strong>预编译性</strong>：<ul><li><code>Statement</code> 是动态 SQL 语句，每次执行 SQL 查询时，都需要将 SQL 字符串发送到数据库进行解析和编译。这可能会导致性能下降，特别是在频繁执行相同查询时。</li><li><code>PreparedStatement</code> 是预编译的 SQL 语句，它在数据库中已经编译好了。你可以在 SQL 语句中使用占位符（如 <code>?</code>），然后在执行时提供具体的值，而不需要重新编译 SQL 语句。这提高了性能并减少了潜在的 SQL 注入风险。</li></ul></li><li><strong>SQL 注入</strong>：<ul><li><code>Statement</code> 在构造 SQL 查询时直接将变量值插入到查询字符串中，如果不谨慎处理输入数据，可能会导致 SQL 注入攻击。</li><li><code>PreparedStatement</code> 使用占位符来分离 SQL 查询和数据值，从而减少了 SQL 注入风险。数据库会安全处理占位符中的数据值。</li></ul></li><li><strong>可读性和维护性</strong>：<ul><li><code>Statement</code> 可能会导致更复杂的 SQL 查询字符串，因为你需要手动将值嵌入到查询中。</li><li><code>PreparedStatement</code> 更容易维护，因为 SQL 查询和数据值是分开的。</li></ul></li><li><strong>性能</strong>：<ul><li><code>PreparedStatement</code> 通常比 <code>Statement</code> 更快，特别是在重复执行相同的查询时，因为它允许数据库进行查询缓存和优化。</li></ul></li></ol></blockquote><pre><code class="java">import java.sql.Connection;import java.sql.DriverManager;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;public class PreparedStatementExample {    private static final String JDBC_URL = "jdbc:mysql://localhost:3306/your_database";    private static final String USERNAME = "your_username";    private static final String PASSWORD = "your_password";    public static void main(String[] args) {        try {            // 1. 创建数据库连接            Connection connection = DriverManager.getConnection(JDBC_URL, USERNAME, PASSWORD);            // 2. 插入数据            insertData(connection, "john_doe", "john@example.com");            // 3. 查询数据            retrieveData(connection, "john_doe");            // 4. 更新数据            updateData(connection, "john_doe", "new_email@example.com");            // 5. 删除数据            deleteData(connection, "john_doe");            // 6. 关闭连接            connection.close();        } catch (Exception e) {            e.printStackTrace();        }    }    // 插入数据    private static void insertData(Connection connection, String username, String email) throws SQLException {        String insertSQL = "INSERT INTO users (username, email) VALUES (?, ?)";        PreparedStatement preparedStatement = connection.prepareStatement(insertSQL);        preparedStatement.setString(1, username);        preparedStatement.setString(2, email);        int rowsInserted = preparedStatement.executeUpdate();        System.out.println(rowsInserted + " row(s) inserted.");        preparedStatement.close();    }    // 查询数据    private static void retrieveData(Connection connection, String username) throws SQLException {        String selectSQL = "SELECT * FROM users WHERE username = ?";        PreparedStatement preparedStatement = connection.prepareStatement(selectSQL);        preparedStatement.setString(1, username);        ResultSet resultSet = preparedStatement.executeQuery();        while (resultSet.next()) {            System.out.println("User ID: " + resultSet.getInt("id"));            System.out.println("Username: " + resultSet.getString("username"));            System.out.println("Email: " + resultSet.getString("email"));        }        preparedStatement.close();    }    // 更新数据    private static void updateData(Connection connection, String username, String newEmail) throws SQLException {        String updateSQL = "UPDATE users SET email = ? WHERE username = ?";        PreparedStatement preparedStatement = connection.prepareStatement(updateSQL);        preparedStatement.setString(1, newEmail);        preparedStatement.setString(2, username);        int rowsUpdated = preparedStatement.executeUpdate();        System.out.println(rowsUpdated + " row(s) updated.");        preparedStatement.close();    }    // 删除数据    private static void deleteData(Connection connection, String username) throws SQLException {        String deleteSQL = "DELETE FROM users WHERE username = ?";        PreparedStatement preparedStatement = connection.prepareStatement(deleteSQL);        preparedStatement.setString(1, username);        int rowsDeleted = preparedStatement.executeUpdate();        System.out.println(rowsDeleted + " row(s) deleted.");        preparedStatement.close();    }}</code></pre><h2 id="11-5-ResultSet"><a href="#11-5-ResultSet" class="headerlink" title="11.5 ResultSet"></a>11.5 ResultSet</h2><p>在 Java 中，你可以使用 <code>ResultSet</code> 对象来处理从数据库查询中获取的结果集。以下是一些常见的 <code>ResultSet</code> 操作：</p><ol><li><p><strong>遍历结果集</strong>：你可以使用 <code>while</code> 循环和 <code>resultSet.next()</code> 方法遍历结果集的每一行。在循环内部，你可以使用不同的 <code>getXXX</code> 方法来获取不同列的数据，例如 <code>getInt()</code>, <code>getString()</code>, <code>getDouble()</code> 等。</p><pre><code class="java">ResultSet resultSet = statement.executeQuery("SELECT * FROM my_table");while (resultSet.next()) {    int id = resultSet.getInt("id");    String name = resultSet.getString("name");    // 处理每一行数据}</code></pre></li><li><p><strong>获取单个列的数据</strong>：你可以使用 <code>getXXX</code> 方法来获取单个列的数据，例如 <code>getInt()</code>, <code>getString()</code>, <code>getDouble()</code> 等。方法的参数是列名或列索引。</p><pre><code class="java">int id = resultSet.getInt("id");String name = resultSet.getString("name");</code></pre></li><li><p><strong>检查列是否存在</strong>：你可以使用 <code>ResultSet</code> 的 <code>findColumn()</code> 方法来检查某列是否存在。</p><pre><code class="java">int columnIndex = resultSet.findColumn("columnName");if (columnIndex &gt; 0) {    // 列存在} else {    // 列不存在}</code></pre></li><li><p><strong>获取结果集的元数据</strong>：你可以使用 <code>ResultSet</code> 的 <code>getMetaData()</code> 方法来获取结果集的元数据，包括列数、列名等。</p><pre><code class="java">ResultSetMetaData metaData = resultSet.getMetaData();int columnCount = metaData.getColumnCount();String columnName = metaData.getColumnName(1);</code></pre></li><li><p><strong>定位到特定行</strong>：你可以使用 <code>ResultSet</code> 的 <code>absolute()</code> 方法将游标移动到结果集中的指定行。</p><pre><code class="java">resultSet.absolute(3); // 将游标移动到第 3 行</code></pre></li><li><p>**关闭 <code>ResultSet</code>**：在使用完 <code>ResultSet</code> 后，务必调用 <code>close()</code> 方法来释放资源。</p><pre><code class="java">resultSet.close();</code></pre></li></ol><h2 id="11-6-查询案例"><a href="#11-6-查询案例" class="headerlink" title="11.6 查询案例"></a>11.6 查询案例</h2><pre><code class="mysql">create database test;use test;CREATE TABLE user(    id int PRIMARY KEY,    name varchar(50),    age int,    sex varchar(50));alter table user change sex sex varchar(50) character set utf8;INSERT INTO `user`(`id`, `name`, `age`, `sex`) VALUES (1, 'shi', 20, '男');INSERT INTO `user`(`id`, `name`, `age`, `sex`) VALUES (2, 'yan', 13, '女');INSERT INTO `user`(`id`, `name`, `age`, `sex`) VALUES (3, 'lou', 22, '女');INSERT INTO `user`(`id`, `name`, `age`, `sex`) VALUES (4, 'admin', 50, '男');</code></pre><ul><li>查询 Id 为 1 的用户。</li><li>查询年龄为 13 岁，名字为 yan 的用户。</li></ul><pre><code class="java">import java.sql.Connection;import java.sql.DriverManager;import java.sql.PreparedStatement;import java.sql.ResultSet;public class JdbcTest {    static final String DB_URL = "jdbc:mysql://localhost/test";    static final String USER = "root";    static final String PASS = "";    public static void main(String[] args) {        try {            // 1. 创建数据库连接            Connection connection = DriverManager.getConnection(DB_URL, USER, PASS);            // 2. 执行第一个查询            String sql1 = "SELECT name FROM user WHERE id &gt;= 1";            PreparedStatement preparedStatement1 = connection.prepareStatement(sql1);            ResultSet resultSet1 = preparedStatement1.executeQuery();            System.out.println("id &gt;= 1");            while (resultSet1.next()) {                System.out.println(resultSet1.getString("name"));            }            // 3. 执行第二个查询            String sql2 = "SELECT * FROM user WHERE age = 13 and name = 'yan'";            PreparedStatement preparedStatement2 = connection.prepareStatement(sql2);            ResultSet resultSet2 = preparedStatement2.executeQuery();            System.out.println("find");            while (resultSet2.next()) {                System.out.println("name = " + resultSet2.getString("name"));                System.out.println("sex = " + resultSet2.getString("sex"));            }            // 4. 关闭资源            resultSet1.close();            preparedStatement1.close();            resultSet2.close();            preparedStatement2.close();            connection.close();        } catch (Exception e) {            e.printStackTrace();        }    }}</code></pre><h2 id="11-7-事务管理"><a href="#11-7-事务管理" class="headerlink" title="11.7 事务管理"></a>11.7 事务管理</h2><p>在 JDBC 中，你可以使用事务来管理数据库操作，以确保一组相关操作要么都成功提交，要么都回滚（撤销）。这是保证数据库操作的一致性和完整性的重要方式。</p><p>以下是在 JDBC 中进行事务管理的一般步骤：</p><ol><li><p><strong>开启事务</strong>：在执行 SQL 操作之前，你可以通过将自动提交（Auto-Commit）设置为 <code>false</code> 来开启事务。默认情况下，JDBC 是自动提交的，每个 SQL 语句都会立即生效。</p><pre><code class="java">connection.setAutoCommit(false); // 关闭自动提交</code></pre></li><li><p><strong>执行数据库操作</strong>：在事务中执行你的数据库操作，包括插入、更新、删除等。</p><pre><code class="java">// 执行数据库操作，例如 INSERT、UPDATE、DELETE</code></pre></li><li><p><strong>提交事务</strong>：如果所有的数据库操作都成功，你可以使用 <code>commit</code> 方法提交事务，使更改永久生效。</p><pre><code class="java">connection.commit(); // 提交事务</code></pre></li><li><p><strong>回滚事务</strong>：如果发生错误或某些操作失败，你可以使用 <code>rollback</code> 方法来回滚事务，使之前的更改不会生效。</p><pre><code class="java">connection.rollback(); // 回滚事务</code></pre></li><li><p><strong>关闭连接</strong>：最后，记得在完成事务后关闭数据库连接。</p><pre><code class="java">connection.close(); // 关闭数据库连接</code></pre></li></ol><p>下面是一个示例代码，演示了如何在 JDBC 中管理事务：</p><pre><code class="java">import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;import java.sql.Statement;public class JdbcTransactionExample {    public static void main(String[] args) {        String jdbcUrl = "jdbc:mysql://localhost:3306/your_database";        String username = "your_username";        String password = "your_password";        try (Connection connection = DriverManager.getConnection(jdbcUrl, username, password)) {            connection.setAutoCommit(false); // 开启事务            try {                // 执行一些数据库操作                Statement statement = connection.createStatement();                statement.execute("INSERT INTO users (name, age) VALUES ('John', 30)");                statement.execute("UPDATE users SET age = 31 WHERE name = 'John'");                statement.execute("DELETE FROM users WHERE name = 'John'");                connection.commit(); // 提交事务                System.out.println("Transaction committed successfully.");            } catch (SQLException e) {                connection.rollback(); // 回滚事务                System.err.println("Transaction rolled back due to an error: " + e.getMessage());            }        } catch (SQLException e) {            e.printStackTrace();        }    }}</code></pre><p>在这个示例中，我们首先将自动提交关闭，然后执行一系列数据库操作。如果操作都成功，我们提交事务。如果任何操作失败，我们回滚事务，以确保之前的更改不会生效。这样，你可以确保一组相关的操作要么全部成功，要么全部失败。</p><h1 id="12-反射"><a href="#12-反射" class="headerlink" title="12 反射"></a>12 反射</h1><p>在Java中，反射（Reflection）是一种强大的机制，允许程序在运行时检查、获取和操作类、对象、方法、字段等程序元素的信息，而不需要在编译时确定这些元素的类型。反射提供了一种途径，使你能够在运行时动态地获取和操作类的成员，而不必事先知道这些成员的名称或类型。这对于编写通用工具、框架和调试器非常有用。</p><p>在Java的反射机制中，有一些常用的类和接口，以下是其中一些主要的类和它们的用途：</p><ol><li>**<code>java.lang.Class</code>**：<code>Class</code>类代表一个类的运行时类型信息。你可以使用它来获取类的各种信息，如类名、字段、方法、构造方法、父类、接口等。</li><li>**<code>java.lang.reflect.Field</code>**：<code>Field</code>类用于表示类中的字段（成员变量）。你可以使用它来获取和设置字段的值，包括私有字段。</li><li>**<code>java.lang.reflect.Method</code>**：<code>Method</code>类用于表示类中的方法。你可以使用它来调用类的方法，包括私有方法。</li><li>**<code>java.lang.reflect.Constructor</code>**：<code>Constructor</code>类用于表示类的构造方法。你可以使用它来实例化类的对象。</li><li>**<code>java.lang.reflect.Modifier</code>**：<code>Modifier</code>类包含了一组用于解析修饰符的静态方法，如<code>isPublic()</code>、<code>isStatic()</code>等。</li><li>**<code>java.lang.reflect.Array</code>**：<code>Array</code>类提供了创建和操作数组的静态方法，如<code>newInstance()</code>和<code>getLength()</code>。</li></ol><p>使用这些类，你可以实现反射的各种功能。以下是使用反射的一般步骤：</p><ol><li>获取类的<code>Class</code>对象，通常使用<code>.class</code>关键字或<code>getClass()</code>方法。</li><li>使用<code>Class</code>对象获取类的信息，如字段、方法或构造方法，通过<code>getFields()</code>, <code>getDeclaredFields()</code>, <code>getMethods()</code>, <code>getDeclaredMethods()</code>, <code>getConstructors()</code>, <code>getDeclaredConstructors()</code>等方法。</li><li>创建类的对象，可以使用<code>Constructor</code>对象的<code>newInstance()</code>方法。</li><li>操作字段和调用方法，使用<code>Field</code>对象的<code>get()</code>和<code>set()</code>方法，以及<code>Method</code>对象的<code>invoke()</code>方法。</li><li>处理异常，因为反射可能引发<code>NoSuchMethodException</code>、<code>IllegalAccessException</code>等异常，需要适当捕获和处理。</li></ol><pre><code class="JAVA">public class Person {    private String name;    private int age;    public Person(String name, int age) {        this.name = name;        this.age = age;    }    public String getName() {        return name;    }    public int getAge() {        return age;    }    public void sayHello() {        System.out.println("Hello, my name is " + name);    }}</code></pre><pre><code class="JAVA">import java.lang.reflect.*;public class ReflectionExample {    public static void main(String[] args) throws Exception {        // 1. 获取类的Class对象        Class&lt;?&gt; personClass = Class.forName("Person");        // 2. 创建对象        Constructor&lt;?&gt; constructor = personClass.getConstructor(String.class, int.class);        Object person = constructor.newInstance("Alice", 30);        // 3. 访问字段        Field nameField = personClass.getDeclaredField("name");        nameField.setAccessible(true);        String name = (String) nameField.get(person);        Field ageField = personClass.getDeclaredField("age");        ageField.setAccessible(true);        int age = (int) ageField.get(person);        System.out.println("Name: " + name);        System.out.println("Age: " + age);        // 4. 调用方法        Method sayHelloMethod = personClass.getDeclaredMethod("sayHello");        sayHelloMethod.setAccessible(true);        sayHelloMethod.invoke(person);    }}</code></pre><h2 id="13-正则表达式"><a href="#13-正则表达式" class="headerlink" title="13 正则表达式"></a>13 正则表达式</h2><h2 id="13-1-用法"><a href="#13-1-用法" class="headerlink" title="13.1 用法"></a>13.1 用法</h2><ol><li>导入正则表达式的库：</li></ol><pre><code class="java">import java.util.regex.*;</code></pre><ol><li>创建正则表达式模式对象（Pattern对象）：</li></ol><pre><code class="java">Pattern pattern = Pattern.compile("正则表达式");</code></pre><ol><li>创建匹配器对象（Matcher对象）并使用模式匹配字符串：</li></ol><pre><code class="java">Matcher matcher = pattern.matcher("要匹配的字符串");</code></pre><ol><li>使用匹配器对象进行匹配操作，并根据需要获取匹配结果：</li></ol><pre><code class="java">if (matcher.find()) {    // 找到匹配    String matchedText = matcher.group(); // 获取匹配的文本    // 进行其他操作} else {    // 没有找到匹配}</code></pre><p>以下是一些常见的正则表达式用法示例：</p><ul><li><strong>查找匹配</strong>：使用 <code>find()</code> 方法查找字符串中是否包含匹配正则表达式的部分。</li></ul><pre><code class="java">Pattern pattern = Pattern.compile("\\d+"); // 匹配一个或多个数字Matcher matcher = pattern.matcher("12345 Hello 6789");while (matcher.find()) {    String matchedText = matcher.group();    System.out.println("匹配到: " + matchedText);}</code></pre><ul><li><strong>替换</strong>：使用 <code>replaceAll()</code> 方法将匹配的部分替换为指定的文本。</li></ul><pre><code class="java">String input = "Hello, World!";String result = input.replaceAll("World", "Java");System.out.println(result); // 输出: "Hello, Java!"</code></pre><ul><li><strong>分割</strong>：使用 <code>split()</code> 方法根据正则表达式分割字符串。</li></ul><pre><code class="java">String input = "apple,banana,grape";String[] fruits = input.split(",");for (String fruit : fruits) {    System.out.println(fruit);}</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/09/18/guai/"/>
      <url>/2023/09/18/guai/</url>
      
        <content type="html"><![CDATA[<h1 id="发现了一只乖乖猪"><a href="#发现了一只乖乖猪" class="headerlink" title="发现了一只乖乖猪~"></a>发现了一只乖乖猪~</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/09/18/text/"/>
      <url>/2023/09/18/text/</url>
      
        <content type="html"><![CDATA[<h1 id="大标题"><a href="#大标题" class="headerlink" title="大标题"></a>大标题</h1><h2 id="小标题"><a href="#小标题" class="headerlink" title="小标题"></a>小标题</h2><p>正文</p><pre><code class="c++">#include &lt;isotream&gt;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/09/18/hello-world/"/>
      <url>/2023/09/18/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new "My New Post"</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
